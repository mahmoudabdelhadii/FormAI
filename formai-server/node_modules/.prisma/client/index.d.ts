
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model AdminToken
 * 
 */
export type AdminToken = $Result.DefaultSelection<Prisma.$AdminTokenPayload>
/**
 * Model BannedUsers
 * 
 */
export type BannedUsers = $Result.DefaultSelection<Prisma.$BannedUsersPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Community
 * 
 */
export type Community = $Result.DefaultSelection<Prisma.$CommunityPayload>
/**
 * Model CommunityRequest
 * 
 */
export type CommunityRequest = $Result.DefaultSelection<Prisma.$CommunityRequestPayload>
/**
 * Model Context
 * 
 */
export type Context = $Result.DefaultSelection<Prisma.$ContextPayload>
/**
 * Model Leaderboard
 * 
 */
export type Leaderboard = $Result.DefaultSelection<Prisma.$LeaderboardPayload>
/**
 * Model LeaderboardEntry
 * 
 */
export type LeaderboardEntry = $Result.DefaultSelection<Prisma.$LeaderboardEntryPayload>
/**
 * Model Like
 * 
 */
export type Like = $Result.DefaultSelection<Prisma.$LikePayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>
/**
 * Model PendingPost
 * 
 */
export type PendingPost = $Result.DefaultSelection<Prisma.$PendingPostPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Preferences
 * 
 */
export type Preferences = $Result.DefaultSelection<Prisma.$PreferencesPayload>
/**
 * Model Relationship
 * 
 */
export type Relationship = $Result.DefaultSelection<Prisma.$RelationshipPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model Token
 * 
 */
export type Token = $Result.DefaultSelection<Prisma.$TokenPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs>;

  /**
   * `prisma.adminToken`: Exposes CRUD operations for the **AdminToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminTokens
    * const adminTokens = await prisma.adminToken.findMany()
    * ```
    */
  get adminToken(): Prisma.AdminTokenDelegate<ExtArgs>;

  /**
   * `prisma.bannedUsers`: Exposes CRUD operations for the **BannedUsers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BannedUsers
    * const bannedUsers = await prisma.bannedUsers.findMany()
    * ```
    */
  get bannedUsers(): Prisma.BannedUsersDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.community`: Exposes CRUD operations for the **Community** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Communities
    * const communities = await prisma.community.findMany()
    * ```
    */
  get community(): Prisma.CommunityDelegate<ExtArgs>;

  /**
   * `prisma.communityRequest`: Exposes CRUD operations for the **CommunityRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityRequests
    * const communityRequests = await prisma.communityRequest.findMany()
    * ```
    */
  get communityRequest(): Prisma.CommunityRequestDelegate<ExtArgs>;

  /**
   * `prisma.context`: Exposes CRUD operations for the **Context** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contexts
    * const contexts = await prisma.context.findMany()
    * ```
    */
  get context(): Prisma.ContextDelegate<ExtArgs>;

  /**
   * `prisma.leaderboard`: Exposes CRUD operations for the **Leaderboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaderboards
    * const leaderboards = await prisma.leaderboard.findMany()
    * ```
    */
  get leaderboard(): Prisma.LeaderboardDelegate<ExtArgs>;

  /**
   * `prisma.leaderboardEntry`: Exposes CRUD operations for the **LeaderboardEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaderboardEntries
    * const leaderboardEntries = await prisma.leaderboardEntry.findMany()
    * ```
    */
  get leaderboardEntry(): Prisma.LeaderboardEntryDelegate<ExtArgs>;

  /**
   * `prisma.like`: Exposes CRUD operations for the **Like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.like.findMany()
    * ```
    */
  get like(): Prisma.LikeDelegate<ExtArgs>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs>;

  /**
   * `prisma.pendingPost`: Exposes CRUD operations for the **PendingPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingPosts
    * const pendingPosts = await prisma.pendingPost.findMany()
    * ```
    */
  get pendingPost(): Prisma.PendingPostDelegate<ExtArgs>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs>;

  /**
   * `prisma.preferences`: Exposes CRUD operations for the **Preferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Preferences
    * const preferences = await prisma.preferences.findMany()
    * ```
    */
  get preferences(): Prisma.PreferencesDelegate<ExtArgs>;

  /**
   * `prisma.relationship`: Exposes CRUD operations for the **Relationship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Relationships
    * const relationships = await prisma.relationship.findMany()
    * ```
    */
  get relationship(): Prisma.RelationshipDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.token`: Exposes CRUD operations for the **Token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.token.findMany()
    * ```
    */
  get token(): Prisma.TokenDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.12.1
   * Query Engine version: 473ed3124229e22d881cb7addf559799debae1ab
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Admin: 'Admin',
    AdminToken: 'AdminToken',
    BannedUsers: 'BannedUsers',
    Comment: 'Comment',
    Community: 'Community',
    CommunityRequest: 'CommunityRequest',
    Context: 'Context',
    Leaderboard: 'Leaderboard',
    LeaderboardEntry: 'LeaderboardEntry',
    Like: 'Like',
    Log: 'Log',
    PendingPost: 'PendingPost',
    Post: 'Post',
    Preferences: 'Preferences',
    Relationship: 'Relationship',
    Report: 'Report',
    Token: 'Token',
    User: 'User'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'admin' | 'adminToken' | 'bannedUsers' | 'comment' | 'community' | 'communityRequest' | 'context' | 'leaderboard' | 'leaderboardEntry' | 'like' | 'log' | 'pendingPost' | 'post' | 'preferences' | 'relationship' | 'report' | 'token' | 'user'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>,
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      AdminToken: {
        payload: Prisma.$AdminTokenPayload<ExtArgs>
        fields: Prisma.AdminTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminTokenPayload>
          }
          findFirst: {
            args: Prisma.AdminTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminTokenPayload>
          }
          findMany: {
            args: Prisma.AdminTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminTokenPayload>[]
          }
          create: {
            args: Prisma.AdminTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminTokenPayload>
          }
          createMany: {
            args: Prisma.AdminTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdminTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminTokenPayload>
          }
          update: {
            args: Prisma.AdminTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminTokenPayload>
          }
          deleteMany: {
            args: Prisma.AdminTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdminTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdminTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminTokenPayload>
          }
          aggregate: {
            args: Prisma.AdminTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdminToken>
          }
          groupBy: {
            args: Prisma.AdminTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdminTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<AdminTokenCountAggregateOutputType> | number
          }
        }
      }
      BannedUsers: {
        payload: Prisma.$BannedUsersPayload<ExtArgs>
        fields: Prisma.BannedUsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannedUsersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannedUsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannedUsersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannedUsersPayload>
          }
          findFirst: {
            args: Prisma.BannedUsersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannedUsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannedUsersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannedUsersPayload>
          }
          findMany: {
            args: Prisma.BannedUsersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannedUsersPayload>[]
          }
          create: {
            args: Prisma.BannedUsersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannedUsersPayload>
          }
          createMany: {
            args: Prisma.BannedUsersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BannedUsersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannedUsersPayload>
          }
          update: {
            args: Prisma.BannedUsersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannedUsersPayload>
          }
          deleteMany: {
            args: Prisma.BannedUsersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BannedUsersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BannedUsersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannedUsersPayload>
          }
          aggregate: {
            args: Prisma.BannedUsersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBannedUsers>
          }
          groupBy: {
            args: Prisma.BannedUsersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BannedUsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannedUsersCountArgs<ExtArgs>,
            result: $Utils.Optional<BannedUsersCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>,
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Community: {
        payload: Prisma.$CommunityPayload<ExtArgs>
        fields: Prisma.CommunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          findFirst: {
            args: Prisma.CommunityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          findMany: {
            args: Prisma.CommunityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>[]
          }
          create: {
            args: Prisma.CommunityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          createMany: {
            args: Prisma.CommunityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommunityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          update: {
            args: Prisma.CommunityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          deleteMany: {
            args: Prisma.CommunityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommunityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          aggregate: {
            args: Prisma.CommunityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCommunity>
          }
          groupBy: {
            args: Prisma.CommunityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityCountArgs<ExtArgs>,
            result: $Utils.Optional<CommunityCountAggregateOutputType> | number
          }
        }
      }
      CommunityRequest: {
        payload: Prisma.$CommunityRequestPayload<ExtArgs>
        fields: Prisma.CommunityRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityRequestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityRequestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityRequestPayload>
          }
          findFirst: {
            args: Prisma.CommunityRequestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityRequestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityRequestPayload>
          }
          findMany: {
            args: Prisma.CommunityRequestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityRequestPayload>[]
          }
          create: {
            args: Prisma.CommunityRequestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityRequestPayload>
          }
          createMany: {
            args: Prisma.CommunityRequestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommunityRequestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityRequestPayload>
          }
          update: {
            args: Prisma.CommunityRequestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityRequestPayload>
          }
          deleteMany: {
            args: Prisma.CommunityRequestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityRequestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommunityRequestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityRequestPayload>
          }
          aggregate: {
            args: Prisma.CommunityRequestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCommunityRequest>
          }
          groupBy: {
            args: Prisma.CommunityRequestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommunityRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityRequestCountArgs<ExtArgs>,
            result: $Utils.Optional<CommunityRequestCountAggregateOutputType> | number
          }
        }
      }
      Context: {
        payload: Prisma.$ContextPayload<ExtArgs>
        fields: Prisma.ContextFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContextFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContextPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContextFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContextPayload>
          }
          findFirst: {
            args: Prisma.ContextFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContextPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContextFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContextPayload>
          }
          findMany: {
            args: Prisma.ContextFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContextPayload>[]
          }
          create: {
            args: Prisma.ContextCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContextPayload>
          }
          createMany: {
            args: Prisma.ContextCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContextDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContextPayload>
          }
          update: {
            args: Prisma.ContextUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContextPayload>
          }
          deleteMany: {
            args: Prisma.ContextDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContextUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContextUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContextPayload>
          }
          aggregate: {
            args: Prisma.ContextAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContext>
          }
          groupBy: {
            args: Prisma.ContextGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContextGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContextCountArgs<ExtArgs>,
            result: $Utils.Optional<ContextCountAggregateOutputType> | number
          }
        }
      }
      Leaderboard: {
        payload: Prisma.$LeaderboardPayload<ExtArgs>
        fields: Prisma.LeaderboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaderboardFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaderboardFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          findFirst: {
            args: Prisma.LeaderboardFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaderboardFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          findMany: {
            args: Prisma.LeaderboardFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>[]
          }
          create: {
            args: Prisma.LeaderboardCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          createMany: {
            args: Prisma.LeaderboardCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LeaderboardDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          update: {
            args: Prisma.LeaderboardUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          deleteMany: {
            args: Prisma.LeaderboardDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LeaderboardUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LeaderboardUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          aggregate: {
            args: Prisma.LeaderboardAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLeaderboard>
          }
          groupBy: {
            args: Prisma.LeaderboardGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LeaderboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaderboardCountArgs<ExtArgs>,
            result: $Utils.Optional<LeaderboardCountAggregateOutputType> | number
          }
        }
      }
      LeaderboardEntry: {
        payload: Prisma.$LeaderboardEntryPayload<ExtArgs>
        fields: Prisma.LeaderboardEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaderboardEntryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          findFirst: {
            args: Prisma.LeaderboardEntryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaderboardEntryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          findMany: {
            args: Prisma.LeaderboardEntryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>[]
          }
          create: {
            args: Prisma.LeaderboardEntryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          createMany: {
            args: Prisma.LeaderboardEntryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LeaderboardEntryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          update: {
            args: Prisma.LeaderboardEntryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          deleteMany: {
            args: Prisma.LeaderboardEntryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LeaderboardEntryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LeaderboardEntryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          aggregate: {
            args: Prisma.LeaderboardEntryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLeaderboardEntry>
          }
          groupBy: {
            args: Prisma.LeaderboardEntryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LeaderboardEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaderboardEntryCountArgs<ExtArgs>,
            result: $Utils.Optional<LeaderboardEntryCountAggregateOutputType> | number
          }
        }
      }
      Like: {
        payload: Prisma.$LikePayload<ExtArgs>
        fields: Prisma.LikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findFirst: {
            args: Prisma.LikeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findMany: {
            args: Prisma.LikeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          create: {
            args: Prisma.LikeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          createMany: {
            args: Prisma.LikeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LikeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          update: {
            args: Prisma.LikeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          deleteMany: {
            args: Prisma.LikeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LikeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LikeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          aggregate: {
            args: Prisma.LikeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLike>
          }
          groupBy: {
            args: Prisma.LikeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikeCountArgs<ExtArgs>,
            result: $Utils.Optional<LikeCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>,
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      PendingPost: {
        payload: Prisma.$PendingPostPayload<ExtArgs>
        fields: Prisma.PendingPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendingPostFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendingPostFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostPayload>
          }
          findFirst: {
            args: Prisma.PendingPostFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendingPostFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostPayload>
          }
          findMany: {
            args: Prisma.PendingPostFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostPayload>[]
          }
          create: {
            args: Prisma.PendingPostCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostPayload>
          }
          createMany: {
            args: Prisma.PendingPostCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PendingPostDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostPayload>
          }
          update: {
            args: Prisma.PendingPostUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostPayload>
          }
          deleteMany: {
            args: Prisma.PendingPostDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PendingPostUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PendingPostUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostPayload>
          }
          aggregate: {
            args: Prisma.PendingPostAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePendingPost>
          }
          groupBy: {
            args: Prisma.PendingPostGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PendingPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendingPostCountArgs<ExtArgs>,
            result: $Utils.Optional<PendingPostCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>,
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Preferences: {
        payload: Prisma.$PreferencesPayload<ExtArgs>
        fields: Prisma.PreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PreferencesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PreferencesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>
          }
          findFirst: {
            args: Prisma.PreferencesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PreferencesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>
          }
          findMany: {
            args: Prisma.PreferencesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>[]
          }
          create: {
            args: Prisma.PreferencesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>
          }
          createMany: {
            args: Prisma.PreferencesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PreferencesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>
          }
          update: {
            args: Prisma.PreferencesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>
          }
          deleteMany: {
            args: Prisma.PreferencesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PreferencesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PreferencesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>
          }
          aggregate: {
            args: Prisma.PreferencesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePreferences>
          }
          groupBy: {
            args: Prisma.PreferencesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.PreferencesCountArgs<ExtArgs>,
            result: $Utils.Optional<PreferencesCountAggregateOutputType> | number
          }
        }
      }
      Relationship: {
        payload: Prisma.$RelationshipPayload<ExtArgs>
        fields: Prisma.RelationshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelationshipFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelationshipFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          findFirst: {
            args: Prisma.RelationshipFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelationshipFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          findMany: {
            args: Prisma.RelationshipFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>[]
          }
          create: {
            args: Prisma.RelationshipCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          createMany: {
            args: Prisma.RelationshipCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RelationshipDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          update: {
            args: Prisma.RelationshipUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          deleteMany: {
            args: Prisma.RelationshipDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RelationshipUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RelationshipUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          aggregate: {
            args: Prisma.RelationshipAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRelationship>
          }
          groupBy: {
            args: Prisma.RelationshipGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RelationshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelationshipCountArgs<ExtArgs>,
            result: $Utils.Optional<RelationshipCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>,
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      Token: {
        payload: Prisma.$TokenPayload<ExtArgs>
        fields: Prisma.TokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findFirst: {
            args: Prisma.TokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findMany: {
            args: Prisma.TokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          create: {
            args: Prisma.TokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          createMany: {
            args: Prisma.TokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          update: {
            args: Prisma.TokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          deleteMany: {
            args: Prisma.TokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          aggregate: {
            args: Prisma.TokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateToken>
          }
          groupBy: {
            args: Prisma.TokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenCountArgs<ExtArgs>,
            result: $Utils.Optional<TokenCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CommunityCountOutputType
   */

  export type CommunityCountOutputType = {
    BannedUsers: number
    CommunityRequest: number
    Leaderboard: number
    LeaderboardEntry: number
    PendingPost: number
    Post: number
    Report: number
  }

  export type CommunityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BannedUsers?: boolean | CommunityCountOutputTypeCountBannedUsersArgs
    CommunityRequest?: boolean | CommunityCountOutputTypeCountCommunityRequestArgs
    Leaderboard?: boolean | CommunityCountOutputTypeCountLeaderboardArgs
    LeaderboardEntry?: boolean | CommunityCountOutputTypeCountLeaderboardEntryArgs
    PendingPost?: boolean | CommunityCountOutputTypeCountPendingPostArgs
    Post?: boolean | CommunityCountOutputTypeCountPostArgs
    Report?: boolean | CommunityCountOutputTypeCountReportArgs
  }

  // Custom InputTypes

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCountOutputType
     */
    select?: CommunityCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountBannedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannedUsersWhereInput
  }


  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountCommunityRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityRequestWhereInput
  }


  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountLeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardWhereInput
  }


  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountLeaderboardEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardEntryWhereInput
  }


  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountPendingPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingPostWhereInput
  }


  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }



  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    Comment: number
    Report: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | PostCountOutputTypeCountCommentArgs
    Report?: boolean | PostCountOutputTypeCountReportArgs
  }

  // Custom InputTypes

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    BannedUsers: number
    CommunityRequest: number
    Context: number
    LeaderboardEntry: number
    PendingPost: number
    Post: number
    Preferences: number
    Relationship_Relationship_followerToUser: number
    Relationship_Relationship_followingToUser: number
    Report: number
    Token: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BannedUsers?: boolean | UserCountOutputTypeCountBannedUsersArgs
    CommunityRequest?: boolean | UserCountOutputTypeCountCommunityRequestArgs
    Context?: boolean | UserCountOutputTypeCountContextArgs
    LeaderboardEntry?: boolean | UserCountOutputTypeCountLeaderboardEntryArgs
    PendingPost?: boolean | UserCountOutputTypeCountPendingPostArgs
    Post?: boolean | UserCountOutputTypeCountPostArgs
    Preferences?: boolean | UserCountOutputTypeCountPreferencesArgs
    Relationship_Relationship_followerToUser?: boolean | UserCountOutputTypeCountRelationship_Relationship_followerToUserArgs
    Relationship_Relationship_followingToUser?: boolean | UserCountOutputTypeCountRelationship_Relationship_followingToUserArgs
    Report?: boolean | UserCountOutputTypeCountReportArgs
    Token?: boolean | UserCountOutputTypeCountTokenArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBannedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannedUsersWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommunityRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityRequestWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContextArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContextWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaderboardEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardEntryWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPendingPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingPostWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferencesWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRelationship_Relationship_followerToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationshipWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRelationship_Relationship_followingToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationshipWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    username: number
    password: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    username: string | null
    password: string | null
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
  }


  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string | null
      password: string | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }


  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
    **/
    create<T extends AdminCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminCreateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Admins.
     *     @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     *     @example
     *     // Create many Admins
     *     const admin = await prisma.admin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
    **/
    delete<T extends AdminDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
    **/
    upsert<T extends AdminUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly username: FieldRef<"Admin", 'String'>
    readonly password: FieldRef<"Admin", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data?: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }


  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }


  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }


  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }


  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
  }



  /**
   * Model AdminToken
   */

  export type AggregateAdminToken = {
    _count: AdminTokenCountAggregateOutputType | null
    _avg: AdminTokenAvgAggregateOutputType | null
    _sum: AdminTokenSumAggregateOutputType | null
    _min: AdminTokenMinAggregateOutputType | null
    _max: AdminTokenMaxAggregateOutputType | null
  }

  export type AdminTokenAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminTokenSumAggregateOutputType = {
    id: number | null
  }

  export type AdminTokenMinAggregateOutputType = {
    id: number | null
    user: string | null
    accessToken: string | null
  }

  export type AdminTokenMaxAggregateOutputType = {
    id: number | null
    user: string | null
    accessToken: string | null
  }

  export type AdminTokenCountAggregateOutputType = {
    id: number
    user: number
    accessToken: number
    _all: number
  }


  export type AdminTokenAvgAggregateInputType = {
    id?: true
  }

  export type AdminTokenSumAggregateInputType = {
    id?: true
  }

  export type AdminTokenMinAggregateInputType = {
    id?: true
    user?: true
    accessToken?: true
  }

  export type AdminTokenMaxAggregateInputType = {
    id?: true
    user?: true
    accessToken?: true
  }

  export type AdminTokenCountAggregateInputType = {
    id?: true
    user?: true
    accessToken?: true
    _all?: true
  }

  export type AdminTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminToken to aggregate.
     */
    where?: AdminTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTokens to fetch.
     */
    orderBy?: AdminTokenOrderByWithRelationInput | AdminTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminTokens
    **/
    _count?: true | AdminTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminTokenMaxAggregateInputType
  }

  export type GetAdminTokenAggregateType<T extends AdminTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminToken[P]>
      : GetScalarType<T[P], AggregateAdminToken[P]>
  }




  export type AdminTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminTokenWhereInput
    orderBy?: AdminTokenOrderByWithAggregationInput | AdminTokenOrderByWithAggregationInput[]
    by: AdminTokenScalarFieldEnum[] | AdminTokenScalarFieldEnum
    having?: AdminTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminTokenCountAggregateInputType | true
    _avg?: AdminTokenAvgAggregateInputType
    _sum?: AdminTokenSumAggregateInputType
    _min?: AdminTokenMinAggregateInputType
    _max?: AdminTokenMaxAggregateInputType
  }

  export type AdminTokenGroupByOutputType = {
    id: number
    user: string | null
    accessToken: string | null
    _count: AdminTokenCountAggregateOutputType | null
    _avg: AdminTokenAvgAggregateOutputType | null
    _sum: AdminTokenSumAggregateOutputType | null
    _min: AdminTokenMinAggregateOutputType | null
    _max: AdminTokenMaxAggregateOutputType | null
  }

  type GetAdminTokenGroupByPayload<T extends AdminTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminTokenGroupByOutputType[P]>
            : GetScalarType<T[P], AdminTokenGroupByOutputType[P]>
        }
      >
    >


  export type AdminTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user?: boolean
    accessToken?: boolean
  }, ExtArgs["result"]["adminToken"]>

  export type AdminTokenSelectScalar = {
    id?: boolean
    user?: boolean
    accessToken?: boolean
  }


  export type $AdminTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user: string | null
      accessToken: string | null
    }, ExtArgs["result"]["adminToken"]>
    composites: {}
  }


  type AdminTokenGetPayload<S extends boolean | null | undefined | AdminTokenDefaultArgs> = $Result.GetResult<Prisma.$AdminTokenPayload, S>

  type AdminTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminTokenCountAggregateInputType | true
    }

  export interface AdminTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminToken'], meta: { name: 'AdminToken' } }
    /**
     * Find zero or one AdminToken that matches the filter.
     * @param {AdminTokenFindUniqueArgs} args - Arguments to find a AdminToken
     * @example
     * // Get one AdminToken
     * const adminToken = await prisma.adminToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminTokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdminTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__AdminTokenClient<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AdminToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdminTokenFindUniqueOrThrowArgs} args - Arguments to find a AdminToken
     * @example
     * // Get one AdminToken
     * const adminToken = await prisma.adminToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdminTokenClient<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AdminToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTokenFindFirstArgs} args - Arguments to find a AdminToken
     * @example
     * // Get one AdminToken
     * const adminToken = await prisma.adminToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminTokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminTokenFindFirstArgs<ExtArgs>>
    ): Prisma__AdminTokenClient<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AdminToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTokenFindFirstOrThrowArgs} args - Arguments to find a AdminToken
     * @example
     * // Get one AdminToken
     * const adminToken = await prisma.adminToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdminTokenClient<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AdminTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminTokens
     * const adminTokens = await prisma.adminToken.findMany()
     * 
     * // Get first 10 AdminTokens
     * const adminTokens = await prisma.adminToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminTokenWithIdOnly = await prisma.adminToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AdminToken.
     * @param {AdminTokenCreateArgs} args - Arguments to create a AdminToken.
     * @example
     * // Create one AdminToken
     * const AdminToken = await prisma.adminToken.create({
     *   data: {
     *     // ... data to create a AdminToken
     *   }
     * })
     * 
    **/
    create<T extends AdminTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminTokenCreateArgs<ExtArgs>>
    ): Prisma__AdminTokenClient<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AdminTokens.
     *     @param {AdminTokenCreateManyArgs} args - Arguments to create many AdminTokens.
     *     @example
     *     // Create many AdminTokens
     *     const adminToken = await prisma.adminToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdminToken.
     * @param {AdminTokenDeleteArgs} args - Arguments to delete one AdminToken.
     * @example
     * // Delete one AdminToken
     * const AdminToken = await prisma.adminToken.delete({
     *   where: {
     *     // ... filter to delete one AdminToken
     *   }
     * })
     * 
    **/
    delete<T extends AdminTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdminTokenDeleteArgs<ExtArgs>>
    ): Prisma__AdminTokenClient<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AdminToken.
     * @param {AdminTokenUpdateArgs} args - Arguments to update one AdminToken.
     * @example
     * // Update one AdminToken
     * const adminToken = await prisma.adminToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminTokenUpdateArgs<ExtArgs>>
    ): Prisma__AdminTokenClient<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AdminTokens.
     * @param {AdminTokenDeleteManyArgs} args - Arguments to filter AdminTokens to delete.
     * @example
     * // Delete a few AdminTokens
     * const { count } = await prisma.adminToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminTokens
     * const adminToken = await prisma.adminToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdminTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminToken.
     * @param {AdminTokenUpsertArgs} args - Arguments to update or create a AdminToken.
     * @example
     * // Update or create a AdminToken
     * const adminToken = await prisma.adminToken.upsert({
     *   create: {
     *     // ... data to create a AdminToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminToken we want to update
     *   }
     * })
    **/
    upsert<T extends AdminTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdminTokenUpsertArgs<ExtArgs>>
    ): Prisma__AdminTokenClient<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AdminTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTokenCountArgs} args - Arguments to filter AdminTokens to count.
     * @example
     * // Count the number of AdminTokens
     * const count = await prisma.adminToken.count({
     *   where: {
     *     // ... the filter for the AdminTokens we want to count
     *   }
     * })
    **/
    count<T extends AdminTokenCountArgs>(
      args?: Subset<T, AdminTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminTokenAggregateArgs>(args: Subset<T, AdminTokenAggregateArgs>): Prisma.PrismaPromise<GetAdminTokenAggregateType<T>>

    /**
     * Group by AdminToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminTokenGroupByArgs['orderBy'] }
        : { orderBy?: AdminTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminToken model
   */
  readonly fields: AdminTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AdminToken model
   */ 
  interface AdminTokenFieldRefs {
    readonly id: FieldRef<"AdminToken", 'Int'>
    readonly user: FieldRef<"AdminToken", 'String'>
    readonly accessToken: FieldRef<"AdminToken", 'String'>
  }
    

  // Custom InputTypes

  /**
   * AdminToken findUnique
   */
  export type AdminTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * Filter, which AdminToken to fetch.
     */
    where: AdminTokenWhereUniqueInput
  }


  /**
   * AdminToken findUniqueOrThrow
   */
  export type AdminTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * Filter, which AdminToken to fetch.
     */
    where: AdminTokenWhereUniqueInput
  }


  /**
   * AdminToken findFirst
   */
  export type AdminTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * Filter, which AdminToken to fetch.
     */
    where?: AdminTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTokens to fetch.
     */
    orderBy?: AdminTokenOrderByWithRelationInput | AdminTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminTokens.
     */
    cursor?: AdminTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminTokens.
     */
    distinct?: AdminTokenScalarFieldEnum | AdminTokenScalarFieldEnum[]
  }


  /**
   * AdminToken findFirstOrThrow
   */
  export type AdminTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * Filter, which AdminToken to fetch.
     */
    where?: AdminTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTokens to fetch.
     */
    orderBy?: AdminTokenOrderByWithRelationInput | AdminTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminTokens.
     */
    cursor?: AdminTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminTokens.
     */
    distinct?: AdminTokenScalarFieldEnum | AdminTokenScalarFieldEnum[]
  }


  /**
   * AdminToken findMany
   */
  export type AdminTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * Filter, which AdminTokens to fetch.
     */
    where?: AdminTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTokens to fetch.
     */
    orderBy?: AdminTokenOrderByWithRelationInput | AdminTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminTokens.
     */
    cursor?: AdminTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTokens.
     */
    skip?: number
    distinct?: AdminTokenScalarFieldEnum | AdminTokenScalarFieldEnum[]
  }


  /**
   * AdminToken create
   */
  export type AdminTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a AdminToken.
     */
    data?: XOR<AdminTokenCreateInput, AdminTokenUncheckedCreateInput>
  }


  /**
   * AdminToken createMany
   */
  export type AdminTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminTokens.
     */
    data: AdminTokenCreateManyInput | AdminTokenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AdminToken update
   */
  export type AdminTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a AdminToken.
     */
    data: XOR<AdminTokenUpdateInput, AdminTokenUncheckedUpdateInput>
    /**
     * Choose, which AdminToken to update.
     */
    where: AdminTokenWhereUniqueInput
  }


  /**
   * AdminToken updateMany
   */
  export type AdminTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminTokens.
     */
    data: XOR<AdminTokenUpdateManyMutationInput, AdminTokenUncheckedUpdateManyInput>
    /**
     * Filter which AdminTokens to update
     */
    where?: AdminTokenWhereInput
  }


  /**
   * AdminToken upsert
   */
  export type AdminTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the AdminToken to update in case it exists.
     */
    where: AdminTokenWhereUniqueInput
    /**
     * In case the AdminToken found by the `where` argument doesn't exist, create a new AdminToken with this data.
     */
    create: XOR<AdminTokenCreateInput, AdminTokenUncheckedCreateInput>
    /**
     * In case the AdminToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminTokenUpdateInput, AdminTokenUncheckedUpdateInput>
  }


  /**
   * AdminToken delete
   */
  export type AdminTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * Filter which AdminToken to delete.
     */
    where: AdminTokenWhereUniqueInput
  }


  /**
   * AdminToken deleteMany
   */
  export type AdminTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminTokens to delete
     */
    where?: AdminTokenWhereInput
  }


  /**
   * AdminToken without action
   */
  export type AdminTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
  }



  /**
   * Model BannedUsers
   */

  export type AggregateBannedUsers = {
    _count: BannedUsersCountAggregateOutputType | null
    _avg: BannedUsersAvgAggregateOutputType | null
    _sum: BannedUsersSumAggregateOutputType | null
    _min: BannedUsersMinAggregateOutputType | null
    _max: BannedUsersMaxAggregateOutputType | null
  }

  export type BannedUsersAvgAggregateOutputType = {
    id: number | null
    community: number | null
  }

  export type BannedUsersSumAggregateOutputType = {
    id: number | null
    community: number | null
  }

  export type BannedUsersMinAggregateOutputType = {
    id: number | null
    community: number | null
    user: string | null
  }

  export type BannedUsersMaxAggregateOutputType = {
    id: number | null
    community: number | null
    user: string | null
  }

  export type BannedUsersCountAggregateOutputType = {
    id: number
    community: number
    user: number
    _all: number
  }


  export type BannedUsersAvgAggregateInputType = {
    id?: true
    community?: true
  }

  export type BannedUsersSumAggregateInputType = {
    id?: true
    community?: true
  }

  export type BannedUsersMinAggregateInputType = {
    id?: true
    community?: true
    user?: true
  }

  export type BannedUsersMaxAggregateInputType = {
    id?: true
    community?: true
    user?: true
  }

  export type BannedUsersCountAggregateInputType = {
    id?: true
    community?: true
    user?: true
    _all?: true
  }

  export type BannedUsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannedUsers to aggregate.
     */
    where?: BannedUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannedUsers to fetch.
     */
    orderBy?: BannedUsersOrderByWithRelationInput | BannedUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannedUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BannedUsers
    **/
    _count?: true | BannedUsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BannedUsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BannedUsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannedUsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannedUsersMaxAggregateInputType
  }

  export type GetBannedUsersAggregateType<T extends BannedUsersAggregateArgs> = {
        [P in keyof T & keyof AggregateBannedUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBannedUsers[P]>
      : GetScalarType<T[P], AggregateBannedUsers[P]>
  }




  export type BannedUsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannedUsersWhereInput
    orderBy?: BannedUsersOrderByWithAggregationInput | BannedUsersOrderByWithAggregationInput[]
    by: BannedUsersScalarFieldEnum[] | BannedUsersScalarFieldEnum
    having?: BannedUsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannedUsersCountAggregateInputType | true
    _avg?: BannedUsersAvgAggregateInputType
    _sum?: BannedUsersSumAggregateInputType
    _min?: BannedUsersMinAggregateInputType
    _max?: BannedUsersMaxAggregateInputType
  }

  export type BannedUsersGroupByOutputType = {
    id: number
    community: number
    user: string
    _count: BannedUsersCountAggregateOutputType | null
    _avg: BannedUsersAvgAggregateOutputType | null
    _sum: BannedUsersSumAggregateOutputType | null
    _min: BannedUsersMinAggregateOutputType | null
    _max: BannedUsersMaxAggregateOutputType | null
  }

  type GetBannedUsersGroupByPayload<T extends BannedUsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannedUsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannedUsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannedUsersGroupByOutputType[P]>
            : GetScalarType<T[P], BannedUsersGroupByOutputType[P]>
        }
      >
    >


  export type BannedUsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    community?: boolean
    user?: boolean
    Community?: boolean | CommunityDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bannedUsers"]>

  export type BannedUsersSelectScalar = {
    id?: boolean
    community?: boolean
    user?: boolean
  }

  export type BannedUsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Community?: boolean | CommunityDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $BannedUsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BannedUsers"
    objects: {
      Community: Prisma.$CommunityPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      community: number
      user: string
    }, ExtArgs["result"]["bannedUsers"]>
    composites: {}
  }


  type BannedUsersGetPayload<S extends boolean | null | undefined | BannedUsersDefaultArgs> = $Result.GetResult<Prisma.$BannedUsersPayload, S>

  type BannedUsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BannedUsersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BannedUsersCountAggregateInputType | true
    }

  export interface BannedUsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BannedUsers'], meta: { name: 'BannedUsers' } }
    /**
     * Find zero or one BannedUsers that matches the filter.
     * @param {BannedUsersFindUniqueArgs} args - Arguments to find a BannedUsers
     * @example
     * // Get one BannedUsers
     * const bannedUsers = await prisma.bannedUsers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BannedUsersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BannedUsersFindUniqueArgs<ExtArgs>>
    ): Prisma__BannedUsersClient<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BannedUsers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BannedUsersFindUniqueOrThrowArgs} args - Arguments to find a BannedUsers
     * @example
     * // Get one BannedUsers
     * const bannedUsers = await prisma.bannedUsers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BannedUsersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BannedUsersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BannedUsersClient<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BannedUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedUsersFindFirstArgs} args - Arguments to find a BannedUsers
     * @example
     * // Get one BannedUsers
     * const bannedUsers = await prisma.bannedUsers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BannedUsersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BannedUsersFindFirstArgs<ExtArgs>>
    ): Prisma__BannedUsersClient<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BannedUsers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedUsersFindFirstOrThrowArgs} args - Arguments to find a BannedUsers
     * @example
     * // Get one BannedUsers
     * const bannedUsers = await prisma.bannedUsers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BannedUsersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BannedUsersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BannedUsersClient<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BannedUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedUsersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BannedUsers
     * const bannedUsers = await prisma.bannedUsers.findMany()
     * 
     * // Get first 10 BannedUsers
     * const bannedUsers = await prisma.bannedUsers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannedUsersWithIdOnly = await prisma.bannedUsers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BannedUsersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BannedUsersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BannedUsers.
     * @param {BannedUsersCreateArgs} args - Arguments to create a BannedUsers.
     * @example
     * // Create one BannedUsers
     * const BannedUsers = await prisma.bannedUsers.create({
     *   data: {
     *     // ... data to create a BannedUsers
     *   }
     * })
     * 
    **/
    create<T extends BannedUsersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BannedUsersCreateArgs<ExtArgs>>
    ): Prisma__BannedUsersClient<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BannedUsers.
     *     @param {BannedUsersCreateManyArgs} args - Arguments to create many BannedUsers.
     *     @example
     *     // Create many BannedUsers
     *     const bannedUsers = await prisma.bannedUsers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BannedUsersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BannedUsersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BannedUsers.
     * @param {BannedUsersDeleteArgs} args - Arguments to delete one BannedUsers.
     * @example
     * // Delete one BannedUsers
     * const BannedUsers = await prisma.bannedUsers.delete({
     *   where: {
     *     // ... filter to delete one BannedUsers
     *   }
     * })
     * 
    **/
    delete<T extends BannedUsersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BannedUsersDeleteArgs<ExtArgs>>
    ): Prisma__BannedUsersClient<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BannedUsers.
     * @param {BannedUsersUpdateArgs} args - Arguments to update one BannedUsers.
     * @example
     * // Update one BannedUsers
     * const bannedUsers = await prisma.bannedUsers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BannedUsersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BannedUsersUpdateArgs<ExtArgs>>
    ): Prisma__BannedUsersClient<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BannedUsers.
     * @param {BannedUsersDeleteManyArgs} args - Arguments to filter BannedUsers to delete.
     * @example
     * // Delete a few BannedUsers
     * const { count } = await prisma.bannedUsers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BannedUsersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BannedUsersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BannedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedUsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BannedUsers
     * const bannedUsers = await prisma.bannedUsers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BannedUsersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BannedUsersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BannedUsers.
     * @param {BannedUsersUpsertArgs} args - Arguments to update or create a BannedUsers.
     * @example
     * // Update or create a BannedUsers
     * const bannedUsers = await prisma.bannedUsers.upsert({
     *   create: {
     *     // ... data to create a BannedUsers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BannedUsers we want to update
     *   }
     * })
    **/
    upsert<T extends BannedUsersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BannedUsersUpsertArgs<ExtArgs>>
    ): Prisma__BannedUsersClient<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BannedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedUsersCountArgs} args - Arguments to filter BannedUsers to count.
     * @example
     * // Count the number of BannedUsers
     * const count = await prisma.bannedUsers.count({
     *   where: {
     *     // ... the filter for the BannedUsers we want to count
     *   }
     * })
    **/
    count<T extends BannedUsersCountArgs>(
      args?: Subset<T, BannedUsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannedUsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BannedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedUsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannedUsersAggregateArgs>(args: Subset<T, BannedUsersAggregateArgs>): Prisma.PrismaPromise<GetBannedUsersAggregateType<T>>

    /**
     * Group by BannedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedUsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannedUsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannedUsersGroupByArgs['orderBy'] }
        : { orderBy?: BannedUsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannedUsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannedUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BannedUsers model
   */
  readonly fields: BannedUsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BannedUsers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannedUsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Community<T extends CommunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityDefaultArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BannedUsers model
   */ 
  interface BannedUsersFieldRefs {
    readonly id: FieldRef<"BannedUsers", 'Int'>
    readonly community: FieldRef<"BannedUsers", 'Int'>
    readonly user: FieldRef<"BannedUsers", 'String'>
  }
    

  // Custom InputTypes

  /**
   * BannedUsers findUnique
   */
  export type BannedUsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    /**
     * Filter, which BannedUsers to fetch.
     */
    where: BannedUsersWhereUniqueInput
  }


  /**
   * BannedUsers findUniqueOrThrow
   */
  export type BannedUsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    /**
     * Filter, which BannedUsers to fetch.
     */
    where: BannedUsersWhereUniqueInput
  }


  /**
   * BannedUsers findFirst
   */
  export type BannedUsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    /**
     * Filter, which BannedUsers to fetch.
     */
    where?: BannedUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannedUsers to fetch.
     */
    orderBy?: BannedUsersOrderByWithRelationInput | BannedUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannedUsers.
     */
    cursor?: BannedUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannedUsers.
     */
    distinct?: BannedUsersScalarFieldEnum | BannedUsersScalarFieldEnum[]
  }


  /**
   * BannedUsers findFirstOrThrow
   */
  export type BannedUsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    /**
     * Filter, which BannedUsers to fetch.
     */
    where?: BannedUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannedUsers to fetch.
     */
    orderBy?: BannedUsersOrderByWithRelationInput | BannedUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannedUsers.
     */
    cursor?: BannedUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannedUsers.
     */
    distinct?: BannedUsersScalarFieldEnum | BannedUsersScalarFieldEnum[]
  }


  /**
   * BannedUsers findMany
   */
  export type BannedUsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    /**
     * Filter, which BannedUsers to fetch.
     */
    where?: BannedUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannedUsers to fetch.
     */
    orderBy?: BannedUsersOrderByWithRelationInput | BannedUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BannedUsers.
     */
    cursor?: BannedUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannedUsers.
     */
    skip?: number
    distinct?: BannedUsersScalarFieldEnum | BannedUsersScalarFieldEnum[]
  }


  /**
   * BannedUsers create
   */
  export type BannedUsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    /**
     * The data needed to create a BannedUsers.
     */
    data: XOR<BannedUsersCreateInput, BannedUsersUncheckedCreateInput>
  }


  /**
   * BannedUsers createMany
   */
  export type BannedUsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BannedUsers.
     */
    data: BannedUsersCreateManyInput | BannedUsersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BannedUsers update
   */
  export type BannedUsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    /**
     * The data needed to update a BannedUsers.
     */
    data: XOR<BannedUsersUpdateInput, BannedUsersUncheckedUpdateInput>
    /**
     * Choose, which BannedUsers to update.
     */
    where: BannedUsersWhereUniqueInput
  }


  /**
   * BannedUsers updateMany
   */
  export type BannedUsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BannedUsers.
     */
    data: XOR<BannedUsersUpdateManyMutationInput, BannedUsersUncheckedUpdateManyInput>
    /**
     * Filter which BannedUsers to update
     */
    where?: BannedUsersWhereInput
  }


  /**
   * BannedUsers upsert
   */
  export type BannedUsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    /**
     * The filter to search for the BannedUsers to update in case it exists.
     */
    where: BannedUsersWhereUniqueInput
    /**
     * In case the BannedUsers found by the `where` argument doesn't exist, create a new BannedUsers with this data.
     */
    create: XOR<BannedUsersCreateInput, BannedUsersUncheckedCreateInput>
    /**
     * In case the BannedUsers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannedUsersUpdateInput, BannedUsersUncheckedUpdateInput>
  }


  /**
   * BannedUsers delete
   */
  export type BannedUsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    /**
     * Filter which BannedUsers to delete.
     */
    where: BannedUsersWhereUniqueInput
  }


  /**
   * BannedUsers deleteMany
   */
  export type BannedUsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannedUsers to delete
     */
    where?: BannedUsersWhereInput
  }


  /**
   * BannedUsers without action
   */
  export type BannedUsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
  }



  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    post: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    post: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    body: string | null
    user: string | null
    post: number | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    body: string | null
    user: string | null
    post: number | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    body: number
    user: number
    post: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    post?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    post?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    body?: true
    user?: true
    post?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    body?: true
    user?: true
    post?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    body?: true
    user?: true
    post?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    body: string | null
    user: string | null
    post: number | null
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    body?: boolean
    user?: boolean
    post?: boolean
    Post?: boolean | Comment$PostArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    body?: boolean
    user?: boolean
    post?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Post?: boolean | Comment$PostArgs<ExtArgs>
  }


  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      Post: Prisma.$PostPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      body: string | null
      user: string | null
      post: number | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }


  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentCreateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Post<T extends Comment$PostArgs<ExtArgs> = {}>(args?: Subset<T, Comment$PostArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly body: FieldRef<"Comment", 'String'>
    readonly user: FieldRef<"Comment", 'String'>
    readonly post: FieldRef<"Comment", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data?: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }


  /**
   * Comment.Post
   */
  export type Comment$PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
  }


  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
  }



  /**
   * Model Community
   */

  export type AggregateCommunity = {
    _count: CommunityCountAggregateOutputType | null
    _avg: CommunityAvgAggregateOutputType | null
    _sum: CommunitySumAggregateOutputType | null
    _min: CommunityMinAggregateOutputType | null
    _max: CommunityMaxAggregateOutputType | null
  }

  export type CommunityAvgAggregateOutputType = {
    id: number | null
  }

  export type CommunitySumAggregateOutputType = {
    id: number | null
  }

  export type CommunityMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type CommunityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type CommunityCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type CommunityAvgAggregateInputType = {
    id?: true
  }

  export type CommunitySumAggregateInputType = {
    id?: true
  }

  export type CommunityMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type CommunityMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type CommunityCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type CommunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Community to aggregate.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Communities
    **/
    _count?: true | CommunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityMaxAggregateInputType
  }

  export type GetCommunityAggregateType<T extends CommunityAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunity[P]>
      : GetScalarType<T[P], AggregateCommunity[P]>
  }




  export type CommunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityWhereInput
    orderBy?: CommunityOrderByWithAggregationInput | CommunityOrderByWithAggregationInput[]
    by: CommunityScalarFieldEnum[] | CommunityScalarFieldEnum
    having?: CommunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityCountAggregateInputType | true
    _avg?: CommunityAvgAggregateInputType
    _sum?: CommunitySumAggregateInputType
    _min?: CommunityMinAggregateInputType
    _max?: CommunityMaxAggregateInputType
  }

  export type CommunityGroupByOutputType = {
    id: number
    name: string | null
    description: string | null
    _count: CommunityCountAggregateOutputType | null
    _avg: CommunityAvgAggregateOutputType | null
    _sum: CommunitySumAggregateOutputType | null
    _min: CommunityMinAggregateOutputType | null
    _max: CommunityMaxAggregateOutputType | null
  }

  type GetCommunityGroupByPayload<T extends CommunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityGroupByOutputType[P]>
        }
      >
    >


  export type CommunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    BannedUsers?: boolean | Community$BannedUsersArgs<ExtArgs>
    CommunityRequest?: boolean | Community$CommunityRequestArgs<ExtArgs>
    Leaderboard?: boolean | Community$LeaderboardArgs<ExtArgs>
    LeaderboardEntry?: boolean | Community$LeaderboardEntryArgs<ExtArgs>
    PendingPost?: boolean | Community$PendingPostArgs<ExtArgs>
    Post?: boolean | Community$PostArgs<ExtArgs>
    Report?: boolean | Community$ReportArgs<ExtArgs>
    _count?: boolean | CommunityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["community"]>

  export type CommunitySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type CommunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BannedUsers?: boolean | Community$BannedUsersArgs<ExtArgs>
    CommunityRequest?: boolean | Community$CommunityRequestArgs<ExtArgs>
    Leaderboard?: boolean | Community$LeaderboardArgs<ExtArgs>
    LeaderboardEntry?: boolean | Community$LeaderboardEntryArgs<ExtArgs>
    PendingPost?: boolean | Community$PendingPostArgs<ExtArgs>
    Post?: boolean | Community$PostArgs<ExtArgs>
    Report?: boolean | Community$ReportArgs<ExtArgs>
    _count?: boolean | CommunityCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CommunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Community"
    objects: {
      BannedUsers: Prisma.$BannedUsersPayload<ExtArgs>[]
      CommunityRequest: Prisma.$CommunityRequestPayload<ExtArgs>[]
      Leaderboard: Prisma.$LeaderboardPayload<ExtArgs>[]
      LeaderboardEntry: Prisma.$LeaderboardEntryPayload<ExtArgs>[]
      PendingPost: Prisma.$PendingPostPayload<ExtArgs>[]
      Post: Prisma.$PostPayload<ExtArgs>[]
      Report: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      description: string | null
    }, ExtArgs["result"]["community"]>
    composites: {}
  }


  type CommunityGetPayload<S extends boolean | null | undefined | CommunityDefaultArgs> = $Result.GetResult<Prisma.$CommunityPayload, S>

  type CommunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommunityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommunityCountAggregateInputType | true
    }

  export interface CommunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Community'], meta: { name: 'Community' } }
    /**
     * Find zero or one Community that matches the filter.
     * @param {CommunityFindUniqueArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityFindUniqueArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Community that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommunityFindUniqueOrThrowArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommunityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Community that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindFirstArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityFindFirstArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Community that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindFirstOrThrowArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommunityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Communities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Communities
     * const communities = await prisma.community.findMany()
     * 
     * // Get first 10 Communities
     * const communities = await prisma.community.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityWithIdOnly = await prisma.community.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Community.
     * @param {CommunityCreateArgs} args - Arguments to create a Community.
     * @example
     * // Create one Community
     * const Community = await prisma.community.create({
     *   data: {
     *     // ... data to create a Community
     *   }
     * })
     * 
    **/
    create<T extends CommunityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityCreateArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Communities.
     *     @param {CommunityCreateManyArgs} args - Arguments to create many Communities.
     *     @example
     *     // Create many Communities
     *     const community = await prisma.community.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Community.
     * @param {CommunityDeleteArgs} args - Arguments to delete one Community.
     * @example
     * // Delete one Community
     * const Community = await prisma.community.delete({
     *   where: {
     *     // ... filter to delete one Community
     *   }
     * })
     * 
    **/
    delete<T extends CommunityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityDeleteArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Community.
     * @param {CommunityUpdateArgs} args - Arguments to update one Community.
     * @example
     * // Update one Community
     * const community = await prisma.community.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityUpdateArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Communities.
     * @param {CommunityDeleteManyArgs} args - Arguments to filter Communities to delete.
     * @example
     * // Delete a few Communities
     * const { count } = await prisma.community.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Communities
     * const community = await prisma.community.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Community.
     * @param {CommunityUpsertArgs} args - Arguments to update or create a Community.
     * @example
     * // Update or create a Community
     * const community = await prisma.community.upsert({
     *   create: {
     *     // ... data to create a Community
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Community we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityUpsertArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Communities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCountArgs} args - Arguments to filter Communities to count.
     * @example
     * // Count the number of Communities
     * const count = await prisma.community.count({
     *   where: {
     *     // ... the filter for the Communities we want to count
     *   }
     * })
    **/
    count<T extends CommunityCountArgs>(
      args?: Subset<T, CommunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Community.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityAggregateArgs>(args: Subset<T, CommunityAggregateArgs>): Prisma.PrismaPromise<GetCommunityAggregateType<T>>

    /**
     * Group by Community.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityGroupByArgs['orderBy'] }
        : { orderBy?: CommunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Community model
   */
  readonly fields: CommunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Community.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    BannedUsers<T extends Community$BannedUsersArgs<ExtArgs> = {}>(args?: Subset<T, Community$BannedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'findMany'> | Null>;

    CommunityRequest<T extends Community$CommunityRequestArgs<ExtArgs> = {}>(args?: Subset<T, Community$CommunityRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'findMany'> | Null>;

    Leaderboard<T extends Community$LeaderboardArgs<ExtArgs> = {}>(args?: Subset<T, Community$LeaderboardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'findMany'> | Null>;

    LeaderboardEntry<T extends Community$LeaderboardEntryArgs<ExtArgs> = {}>(args?: Subset<T, Community$LeaderboardEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, 'findMany'> | Null>;

    PendingPost<T extends Community$PendingPostArgs<ExtArgs> = {}>(args?: Subset<T, Community$PendingPostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'findMany'> | Null>;

    Post<T extends Community$PostArgs<ExtArgs> = {}>(args?: Subset<T, Community$PostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findMany'> | Null>;

    Report<T extends Community$ReportArgs<ExtArgs> = {}>(args?: Subset<T, Community$ReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Community model
   */ 
  interface CommunityFieldRefs {
    readonly id: FieldRef<"Community", 'Int'>
    readonly name: FieldRef<"Community", 'String'>
    readonly description: FieldRef<"Community", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Community findUnique
   */
  export type CommunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where: CommunityWhereUniqueInput
  }


  /**
   * Community findUniqueOrThrow
   */
  export type CommunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where: CommunityWhereUniqueInput
  }


  /**
   * Community findFirst
   */
  export type CommunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communities.
     */
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }


  /**
   * Community findFirstOrThrow
   */
  export type CommunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communities.
     */
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }


  /**
   * Community findMany
   */
  export type CommunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Communities to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }


  /**
   * Community create
   */
  export type CommunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The data needed to create a Community.
     */
    data?: XOR<CommunityCreateInput, CommunityUncheckedCreateInput>
  }


  /**
   * Community createMany
   */
  export type CommunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Communities.
     */
    data: CommunityCreateManyInput | CommunityCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Community update
   */
  export type CommunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The data needed to update a Community.
     */
    data: XOR<CommunityUpdateInput, CommunityUncheckedUpdateInput>
    /**
     * Choose, which Community to update.
     */
    where: CommunityWhereUniqueInput
  }


  /**
   * Community updateMany
   */
  export type CommunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Communities.
     */
    data: XOR<CommunityUpdateManyMutationInput, CommunityUncheckedUpdateManyInput>
    /**
     * Filter which Communities to update
     */
    where?: CommunityWhereInput
  }


  /**
   * Community upsert
   */
  export type CommunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The filter to search for the Community to update in case it exists.
     */
    where: CommunityWhereUniqueInput
    /**
     * In case the Community found by the `where` argument doesn't exist, create a new Community with this data.
     */
    create: XOR<CommunityCreateInput, CommunityUncheckedCreateInput>
    /**
     * In case the Community was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityUpdateInput, CommunityUncheckedUpdateInput>
  }


  /**
   * Community delete
   */
  export type CommunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter which Community to delete.
     */
    where: CommunityWhereUniqueInput
  }


  /**
   * Community deleteMany
   */
  export type CommunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Communities to delete
     */
    where?: CommunityWhereInput
  }


  /**
   * Community.BannedUsers
   */
  export type Community$BannedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    where?: BannedUsersWhereInput
    orderBy?: BannedUsersOrderByWithRelationInput | BannedUsersOrderByWithRelationInput[]
    cursor?: BannedUsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannedUsersScalarFieldEnum | BannedUsersScalarFieldEnum[]
  }


  /**
   * Community.CommunityRequest
   */
  export type Community$CommunityRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    where?: CommunityRequestWhereInput
    orderBy?: CommunityRequestOrderByWithRelationInput | CommunityRequestOrderByWithRelationInput[]
    cursor?: CommunityRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityRequestScalarFieldEnum | CommunityRequestScalarFieldEnum[]
  }


  /**
   * Community.Leaderboard
   */
  export type Community$LeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    where?: LeaderboardWhereInput
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    cursor?: LeaderboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }


  /**
   * Community.LeaderboardEntry
   */
  export type Community$LeaderboardEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    where?: LeaderboardEntryWhereInput
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    cursor?: LeaderboardEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }


  /**
   * Community.PendingPost
   */
  export type Community$PendingPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    where?: PendingPostWhereInput
    orderBy?: PendingPostOrderByWithRelationInput | PendingPostOrderByWithRelationInput[]
    cursor?: PendingPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendingPostScalarFieldEnum | PendingPostScalarFieldEnum[]
  }


  /**
   * Community.Post
   */
  export type Community$PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }


  /**
   * Community.Report
   */
  export type Community$ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * Community without action
   */
  export type CommunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
  }



  /**
   * Model CommunityRequest
   */

  export type AggregateCommunityRequest = {
    _count: CommunityRequestCountAggregateOutputType | null
    _avg: CommunityRequestAvgAggregateOutputType | null
    _sum: CommunityRequestSumAggregateOutputType | null
    _min: CommunityRequestMinAggregateOutputType | null
    _max: CommunityRequestMaxAggregateOutputType | null
  }

  export type CommunityRequestAvgAggregateOutputType = {
    id: number | null
    community: number | null
  }

  export type CommunityRequestSumAggregateOutputType = {
    id: number | null
    community: number | null
  }

  export type CommunityRequestMinAggregateOutputType = {
    id: number | null
    user: string | null
    community: number | null
    isVerified: boolean | null
    isRequested: boolean | null
  }

  export type CommunityRequestMaxAggregateOutputType = {
    id: number | null
    user: string | null
    community: number | null
    isVerified: boolean | null
    isRequested: boolean | null
  }

  export type CommunityRequestCountAggregateOutputType = {
    id: number
    user: number
    community: number
    isVerified: number
    isRequested: number
    _all: number
  }


  export type CommunityRequestAvgAggregateInputType = {
    id?: true
    community?: true
  }

  export type CommunityRequestSumAggregateInputType = {
    id?: true
    community?: true
  }

  export type CommunityRequestMinAggregateInputType = {
    id?: true
    user?: true
    community?: true
    isVerified?: true
    isRequested?: true
  }

  export type CommunityRequestMaxAggregateInputType = {
    id?: true
    user?: true
    community?: true
    isVerified?: true
    isRequested?: true
  }

  export type CommunityRequestCountAggregateInputType = {
    id?: true
    user?: true
    community?: true
    isVerified?: true
    isRequested?: true
    _all?: true
  }

  export type CommunityRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityRequest to aggregate.
     */
    where?: CommunityRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityRequests to fetch.
     */
    orderBy?: CommunityRequestOrderByWithRelationInput | CommunityRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityRequests
    **/
    _count?: true | CommunityRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityRequestMaxAggregateInputType
  }

  export type GetCommunityRequestAggregateType<T extends CommunityRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityRequest[P]>
      : GetScalarType<T[P], AggregateCommunityRequest[P]>
  }




  export type CommunityRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityRequestWhereInput
    orderBy?: CommunityRequestOrderByWithAggregationInput | CommunityRequestOrderByWithAggregationInput[]
    by: CommunityRequestScalarFieldEnum[] | CommunityRequestScalarFieldEnum
    having?: CommunityRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityRequestCountAggregateInputType | true
    _avg?: CommunityRequestAvgAggregateInputType
    _sum?: CommunityRequestSumAggregateInputType
    _min?: CommunityRequestMinAggregateInputType
    _max?: CommunityRequestMaxAggregateInputType
  }

  export type CommunityRequestGroupByOutputType = {
    id: number
    user: string | null
    community: number | null
    isVerified: boolean | null
    isRequested: boolean | null
    _count: CommunityRequestCountAggregateOutputType | null
    _avg: CommunityRequestAvgAggregateOutputType | null
    _sum: CommunityRequestSumAggregateOutputType | null
    _min: CommunityRequestMinAggregateOutputType | null
    _max: CommunityRequestMaxAggregateOutputType | null
  }

  type GetCommunityRequestGroupByPayload<T extends CommunityRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityRequestGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityRequestGroupByOutputType[P]>
        }
      >
    >


  export type CommunityRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user?: boolean
    community?: boolean
    isVerified?: boolean
    isRequested?: boolean
    Community?: boolean | CommunityRequest$CommunityArgs<ExtArgs>
    User?: boolean | CommunityRequest$UserArgs<ExtArgs>
  }, ExtArgs["result"]["communityRequest"]>

  export type CommunityRequestSelectScalar = {
    id?: boolean
    user?: boolean
    community?: boolean
    isVerified?: boolean
    isRequested?: boolean
  }

  export type CommunityRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Community?: boolean | CommunityRequest$CommunityArgs<ExtArgs>
    User?: boolean | CommunityRequest$UserArgs<ExtArgs>
  }


  export type $CommunityRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityRequest"
    objects: {
      Community: Prisma.$CommunityPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user: string | null
      community: number | null
      isVerified: boolean | null
      isRequested: boolean | null
    }, ExtArgs["result"]["communityRequest"]>
    composites: {}
  }


  type CommunityRequestGetPayload<S extends boolean | null | undefined | CommunityRequestDefaultArgs> = $Result.GetResult<Prisma.$CommunityRequestPayload, S>

  type CommunityRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommunityRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommunityRequestCountAggregateInputType | true
    }

  export interface CommunityRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityRequest'], meta: { name: 'CommunityRequest' } }
    /**
     * Find zero or one CommunityRequest that matches the filter.
     * @param {CommunityRequestFindUniqueArgs} args - Arguments to find a CommunityRequest
     * @example
     * // Get one CommunityRequest
     * const communityRequest = await prisma.communityRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityRequestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityRequestFindUniqueArgs<ExtArgs>>
    ): Prisma__CommunityRequestClient<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CommunityRequest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommunityRequestFindUniqueOrThrowArgs} args - Arguments to find a CommunityRequest
     * @example
     * // Get one CommunityRequest
     * const communityRequest = await prisma.communityRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommunityRequestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityRequestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityRequestClient<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CommunityRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityRequestFindFirstArgs} args - Arguments to find a CommunityRequest
     * @example
     * // Get one CommunityRequest
     * const communityRequest = await prisma.communityRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityRequestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityRequestFindFirstArgs<ExtArgs>>
    ): Prisma__CommunityRequestClient<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CommunityRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityRequestFindFirstOrThrowArgs} args - Arguments to find a CommunityRequest
     * @example
     * // Get one CommunityRequest
     * const communityRequest = await prisma.communityRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommunityRequestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityRequestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityRequestClient<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CommunityRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityRequests
     * const communityRequests = await prisma.communityRequest.findMany()
     * 
     * // Get first 10 CommunityRequests
     * const communityRequests = await prisma.communityRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityRequestWithIdOnly = await prisma.communityRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunityRequestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityRequestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CommunityRequest.
     * @param {CommunityRequestCreateArgs} args - Arguments to create a CommunityRequest.
     * @example
     * // Create one CommunityRequest
     * const CommunityRequest = await prisma.communityRequest.create({
     *   data: {
     *     // ... data to create a CommunityRequest
     *   }
     * })
     * 
    **/
    create<T extends CommunityRequestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityRequestCreateArgs<ExtArgs>>
    ): Prisma__CommunityRequestClient<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CommunityRequests.
     *     @param {CommunityRequestCreateManyArgs} args - Arguments to create many CommunityRequests.
     *     @example
     *     // Create many CommunityRequests
     *     const communityRequest = await prisma.communityRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunityRequestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityRequestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommunityRequest.
     * @param {CommunityRequestDeleteArgs} args - Arguments to delete one CommunityRequest.
     * @example
     * // Delete one CommunityRequest
     * const CommunityRequest = await prisma.communityRequest.delete({
     *   where: {
     *     // ... filter to delete one CommunityRequest
     *   }
     * })
     * 
    **/
    delete<T extends CommunityRequestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityRequestDeleteArgs<ExtArgs>>
    ): Prisma__CommunityRequestClient<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CommunityRequest.
     * @param {CommunityRequestUpdateArgs} args - Arguments to update one CommunityRequest.
     * @example
     * // Update one CommunityRequest
     * const communityRequest = await prisma.communityRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityRequestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityRequestUpdateArgs<ExtArgs>>
    ): Prisma__CommunityRequestClient<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CommunityRequests.
     * @param {CommunityRequestDeleteManyArgs} args - Arguments to filter CommunityRequests to delete.
     * @example
     * // Delete a few CommunityRequests
     * const { count } = await prisma.communityRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityRequestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityRequestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityRequests
     * const communityRequest = await prisma.communityRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityRequestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityRequestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityRequest.
     * @param {CommunityRequestUpsertArgs} args - Arguments to update or create a CommunityRequest.
     * @example
     * // Update or create a CommunityRequest
     * const communityRequest = await prisma.communityRequest.upsert({
     *   create: {
     *     // ... data to create a CommunityRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityRequest we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityRequestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityRequestUpsertArgs<ExtArgs>>
    ): Prisma__CommunityRequestClient<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CommunityRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityRequestCountArgs} args - Arguments to filter CommunityRequests to count.
     * @example
     * // Count the number of CommunityRequests
     * const count = await prisma.communityRequest.count({
     *   where: {
     *     // ... the filter for the CommunityRequests we want to count
     *   }
     * })
    **/
    count<T extends CommunityRequestCountArgs>(
      args?: Subset<T, CommunityRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityRequestAggregateArgs>(args: Subset<T, CommunityRequestAggregateArgs>): Prisma.PrismaPromise<GetCommunityRequestAggregateType<T>>

    /**
     * Group by CommunityRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityRequestGroupByArgs['orderBy'] }
        : { orderBy?: CommunityRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityRequest model
   */
  readonly fields: CommunityRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Community<T extends CommunityRequest$CommunityArgs<ExtArgs> = {}>(args?: Subset<T, CommunityRequest$CommunityArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    User<T extends CommunityRequest$UserArgs<ExtArgs> = {}>(args?: Subset<T, CommunityRequest$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CommunityRequest model
   */ 
  interface CommunityRequestFieldRefs {
    readonly id: FieldRef<"CommunityRequest", 'Int'>
    readonly user: FieldRef<"CommunityRequest", 'String'>
    readonly community: FieldRef<"CommunityRequest", 'Int'>
    readonly isVerified: FieldRef<"CommunityRequest", 'Boolean'>
    readonly isRequested: FieldRef<"CommunityRequest", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * CommunityRequest findUnique
   */
  export type CommunityRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    /**
     * Filter, which CommunityRequest to fetch.
     */
    where: CommunityRequestWhereUniqueInput
  }


  /**
   * CommunityRequest findUniqueOrThrow
   */
  export type CommunityRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    /**
     * Filter, which CommunityRequest to fetch.
     */
    where: CommunityRequestWhereUniqueInput
  }


  /**
   * CommunityRequest findFirst
   */
  export type CommunityRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    /**
     * Filter, which CommunityRequest to fetch.
     */
    where?: CommunityRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityRequests to fetch.
     */
    orderBy?: CommunityRequestOrderByWithRelationInput | CommunityRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityRequests.
     */
    cursor?: CommunityRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityRequests.
     */
    distinct?: CommunityRequestScalarFieldEnum | CommunityRequestScalarFieldEnum[]
  }


  /**
   * CommunityRequest findFirstOrThrow
   */
  export type CommunityRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    /**
     * Filter, which CommunityRequest to fetch.
     */
    where?: CommunityRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityRequests to fetch.
     */
    orderBy?: CommunityRequestOrderByWithRelationInput | CommunityRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityRequests.
     */
    cursor?: CommunityRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityRequests.
     */
    distinct?: CommunityRequestScalarFieldEnum | CommunityRequestScalarFieldEnum[]
  }


  /**
   * CommunityRequest findMany
   */
  export type CommunityRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    /**
     * Filter, which CommunityRequests to fetch.
     */
    where?: CommunityRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityRequests to fetch.
     */
    orderBy?: CommunityRequestOrderByWithRelationInput | CommunityRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityRequests.
     */
    cursor?: CommunityRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityRequests.
     */
    skip?: number
    distinct?: CommunityRequestScalarFieldEnum | CommunityRequestScalarFieldEnum[]
  }


  /**
   * CommunityRequest create
   */
  export type CommunityRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityRequest.
     */
    data?: XOR<CommunityRequestCreateInput, CommunityRequestUncheckedCreateInput>
  }


  /**
   * CommunityRequest createMany
   */
  export type CommunityRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityRequests.
     */
    data: CommunityRequestCreateManyInput | CommunityRequestCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CommunityRequest update
   */
  export type CommunityRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityRequest.
     */
    data: XOR<CommunityRequestUpdateInput, CommunityRequestUncheckedUpdateInput>
    /**
     * Choose, which CommunityRequest to update.
     */
    where: CommunityRequestWhereUniqueInput
  }


  /**
   * CommunityRequest updateMany
   */
  export type CommunityRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityRequests.
     */
    data: XOR<CommunityRequestUpdateManyMutationInput, CommunityRequestUncheckedUpdateManyInput>
    /**
     * Filter which CommunityRequests to update
     */
    where?: CommunityRequestWhereInput
  }


  /**
   * CommunityRequest upsert
   */
  export type CommunityRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityRequest to update in case it exists.
     */
    where: CommunityRequestWhereUniqueInput
    /**
     * In case the CommunityRequest found by the `where` argument doesn't exist, create a new CommunityRequest with this data.
     */
    create: XOR<CommunityRequestCreateInput, CommunityRequestUncheckedCreateInput>
    /**
     * In case the CommunityRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityRequestUpdateInput, CommunityRequestUncheckedUpdateInput>
  }


  /**
   * CommunityRequest delete
   */
  export type CommunityRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    /**
     * Filter which CommunityRequest to delete.
     */
    where: CommunityRequestWhereUniqueInput
  }


  /**
   * CommunityRequest deleteMany
   */
  export type CommunityRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityRequests to delete
     */
    where?: CommunityRequestWhereInput
  }


  /**
   * CommunityRequest.Community
   */
  export type CommunityRequest$CommunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    where?: CommunityWhereInput
  }


  /**
   * CommunityRequest.User
   */
  export type CommunityRequest$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * CommunityRequest without action
   */
  export type CommunityRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
  }



  /**
   * Model Context
   */

  export type AggregateContext = {
    _count: ContextCountAggregateOutputType | null
    _avg: ContextAvgAggregateOutputType | null
    _sum: ContextSumAggregateOutputType | null
    _min: ContextMinAggregateOutputType | null
    _max: ContextMaxAggregateOutputType | null
  }

  export type ContextAvgAggregateOutputType = {
    id: number | null
  }

  export type ContextSumAggregateOutputType = {
    id: number | null
  }

  export type ContextMinAggregateOutputType = {
    id: number | null
    user: string | null
    email: string | null
    ip: string | null
    country: string | null
    city: string | null
    browser: string | null
    platform: string | null
    os: string | null
    device: string | null
    deviceType: string | null
    isTrusted: boolean | null
  }

  export type ContextMaxAggregateOutputType = {
    id: number | null
    user: string | null
    email: string | null
    ip: string | null
    country: string | null
    city: string | null
    browser: string | null
    platform: string | null
    os: string | null
    device: string | null
    deviceType: string | null
    isTrusted: boolean | null
  }

  export type ContextCountAggregateOutputType = {
    id: number
    user: number
    email: number
    ip: number
    country: number
    city: number
    browser: number
    platform: number
    os: number
    device: number
    deviceType: number
    isTrusted: number
    _all: number
  }


  export type ContextAvgAggregateInputType = {
    id?: true
  }

  export type ContextSumAggregateInputType = {
    id?: true
  }

  export type ContextMinAggregateInputType = {
    id?: true
    user?: true
    email?: true
    ip?: true
    country?: true
    city?: true
    browser?: true
    platform?: true
    os?: true
    device?: true
    deviceType?: true
    isTrusted?: true
  }

  export type ContextMaxAggregateInputType = {
    id?: true
    user?: true
    email?: true
    ip?: true
    country?: true
    city?: true
    browser?: true
    platform?: true
    os?: true
    device?: true
    deviceType?: true
    isTrusted?: true
  }

  export type ContextCountAggregateInputType = {
    id?: true
    user?: true
    email?: true
    ip?: true
    country?: true
    city?: true
    browser?: true
    platform?: true
    os?: true
    device?: true
    deviceType?: true
    isTrusted?: true
    _all?: true
  }

  export type ContextAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Context to aggregate.
     */
    where?: ContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contexts to fetch.
     */
    orderBy?: ContextOrderByWithRelationInput | ContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contexts
    **/
    _count?: true | ContextCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContextAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContextSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContextMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContextMaxAggregateInputType
  }

  export type GetContextAggregateType<T extends ContextAggregateArgs> = {
        [P in keyof T & keyof AggregateContext]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContext[P]>
      : GetScalarType<T[P], AggregateContext[P]>
  }




  export type ContextGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContextWhereInput
    orderBy?: ContextOrderByWithAggregationInput | ContextOrderByWithAggregationInput[]
    by: ContextScalarFieldEnum[] | ContextScalarFieldEnum
    having?: ContextScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContextCountAggregateInputType | true
    _avg?: ContextAvgAggregateInputType
    _sum?: ContextSumAggregateInputType
    _min?: ContextMinAggregateInputType
    _max?: ContextMaxAggregateInputType
  }

  export type ContextGroupByOutputType = {
    id: number
    user: string | null
    email: string | null
    ip: string | null
    country: string | null
    city: string | null
    browser: string | null
    platform: string | null
    os: string | null
    device: string | null
    deviceType: string | null
    isTrusted: boolean | null
    _count: ContextCountAggregateOutputType | null
    _avg: ContextAvgAggregateOutputType | null
    _sum: ContextSumAggregateOutputType | null
    _min: ContextMinAggregateOutputType | null
    _max: ContextMaxAggregateOutputType | null
  }

  type GetContextGroupByPayload<T extends ContextGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContextGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContextGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContextGroupByOutputType[P]>
            : GetScalarType<T[P], ContextGroupByOutputType[P]>
        }
      >
    >


  export type ContextSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user?: boolean
    email?: boolean
    ip?: boolean
    country?: boolean
    city?: boolean
    browser?: boolean
    platform?: boolean
    os?: boolean
    device?: boolean
    deviceType?: boolean
    isTrusted?: boolean
    User?: boolean | Context$UserArgs<ExtArgs>
  }, ExtArgs["result"]["context"]>

  export type ContextSelectScalar = {
    id?: boolean
    user?: boolean
    email?: boolean
    ip?: boolean
    country?: boolean
    city?: boolean
    browser?: boolean
    platform?: boolean
    os?: boolean
    device?: boolean
    deviceType?: boolean
    isTrusted?: boolean
  }

  export type ContextInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Context$UserArgs<ExtArgs>
  }


  export type $ContextPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Context"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user: string | null
      email: string | null
      ip: string | null
      country: string | null
      city: string | null
      browser: string | null
      platform: string | null
      os: string | null
      device: string | null
      deviceType: string | null
      isTrusted: boolean | null
    }, ExtArgs["result"]["context"]>
    composites: {}
  }


  type ContextGetPayload<S extends boolean | null | undefined | ContextDefaultArgs> = $Result.GetResult<Prisma.$ContextPayload, S>

  type ContextCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContextFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContextCountAggregateInputType | true
    }

  export interface ContextDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Context'], meta: { name: 'Context' } }
    /**
     * Find zero or one Context that matches the filter.
     * @param {ContextFindUniqueArgs} args - Arguments to find a Context
     * @example
     * // Get one Context
     * const context = await prisma.context.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContextFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContextFindUniqueArgs<ExtArgs>>
    ): Prisma__ContextClient<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Context that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContextFindUniqueOrThrowArgs} args - Arguments to find a Context
     * @example
     * // Get one Context
     * const context = await prisma.context.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContextFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContextClient<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Context that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextFindFirstArgs} args - Arguments to find a Context
     * @example
     * // Get one Context
     * const context = await prisma.context.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContextFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextFindFirstArgs<ExtArgs>>
    ): Prisma__ContextClient<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Context that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextFindFirstOrThrowArgs} args - Arguments to find a Context
     * @example
     * // Get one Context
     * const context = await prisma.context.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContextFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContextClient<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contexts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contexts
     * const contexts = await prisma.context.findMany()
     * 
     * // Get first 10 Contexts
     * const contexts = await prisma.context.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contextWithIdOnly = await prisma.context.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContextFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Context.
     * @param {ContextCreateArgs} args - Arguments to create a Context.
     * @example
     * // Create one Context
     * const Context = await prisma.context.create({
     *   data: {
     *     // ... data to create a Context
     *   }
     * })
     * 
    **/
    create<T extends ContextCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextCreateArgs<ExtArgs>>
    ): Prisma__ContextClient<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contexts.
     *     @param {ContextCreateManyArgs} args - Arguments to create many Contexts.
     *     @example
     *     // Create many Contexts
     *     const context = await prisma.context.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContextCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Context.
     * @param {ContextDeleteArgs} args - Arguments to delete one Context.
     * @example
     * // Delete one Context
     * const Context = await prisma.context.delete({
     *   where: {
     *     // ... filter to delete one Context
     *   }
     * })
     * 
    **/
    delete<T extends ContextDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContextDeleteArgs<ExtArgs>>
    ): Prisma__ContextClient<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Context.
     * @param {ContextUpdateArgs} args - Arguments to update one Context.
     * @example
     * // Update one Context
     * const context = await prisma.context.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContextUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextUpdateArgs<ExtArgs>>
    ): Prisma__ContextClient<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contexts.
     * @param {ContextDeleteManyArgs} args - Arguments to filter Contexts to delete.
     * @example
     * // Delete a few Contexts
     * const { count } = await prisma.context.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContextDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contexts
     * const context = await prisma.context.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContextUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContextUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Context.
     * @param {ContextUpsertArgs} args - Arguments to update or create a Context.
     * @example
     * // Update or create a Context
     * const context = await prisma.context.upsert({
     *   create: {
     *     // ... data to create a Context
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Context we want to update
     *   }
     * })
    **/
    upsert<T extends ContextUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContextUpsertArgs<ExtArgs>>
    ): Prisma__ContextClient<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextCountArgs} args - Arguments to filter Contexts to count.
     * @example
     * // Count the number of Contexts
     * const count = await prisma.context.count({
     *   where: {
     *     // ... the filter for the Contexts we want to count
     *   }
     * })
    **/
    count<T extends ContextCountArgs>(
      args?: Subset<T, ContextCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContextCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Context.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContextAggregateArgs>(args: Subset<T, ContextAggregateArgs>): Prisma.PrismaPromise<GetContextAggregateType<T>>

    /**
     * Group by Context.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContextGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContextGroupByArgs['orderBy'] }
        : { orderBy?: ContextGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContextGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContextGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Context model
   */
  readonly fields: ContextFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Context.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContextClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    User<T extends Context$UserArgs<ExtArgs> = {}>(args?: Subset<T, Context$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Context model
   */ 
  interface ContextFieldRefs {
    readonly id: FieldRef<"Context", 'Int'>
    readonly user: FieldRef<"Context", 'String'>
    readonly email: FieldRef<"Context", 'String'>
    readonly ip: FieldRef<"Context", 'String'>
    readonly country: FieldRef<"Context", 'String'>
    readonly city: FieldRef<"Context", 'String'>
    readonly browser: FieldRef<"Context", 'String'>
    readonly platform: FieldRef<"Context", 'String'>
    readonly os: FieldRef<"Context", 'String'>
    readonly device: FieldRef<"Context", 'String'>
    readonly deviceType: FieldRef<"Context", 'String'>
    readonly isTrusted: FieldRef<"Context", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Context findUnique
   */
  export type ContextFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextInclude<ExtArgs> | null
    /**
     * Filter, which Context to fetch.
     */
    where: ContextWhereUniqueInput
  }


  /**
   * Context findUniqueOrThrow
   */
  export type ContextFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextInclude<ExtArgs> | null
    /**
     * Filter, which Context to fetch.
     */
    where: ContextWhereUniqueInput
  }


  /**
   * Context findFirst
   */
  export type ContextFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextInclude<ExtArgs> | null
    /**
     * Filter, which Context to fetch.
     */
    where?: ContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contexts to fetch.
     */
    orderBy?: ContextOrderByWithRelationInput | ContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contexts.
     */
    cursor?: ContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contexts.
     */
    distinct?: ContextScalarFieldEnum | ContextScalarFieldEnum[]
  }


  /**
   * Context findFirstOrThrow
   */
  export type ContextFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextInclude<ExtArgs> | null
    /**
     * Filter, which Context to fetch.
     */
    where?: ContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contexts to fetch.
     */
    orderBy?: ContextOrderByWithRelationInput | ContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contexts.
     */
    cursor?: ContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contexts.
     */
    distinct?: ContextScalarFieldEnum | ContextScalarFieldEnum[]
  }


  /**
   * Context findMany
   */
  export type ContextFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextInclude<ExtArgs> | null
    /**
     * Filter, which Contexts to fetch.
     */
    where?: ContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contexts to fetch.
     */
    orderBy?: ContextOrderByWithRelationInput | ContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contexts.
     */
    cursor?: ContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contexts.
     */
    skip?: number
    distinct?: ContextScalarFieldEnum | ContextScalarFieldEnum[]
  }


  /**
   * Context create
   */
  export type ContextCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextInclude<ExtArgs> | null
    /**
     * The data needed to create a Context.
     */
    data?: XOR<ContextCreateInput, ContextUncheckedCreateInput>
  }


  /**
   * Context createMany
   */
  export type ContextCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contexts.
     */
    data: ContextCreateManyInput | ContextCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Context update
   */
  export type ContextUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextInclude<ExtArgs> | null
    /**
     * The data needed to update a Context.
     */
    data: XOR<ContextUpdateInput, ContextUncheckedUpdateInput>
    /**
     * Choose, which Context to update.
     */
    where: ContextWhereUniqueInput
  }


  /**
   * Context updateMany
   */
  export type ContextUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contexts.
     */
    data: XOR<ContextUpdateManyMutationInput, ContextUncheckedUpdateManyInput>
    /**
     * Filter which Contexts to update
     */
    where?: ContextWhereInput
  }


  /**
   * Context upsert
   */
  export type ContextUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextInclude<ExtArgs> | null
    /**
     * The filter to search for the Context to update in case it exists.
     */
    where: ContextWhereUniqueInput
    /**
     * In case the Context found by the `where` argument doesn't exist, create a new Context with this data.
     */
    create: XOR<ContextCreateInput, ContextUncheckedCreateInput>
    /**
     * In case the Context was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContextUpdateInput, ContextUncheckedUpdateInput>
  }


  /**
   * Context delete
   */
  export type ContextDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextInclude<ExtArgs> | null
    /**
     * Filter which Context to delete.
     */
    where: ContextWhereUniqueInput
  }


  /**
   * Context deleteMany
   */
  export type ContextDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contexts to delete
     */
    where?: ContextWhereInput
  }


  /**
   * Context.User
   */
  export type Context$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Context without action
   */
  export type ContextDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextInclude<ExtArgs> | null
  }



  /**
   * Model Leaderboard
   */

  export type AggregateLeaderboard = {
    _count: LeaderboardCountAggregateOutputType | null
    _avg: LeaderboardAvgAggregateOutputType | null
    _sum: LeaderboardSumAggregateOutputType | null
    _min: LeaderboardMinAggregateOutputType | null
    _max: LeaderboardMaxAggregateOutputType | null
  }

  export type LeaderboardAvgAggregateOutputType = {
    id: number | null
    community: number | null
  }

  export type LeaderboardSumAggregateOutputType = {
    id: number | null
    community: number | null
  }

  export type LeaderboardMinAggregateOutputType = {
    id: number | null
    community: number | null
    tracking: string | null
  }

  export type LeaderboardMaxAggregateOutputType = {
    id: number | null
    community: number | null
    tracking: string | null
  }

  export type LeaderboardCountAggregateOutputType = {
    id: number
    community: number
    tracking: number
    _all: number
  }


  export type LeaderboardAvgAggregateInputType = {
    id?: true
    community?: true
  }

  export type LeaderboardSumAggregateInputType = {
    id?: true
    community?: true
  }

  export type LeaderboardMinAggregateInputType = {
    id?: true
    community?: true
    tracking?: true
  }

  export type LeaderboardMaxAggregateInputType = {
    id?: true
    community?: true
    tracking?: true
  }

  export type LeaderboardCountAggregateInputType = {
    id?: true
    community?: true
    tracking?: true
    _all?: true
  }

  export type LeaderboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaderboard to aggregate.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leaderboards
    **/
    _count?: true | LeaderboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaderboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaderboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaderboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaderboardMaxAggregateInputType
  }

  export type GetLeaderboardAggregateType<T extends LeaderboardAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaderboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaderboard[P]>
      : GetScalarType<T[P], AggregateLeaderboard[P]>
  }




  export type LeaderboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardWhereInput
    orderBy?: LeaderboardOrderByWithAggregationInput | LeaderboardOrderByWithAggregationInput[]
    by: LeaderboardScalarFieldEnum[] | LeaderboardScalarFieldEnum
    having?: LeaderboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaderboardCountAggregateInputType | true
    _avg?: LeaderboardAvgAggregateInputType
    _sum?: LeaderboardSumAggregateInputType
    _min?: LeaderboardMinAggregateInputType
    _max?: LeaderboardMaxAggregateInputType
  }

  export type LeaderboardGroupByOutputType = {
    id: number
    community: number
    tracking: string | null
    _count: LeaderboardCountAggregateOutputType | null
    _avg: LeaderboardAvgAggregateOutputType | null
    _sum: LeaderboardSumAggregateOutputType | null
    _min: LeaderboardMinAggregateOutputType | null
    _max: LeaderboardMaxAggregateOutputType | null
  }

  type GetLeaderboardGroupByPayload<T extends LeaderboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaderboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaderboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaderboardGroupByOutputType[P]>
            : GetScalarType<T[P], LeaderboardGroupByOutputType[P]>
        }
      >
    >


  export type LeaderboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    community?: boolean
    tracking?: boolean
    Community?: boolean | CommunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboard"]>

  export type LeaderboardSelectScalar = {
    id?: boolean
    community?: boolean
    tracking?: boolean
  }

  export type LeaderboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Community?: boolean | CommunityDefaultArgs<ExtArgs>
  }


  export type $LeaderboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leaderboard"
    objects: {
      Community: Prisma.$CommunityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      community: number
      tracking: string | null
    }, ExtArgs["result"]["leaderboard"]>
    composites: {}
  }


  type LeaderboardGetPayload<S extends boolean | null | undefined | LeaderboardDefaultArgs> = $Result.GetResult<Prisma.$LeaderboardPayload, S>

  type LeaderboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaderboardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaderboardCountAggregateInputType | true
    }

  export interface LeaderboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leaderboard'], meta: { name: 'Leaderboard' } }
    /**
     * Find zero or one Leaderboard that matches the filter.
     * @param {LeaderboardFindUniqueArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LeaderboardFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardFindUniqueArgs<ExtArgs>>
    ): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Leaderboard that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LeaderboardFindUniqueOrThrowArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LeaderboardFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Leaderboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardFindFirstArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LeaderboardFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardFindFirstArgs<ExtArgs>>
    ): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Leaderboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardFindFirstOrThrowArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LeaderboardFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Leaderboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leaderboards
     * const leaderboards = await prisma.leaderboard.findMany()
     * 
     * // Get first 10 Leaderboards
     * const leaderboards = await prisma.leaderboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaderboardWithIdOnly = await prisma.leaderboard.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LeaderboardFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Leaderboard.
     * @param {LeaderboardCreateArgs} args - Arguments to create a Leaderboard.
     * @example
     * // Create one Leaderboard
     * const Leaderboard = await prisma.leaderboard.create({
     *   data: {
     *     // ... data to create a Leaderboard
     *   }
     * })
     * 
    **/
    create<T extends LeaderboardCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardCreateArgs<ExtArgs>>
    ): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Leaderboards.
     *     @param {LeaderboardCreateManyArgs} args - Arguments to create many Leaderboards.
     *     @example
     *     // Create many Leaderboards
     *     const leaderboard = await prisma.leaderboard.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LeaderboardCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Leaderboard.
     * @param {LeaderboardDeleteArgs} args - Arguments to delete one Leaderboard.
     * @example
     * // Delete one Leaderboard
     * const Leaderboard = await prisma.leaderboard.delete({
     *   where: {
     *     // ... filter to delete one Leaderboard
     *   }
     * })
     * 
    **/
    delete<T extends LeaderboardDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardDeleteArgs<ExtArgs>>
    ): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Leaderboard.
     * @param {LeaderboardUpdateArgs} args - Arguments to update one Leaderboard.
     * @example
     * // Update one Leaderboard
     * const leaderboard = await prisma.leaderboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LeaderboardUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardUpdateArgs<ExtArgs>>
    ): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Leaderboards.
     * @param {LeaderboardDeleteManyArgs} args - Arguments to filter Leaderboards to delete.
     * @example
     * // Delete a few Leaderboards
     * const { count } = await prisma.leaderboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LeaderboardDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leaderboards
     * const leaderboard = await prisma.leaderboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LeaderboardUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Leaderboard.
     * @param {LeaderboardUpsertArgs} args - Arguments to update or create a Leaderboard.
     * @example
     * // Update or create a Leaderboard
     * const leaderboard = await prisma.leaderboard.upsert({
     *   create: {
     *     // ... data to create a Leaderboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leaderboard we want to update
     *   }
     * })
    **/
    upsert<T extends LeaderboardUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardUpsertArgs<ExtArgs>>
    ): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Leaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardCountArgs} args - Arguments to filter Leaderboards to count.
     * @example
     * // Count the number of Leaderboards
     * const count = await prisma.leaderboard.count({
     *   where: {
     *     // ... the filter for the Leaderboards we want to count
     *   }
     * })
    **/
    count<T extends LeaderboardCountArgs>(
      args?: Subset<T, LeaderboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaderboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaderboardAggregateArgs>(args: Subset<T, LeaderboardAggregateArgs>): Prisma.PrismaPromise<GetLeaderboardAggregateType<T>>

    /**
     * Group by Leaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaderboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaderboardGroupByArgs['orderBy'] }
        : { orderBy?: LeaderboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaderboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaderboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leaderboard model
   */
  readonly fields: LeaderboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leaderboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaderboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Community<T extends CommunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityDefaultArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Leaderboard model
   */ 
  interface LeaderboardFieldRefs {
    readonly id: FieldRef<"Leaderboard", 'Int'>
    readonly community: FieldRef<"Leaderboard", 'Int'>
    readonly tracking: FieldRef<"Leaderboard", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Leaderboard findUnique
   */
  export type LeaderboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where: LeaderboardWhereUniqueInput
  }


  /**
   * Leaderboard findUniqueOrThrow
   */
  export type LeaderboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where: LeaderboardWhereUniqueInput
  }


  /**
   * Leaderboard findFirst
   */
  export type LeaderboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaderboards.
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaderboards.
     */
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }


  /**
   * Leaderboard findFirstOrThrow
   */
  export type LeaderboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaderboards.
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaderboards.
     */
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }


  /**
   * Leaderboard findMany
   */
  export type LeaderboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboards to fetch.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leaderboards.
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }


  /**
   * Leaderboard create
   */
  export type LeaderboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to create a Leaderboard.
     */
    data: XOR<LeaderboardCreateInput, LeaderboardUncheckedCreateInput>
  }


  /**
   * Leaderboard createMany
   */
  export type LeaderboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leaderboards.
     */
    data: LeaderboardCreateManyInput | LeaderboardCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Leaderboard update
   */
  export type LeaderboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to update a Leaderboard.
     */
    data: XOR<LeaderboardUpdateInput, LeaderboardUncheckedUpdateInput>
    /**
     * Choose, which Leaderboard to update.
     */
    where: LeaderboardWhereUniqueInput
  }


  /**
   * Leaderboard updateMany
   */
  export type LeaderboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leaderboards.
     */
    data: XOR<LeaderboardUpdateManyMutationInput, LeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which Leaderboards to update
     */
    where?: LeaderboardWhereInput
  }


  /**
   * Leaderboard upsert
   */
  export type LeaderboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * The filter to search for the Leaderboard to update in case it exists.
     */
    where: LeaderboardWhereUniqueInput
    /**
     * In case the Leaderboard found by the `where` argument doesn't exist, create a new Leaderboard with this data.
     */
    create: XOR<LeaderboardCreateInput, LeaderboardUncheckedCreateInput>
    /**
     * In case the Leaderboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaderboardUpdateInput, LeaderboardUncheckedUpdateInput>
  }


  /**
   * Leaderboard delete
   */
  export type LeaderboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter which Leaderboard to delete.
     */
    where: LeaderboardWhereUniqueInput
  }


  /**
   * Leaderboard deleteMany
   */
  export type LeaderboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaderboards to delete
     */
    where?: LeaderboardWhereInput
  }


  /**
   * Leaderboard without action
   */
  export type LeaderboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
  }



  /**
   * Model LeaderboardEntry
   */

  export type AggregateLeaderboardEntry = {
    _count: LeaderboardEntryCountAggregateOutputType | null
    _avg: LeaderboardEntryAvgAggregateOutputType | null
    _sum: LeaderboardEntrySumAggregateOutputType | null
    _min: LeaderboardEntryMinAggregateOutputType | null
    _max: LeaderboardEntryMaxAggregateOutputType | null
  }

  export type LeaderboardEntryAvgAggregateOutputType = {
    id: number | null
    community: number | null
    verifiedBy: number | null
    rank: number | null
  }

  export type LeaderboardEntrySumAggregateOutputType = {
    id: number | null
    community: number | null
    verifiedBy: number | null
    rank: number | null
  }

  export type LeaderboardEntryMinAggregateOutputType = {
    id: number | null
    user: string | null
    community: number | null
    entryUrl: string | null
    verifiedBy: number | null
    isVerified: boolean | null
    rank: number | null
  }

  export type LeaderboardEntryMaxAggregateOutputType = {
    id: number | null
    user: string | null
    community: number | null
    entryUrl: string | null
    verifiedBy: number | null
    isVerified: boolean | null
    rank: number | null
  }

  export type LeaderboardEntryCountAggregateOutputType = {
    id: number
    user: number
    community: number
    entryUrl: number
    verifiedBy: number
    isVerified: number
    rank: number
    _all: number
  }


  export type LeaderboardEntryAvgAggregateInputType = {
    id?: true
    community?: true
    verifiedBy?: true
    rank?: true
  }

  export type LeaderboardEntrySumAggregateInputType = {
    id?: true
    community?: true
    verifiedBy?: true
    rank?: true
  }

  export type LeaderboardEntryMinAggregateInputType = {
    id?: true
    user?: true
    community?: true
    entryUrl?: true
    verifiedBy?: true
    isVerified?: true
    rank?: true
  }

  export type LeaderboardEntryMaxAggregateInputType = {
    id?: true
    user?: true
    community?: true
    entryUrl?: true
    verifiedBy?: true
    isVerified?: true
    rank?: true
  }

  export type LeaderboardEntryCountAggregateInputType = {
    id?: true
    user?: true
    community?: true
    entryUrl?: true
    verifiedBy?: true
    isVerified?: true
    rank?: true
    _all?: true
  }

  export type LeaderboardEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaderboardEntry to aggregate.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaderboardEntries
    **/
    _count?: true | LeaderboardEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaderboardEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaderboardEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaderboardEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaderboardEntryMaxAggregateInputType
  }

  export type GetLeaderboardEntryAggregateType<T extends LeaderboardEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaderboardEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaderboardEntry[P]>
      : GetScalarType<T[P], AggregateLeaderboardEntry[P]>
  }




  export type LeaderboardEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardEntryWhereInput
    orderBy?: LeaderboardEntryOrderByWithAggregationInput | LeaderboardEntryOrderByWithAggregationInput[]
    by: LeaderboardEntryScalarFieldEnum[] | LeaderboardEntryScalarFieldEnum
    having?: LeaderboardEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaderboardEntryCountAggregateInputType | true
    _avg?: LeaderboardEntryAvgAggregateInputType
    _sum?: LeaderboardEntrySumAggregateInputType
    _min?: LeaderboardEntryMinAggregateInputType
    _max?: LeaderboardEntryMaxAggregateInputType
  }

  export type LeaderboardEntryGroupByOutputType = {
    id: number
    user: string | null
    community: number | null
    entryUrl: string | null
    verifiedBy: number | null
    isVerified: boolean | null
    rank: number | null
    _count: LeaderboardEntryCountAggregateOutputType | null
    _avg: LeaderboardEntryAvgAggregateOutputType | null
    _sum: LeaderboardEntrySumAggregateOutputType | null
    _min: LeaderboardEntryMinAggregateOutputType | null
    _max: LeaderboardEntryMaxAggregateOutputType | null
  }

  type GetLeaderboardEntryGroupByPayload<T extends LeaderboardEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaderboardEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaderboardEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaderboardEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LeaderboardEntryGroupByOutputType[P]>
        }
      >
    >


  export type LeaderboardEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user?: boolean
    community?: boolean
    entryUrl?: boolean
    verifiedBy?: boolean
    isVerified?: boolean
    rank?: boolean
    Community?: boolean | LeaderboardEntry$CommunityArgs<ExtArgs>
    User?: boolean | LeaderboardEntry$UserArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboardEntry"]>

  export type LeaderboardEntrySelectScalar = {
    id?: boolean
    user?: boolean
    community?: boolean
    entryUrl?: boolean
    verifiedBy?: boolean
    isVerified?: boolean
    rank?: boolean
  }

  export type LeaderboardEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Community?: boolean | LeaderboardEntry$CommunityArgs<ExtArgs>
    User?: boolean | LeaderboardEntry$UserArgs<ExtArgs>
  }


  export type $LeaderboardEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaderboardEntry"
    objects: {
      Community: Prisma.$CommunityPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user: string | null
      community: number | null
      entryUrl: string | null
      verifiedBy: number | null
      isVerified: boolean | null
      rank: number | null
    }, ExtArgs["result"]["leaderboardEntry"]>
    composites: {}
  }


  type LeaderboardEntryGetPayload<S extends boolean | null | undefined | LeaderboardEntryDefaultArgs> = $Result.GetResult<Prisma.$LeaderboardEntryPayload, S>

  type LeaderboardEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaderboardEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaderboardEntryCountAggregateInputType | true
    }

  export interface LeaderboardEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaderboardEntry'], meta: { name: 'LeaderboardEntry' } }
    /**
     * Find zero or one LeaderboardEntry that matches the filter.
     * @param {LeaderboardEntryFindUniqueArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LeaderboardEntryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardEntryFindUniqueArgs<ExtArgs>>
    ): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LeaderboardEntry that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LeaderboardEntryFindUniqueOrThrowArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LeaderboardEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryFindFirstArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LeaderboardEntryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardEntryFindFirstArgs<ExtArgs>>
    ): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LeaderboardEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryFindFirstOrThrowArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LeaderboardEntryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardEntryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LeaderboardEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaderboardEntries
     * const leaderboardEntries = await prisma.leaderboardEntry.findMany()
     * 
     * // Get first 10 LeaderboardEntries
     * const leaderboardEntries = await prisma.leaderboardEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaderboardEntryWithIdOnly = await prisma.leaderboardEntry.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LeaderboardEntryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardEntryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LeaderboardEntry.
     * @param {LeaderboardEntryCreateArgs} args - Arguments to create a LeaderboardEntry.
     * @example
     * // Create one LeaderboardEntry
     * const LeaderboardEntry = await prisma.leaderboardEntry.create({
     *   data: {
     *     // ... data to create a LeaderboardEntry
     *   }
     * })
     * 
    **/
    create<T extends LeaderboardEntryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardEntryCreateArgs<ExtArgs>>
    ): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LeaderboardEntries.
     *     @param {LeaderboardEntryCreateManyArgs} args - Arguments to create many LeaderboardEntries.
     *     @example
     *     // Create many LeaderboardEntries
     *     const leaderboardEntry = await prisma.leaderboardEntry.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LeaderboardEntryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardEntryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LeaderboardEntry.
     * @param {LeaderboardEntryDeleteArgs} args - Arguments to delete one LeaderboardEntry.
     * @example
     * // Delete one LeaderboardEntry
     * const LeaderboardEntry = await prisma.leaderboardEntry.delete({
     *   where: {
     *     // ... filter to delete one LeaderboardEntry
     *   }
     * })
     * 
    **/
    delete<T extends LeaderboardEntryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardEntryDeleteArgs<ExtArgs>>
    ): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LeaderboardEntry.
     * @param {LeaderboardEntryUpdateArgs} args - Arguments to update one LeaderboardEntry.
     * @example
     * // Update one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LeaderboardEntryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardEntryUpdateArgs<ExtArgs>>
    ): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LeaderboardEntries.
     * @param {LeaderboardEntryDeleteManyArgs} args - Arguments to filter LeaderboardEntries to delete.
     * @example
     * // Delete a few LeaderboardEntries
     * const { count } = await prisma.leaderboardEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LeaderboardEntryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardEntryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaderboardEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaderboardEntries
     * const leaderboardEntry = await prisma.leaderboardEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LeaderboardEntryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardEntryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaderboardEntry.
     * @param {LeaderboardEntryUpsertArgs} args - Arguments to update or create a LeaderboardEntry.
     * @example
     * // Update or create a LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.upsert({
     *   create: {
     *     // ... data to create a LeaderboardEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaderboardEntry we want to update
     *   }
     * })
    **/
    upsert<T extends LeaderboardEntryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardEntryUpsertArgs<ExtArgs>>
    ): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LeaderboardEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryCountArgs} args - Arguments to filter LeaderboardEntries to count.
     * @example
     * // Count the number of LeaderboardEntries
     * const count = await prisma.leaderboardEntry.count({
     *   where: {
     *     // ... the filter for the LeaderboardEntries we want to count
     *   }
     * })
    **/
    count<T extends LeaderboardEntryCountArgs>(
      args?: Subset<T, LeaderboardEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaderboardEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaderboardEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaderboardEntryAggregateArgs>(args: Subset<T, LeaderboardEntryAggregateArgs>): Prisma.PrismaPromise<GetLeaderboardEntryAggregateType<T>>

    /**
     * Group by LeaderboardEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaderboardEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaderboardEntryGroupByArgs['orderBy'] }
        : { orderBy?: LeaderboardEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaderboardEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaderboardEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaderboardEntry model
   */
  readonly fields: LeaderboardEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaderboardEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaderboardEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Community<T extends LeaderboardEntry$CommunityArgs<ExtArgs> = {}>(args?: Subset<T, LeaderboardEntry$CommunityArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    User<T extends LeaderboardEntry$UserArgs<ExtArgs> = {}>(args?: Subset<T, LeaderboardEntry$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LeaderboardEntry model
   */ 
  interface LeaderboardEntryFieldRefs {
    readonly id: FieldRef<"LeaderboardEntry", 'Int'>
    readonly user: FieldRef<"LeaderboardEntry", 'String'>
    readonly community: FieldRef<"LeaderboardEntry", 'Int'>
    readonly entryUrl: FieldRef<"LeaderboardEntry", 'String'>
    readonly verifiedBy: FieldRef<"LeaderboardEntry", 'Int'>
    readonly isVerified: FieldRef<"LeaderboardEntry", 'Boolean'>
    readonly rank: FieldRef<"LeaderboardEntry", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * LeaderboardEntry findUnique
   */
  export type LeaderboardEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where: LeaderboardEntryWhereUniqueInput
  }


  /**
   * LeaderboardEntry findUniqueOrThrow
   */
  export type LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where: LeaderboardEntryWhereUniqueInput
  }


  /**
   * LeaderboardEntry findFirst
   */
  export type LeaderboardEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaderboardEntries.
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaderboardEntries.
     */
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }


  /**
   * LeaderboardEntry findFirstOrThrow
   */
  export type LeaderboardEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaderboardEntries.
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaderboardEntries.
     */
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }


  /**
   * LeaderboardEntry findMany
   */
  export type LeaderboardEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntries to fetch.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaderboardEntries.
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }


  /**
   * LeaderboardEntry create
   */
  export type LeaderboardEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaderboardEntry.
     */
    data?: XOR<LeaderboardEntryCreateInput, LeaderboardEntryUncheckedCreateInput>
  }


  /**
   * LeaderboardEntry createMany
   */
  export type LeaderboardEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaderboardEntries.
     */
    data: LeaderboardEntryCreateManyInput | LeaderboardEntryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LeaderboardEntry update
   */
  export type LeaderboardEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaderboardEntry.
     */
    data: XOR<LeaderboardEntryUpdateInput, LeaderboardEntryUncheckedUpdateInput>
    /**
     * Choose, which LeaderboardEntry to update.
     */
    where: LeaderboardEntryWhereUniqueInput
  }


  /**
   * LeaderboardEntry updateMany
   */
  export type LeaderboardEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaderboardEntries.
     */
    data: XOR<LeaderboardEntryUpdateManyMutationInput, LeaderboardEntryUncheckedUpdateManyInput>
    /**
     * Filter which LeaderboardEntries to update
     */
    where?: LeaderboardEntryWhereInput
  }


  /**
   * LeaderboardEntry upsert
   */
  export type LeaderboardEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaderboardEntry to update in case it exists.
     */
    where: LeaderboardEntryWhereUniqueInput
    /**
     * In case the LeaderboardEntry found by the `where` argument doesn't exist, create a new LeaderboardEntry with this data.
     */
    create: XOR<LeaderboardEntryCreateInput, LeaderboardEntryUncheckedCreateInput>
    /**
     * In case the LeaderboardEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaderboardEntryUpdateInput, LeaderboardEntryUncheckedUpdateInput>
  }


  /**
   * LeaderboardEntry delete
   */
  export type LeaderboardEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter which LeaderboardEntry to delete.
     */
    where: LeaderboardEntryWhereUniqueInput
  }


  /**
   * LeaderboardEntry deleteMany
   */
  export type LeaderboardEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaderboardEntries to delete
     */
    where?: LeaderboardEntryWhereInput
  }


  /**
   * LeaderboardEntry.Community
   */
  export type LeaderboardEntry$CommunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    where?: CommunityWhereInput
  }


  /**
   * LeaderboardEntry.User
   */
  export type LeaderboardEntry$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * LeaderboardEntry without action
   */
  export type LeaderboardEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
  }



  /**
   * Model Like
   */

  export type AggregateLike = {
    _count: LikeCountAggregateOutputType | null
    _avg: LikeAvgAggregateOutputType | null
    _sum: LikeSumAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  export type LikeAvgAggregateOutputType = {
    id: number | null
    post: number | null
  }

  export type LikeSumAggregateOutputType = {
    id: number | null
    post: number | null
  }

  export type LikeMinAggregateOutputType = {
    id: number | null
    user: string | null
    post: number | null
  }

  export type LikeMaxAggregateOutputType = {
    id: number | null
    user: string | null
    post: number | null
  }

  export type LikeCountAggregateOutputType = {
    id: number
    user: number
    post: number
    _all: number
  }


  export type LikeAvgAggregateInputType = {
    id?: true
    post?: true
  }

  export type LikeSumAggregateInputType = {
    id?: true
    post?: true
  }

  export type LikeMinAggregateInputType = {
    id?: true
    user?: true
    post?: true
  }

  export type LikeMaxAggregateInputType = {
    id?: true
    user?: true
    post?: true
  }

  export type LikeCountAggregateInputType = {
    id?: true
    user?: true
    post?: true
    _all?: true
  }

  export type LikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Like to aggregate.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Likes
    **/
    _count?: true | LikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeMaxAggregateInputType
  }

  export type GetLikeAggregateType<T extends LikeAggregateArgs> = {
        [P in keyof T & keyof AggregateLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLike[P]>
      : GetScalarType<T[P], AggregateLike[P]>
  }




  export type LikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithAggregationInput | LikeOrderByWithAggregationInput[]
    by: LikeScalarFieldEnum[] | LikeScalarFieldEnum
    having?: LikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeCountAggregateInputType | true
    _avg?: LikeAvgAggregateInputType
    _sum?: LikeSumAggregateInputType
    _min?: LikeMinAggregateInputType
    _max?: LikeMaxAggregateInputType
  }

  export type LikeGroupByOutputType = {
    id: number
    user: string | null
    post: number | null
    _count: LikeCountAggregateOutputType | null
    _avg: LikeAvgAggregateOutputType | null
    _sum: LikeSumAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  type GetLikeGroupByPayload<T extends LikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeGroupByOutputType[P]>
            : GetScalarType<T[P], LikeGroupByOutputType[P]>
        }
      >
    >


  export type LikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user?: boolean
    post?: boolean
  }, ExtArgs["result"]["like"]>

  export type LikeSelectScalar = {
    id?: boolean
    user?: boolean
    post?: boolean
  }


  export type $LikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Like"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user: string | null
      post: number | null
    }, ExtArgs["result"]["like"]>
    composites: {}
  }


  type LikeGetPayload<S extends boolean | null | undefined | LikeDefaultArgs> = $Result.GetResult<Prisma.$LikePayload, S>

  type LikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LikeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LikeCountAggregateInputType | true
    }

  export interface LikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Like'], meta: { name: 'Like' } }
    /**
     * Find zero or one Like that matches the filter.
     * @param {LikeFindUniqueArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LikeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LikeFindUniqueArgs<ExtArgs>>
    ): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Like that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LikeFindUniqueOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LikeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LikeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LikeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LikeFindFirstArgs<ExtArgs>>
    ): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Like that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LikeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LikeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.like.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.like.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeWithIdOnly = await prisma.like.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LikeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LikeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Like.
     * @param {LikeCreateArgs} args - Arguments to create a Like.
     * @example
     * // Create one Like
     * const Like = await prisma.like.create({
     *   data: {
     *     // ... data to create a Like
     *   }
     * })
     * 
    **/
    create<T extends LikeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LikeCreateArgs<ExtArgs>>
    ): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Likes.
     *     @param {LikeCreateManyArgs} args - Arguments to create many Likes.
     *     @example
     *     // Create many Likes
     *     const like = await prisma.like.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LikeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LikeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Like.
     * @param {LikeDeleteArgs} args - Arguments to delete one Like.
     * @example
     * // Delete one Like
     * const Like = await prisma.like.delete({
     *   where: {
     *     // ... filter to delete one Like
     *   }
     * })
     * 
    **/
    delete<T extends LikeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LikeDeleteArgs<ExtArgs>>
    ): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Like.
     * @param {LikeUpdateArgs} args - Arguments to update one Like.
     * @example
     * // Update one Like
     * const like = await prisma.like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LikeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LikeUpdateArgs<ExtArgs>>
    ): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Likes.
     * @param {LikeDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LikeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LikeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LikeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LikeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Like.
     * @param {LikeUpsertArgs} args - Arguments to update or create a Like.
     * @example
     * // Update or create a Like
     * const like = await prisma.like.upsert({
     *   create: {
     *     // ... data to create a Like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Like we want to update
     *   }
     * })
    **/
    upsert<T extends LikeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LikeUpsertArgs<ExtArgs>>
    ): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.like.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends LikeCountArgs>(
      args?: Subset<T, LikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeAggregateArgs>(args: Subset<T, LikeAggregateArgs>): Prisma.PrismaPromise<GetLikeAggregateType<T>>

    /**
     * Group by Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeGroupByArgs['orderBy'] }
        : { orderBy?: LikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Like model
   */
  readonly fields: LikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Like model
   */ 
  interface LikeFieldRefs {
    readonly id: FieldRef<"Like", 'Int'>
    readonly user: FieldRef<"Like", 'String'>
    readonly post: FieldRef<"Like", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Like findUnique
   */
  export type LikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }


  /**
   * Like findUniqueOrThrow
   */
  export type LikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }


  /**
   * Like findFirst
   */
  export type LikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }


  /**
   * Like findFirstOrThrow
   */
  export type LikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }


  /**
   * Like findMany
   */
  export type LikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }


  /**
   * Like create
   */
  export type LikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * The data needed to create a Like.
     */
    data?: XOR<LikeCreateInput, LikeUncheckedCreateInput>
  }


  /**
   * Like createMany
   */
  export type LikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Like update
   */
  export type LikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * The data needed to update a Like.
     */
    data: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
    /**
     * Choose, which Like to update.
     */
    where: LikeWhereUniqueInput
  }


  /**
   * Like updateMany
   */
  export type LikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
  }


  /**
   * Like upsert
   */
  export type LikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * The filter to search for the Like to update in case it exists.
     */
    where: LikeWhereUniqueInput
    /**
     * In case the Like found by the `where` argument doesn't exist, create a new Like with this data.
     */
    create: XOR<LikeCreateInput, LikeUncheckedCreateInput>
    /**
     * In case the Like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
  }


  /**
   * Like delete
   */
  export type LikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Filter which Like to delete.
     */
    where: LikeWhereUniqueInput
  }


  /**
   * Like deleteMany
   */
  export type LikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Likes to delete
     */
    where?: LikeWhereInput
  }


  /**
   * Like without action
   */
  export type LikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
  }



  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogAvgAggregateOutputType = {
    id: number | null
  }

  export type LogSumAggregateOutputType = {
    id: number | null
  }

  export type LogMinAggregateOutputType = {
    id: number | null
    email: string | null
    context: string | null
    message: string | null
    type: string | null
    level: string | null
    timestamp: Date | null
  }

  export type LogMaxAggregateOutputType = {
    id: number | null
    email: string | null
    context: string | null
    message: string | null
    type: string | null
    level: string | null
    timestamp: Date | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    email: number
    context: number
    message: number
    type: number
    level: number
    timestamp: number
    _all: number
  }


  export type LogAvgAggregateInputType = {
    id?: true
  }

  export type LogSumAggregateInputType = {
    id?: true
  }

  export type LogMinAggregateInputType = {
    id?: true
    email?: true
    context?: true
    message?: true
    type?: true
    level?: true
    timestamp?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    email?: true
    context?: true
    message?: true
    type?: true
    level?: true
    timestamp?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    email?: true
    context?: true
    message?: true
    type?: true
    level?: true
    timestamp?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _avg?: LogAvgAggregateInputType
    _sum?: LogSumAggregateInputType
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: number
    email: string | null
    context: string | null
    message: string | null
    type: string | null
    level: string | null
    timestamp: Date | null
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    context?: boolean
    message?: boolean
    type?: boolean
    level?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["log"]>

  export type LogSelectScalar = {
    id?: boolean
    email?: boolean
    context?: boolean
    message?: boolean
    type?: boolean
    level?: boolean
    timestamp?: boolean
  }


  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string | null
      context: string | null
      message: string | null
      type: string | null
      level: string | null
      timestamp: Date | null
    }, ExtArgs["result"]["log"]>
    composites: {}
  }


  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>
    ): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Log that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>
    ): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
    **/
    create<T extends LogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogCreateArgs<ExtArgs>>
    ): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Logs.
     *     @param {LogCreateManyArgs} args - Arguments to create many Logs.
     *     @example
     *     // Create many Logs
     *     const log = await prisma.log.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
    **/
    delete<T extends LogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogDeleteArgs<ExtArgs>>
    ): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogUpdateArgs<ExtArgs>>
    ): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
    **/
    upsert<T extends LogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogUpsertArgs<ExtArgs>>
    ): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Log model
   */ 
  interface LogFieldRefs {
    readonly id: FieldRef<"Log", 'Int'>
    readonly email: FieldRef<"Log", 'String'>
    readonly context: FieldRef<"Log", 'String'>
    readonly message: FieldRef<"Log", 'String'>
    readonly type: FieldRef<"Log", 'String'>
    readonly level: FieldRef<"Log", 'String'>
    readonly timestamp: FieldRef<"Log", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }


  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }


  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }


  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }


  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }


  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data?: XOR<LogCreateInput, LogUncheckedCreateInput>
  }


  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
  }


  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
  }


  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }


  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
  }


  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
  }


  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
  }



  /**
   * Model PendingPost
   */

  export type AggregatePendingPost = {
    _count: PendingPostCountAggregateOutputType | null
    _avg: PendingPostAvgAggregateOutputType | null
    _sum: PendingPostSumAggregateOutputType | null
    _min: PendingPostMinAggregateOutputType | null
    _max: PendingPostMaxAggregateOutputType | null
  }

  export type PendingPostAvgAggregateOutputType = {
    id: number | null
    community: number | null
  }

  export type PendingPostSumAggregateOutputType = {
    id: number | null
    community: number | null
  }

  export type PendingPostMinAggregateOutputType = {
    id: number | null
    Content: string | null
    fileUrl: string | null
    community: number | null
    user: string | null
    caption: string | null
    status: string | null
    confirmationToken: string | null
  }

  export type PendingPostMaxAggregateOutputType = {
    id: number | null
    Content: string | null
    fileUrl: string | null
    community: number | null
    user: string | null
    caption: string | null
    status: string | null
    confirmationToken: string | null
  }

  export type PendingPostCountAggregateOutputType = {
    id: number
    Content: number
    fileUrl: number
    community: number
    user: number
    caption: number
    status: number
    confirmationToken: number
    _all: number
  }


  export type PendingPostAvgAggregateInputType = {
    id?: true
    community?: true
  }

  export type PendingPostSumAggregateInputType = {
    id?: true
    community?: true
  }

  export type PendingPostMinAggregateInputType = {
    id?: true
    Content?: true
    fileUrl?: true
    community?: true
    user?: true
    caption?: true
    status?: true
    confirmationToken?: true
  }

  export type PendingPostMaxAggregateInputType = {
    id?: true
    Content?: true
    fileUrl?: true
    community?: true
    user?: true
    caption?: true
    status?: true
    confirmationToken?: true
  }

  export type PendingPostCountAggregateInputType = {
    id?: true
    Content?: true
    fileUrl?: true
    community?: true
    user?: true
    caption?: true
    status?: true
    confirmationToken?: true
    _all?: true
  }

  export type PendingPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingPost to aggregate.
     */
    where?: PendingPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPosts to fetch.
     */
    orderBy?: PendingPostOrderByWithRelationInput | PendingPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendingPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingPosts
    **/
    _count?: true | PendingPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendingPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendingPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendingPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendingPostMaxAggregateInputType
  }

  export type GetPendingPostAggregateType<T extends PendingPostAggregateArgs> = {
        [P in keyof T & keyof AggregatePendingPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingPost[P]>
      : GetScalarType<T[P], AggregatePendingPost[P]>
  }




  export type PendingPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingPostWhereInput
    orderBy?: PendingPostOrderByWithAggregationInput | PendingPostOrderByWithAggregationInput[]
    by: PendingPostScalarFieldEnum[] | PendingPostScalarFieldEnum
    having?: PendingPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendingPostCountAggregateInputType | true
    _avg?: PendingPostAvgAggregateInputType
    _sum?: PendingPostSumAggregateInputType
    _min?: PendingPostMinAggregateInputType
    _max?: PendingPostMaxAggregateInputType
  }

  export type PendingPostGroupByOutputType = {
    id: number
    Content: string | null
    fileUrl: string | null
    community: number | null
    user: string | null
    caption: string | null
    status: string | null
    confirmationToken: string | null
    _count: PendingPostCountAggregateOutputType | null
    _avg: PendingPostAvgAggregateOutputType | null
    _sum: PendingPostSumAggregateOutputType | null
    _min: PendingPostMinAggregateOutputType | null
    _max: PendingPostMaxAggregateOutputType | null
  }

  type GetPendingPostGroupByPayload<T extends PendingPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendingPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendingPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendingPostGroupByOutputType[P]>
            : GetScalarType<T[P], PendingPostGroupByOutputType[P]>
        }
      >
    >


  export type PendingPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Content?: boolean
    fileUrl?: boolean
    community?: boolean
    user?: boolean
    caption?: boolean
    status?: boolean
    confirmationToken?: boolean
    Community?: boolean | PendingPost$CommunityArgs<ExtArgs>
    User?: boolean | PendingPost$UserArgs<ExtArgs>
  }, ExtArgs["result"]["pendingPost"]>

  export type PendingPostSelectScalar = {
    id?: boolean
    Content?: boolean
    fileUrl?: boolean
    community?: boolean
    user?: boolean
    caption?: boolean
    status?: boolean
    confirmationToken?: boolean
  }

  export type PendingPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Community?: boolean | PendingPost$CommunityArgs<ExtArgs>
    User?: boolean | PendingPost$UserArgs<ExtArgs>
  }


  export type $PendingPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PendingPost"
    objects: {
      Community: Prisma.$CommunityPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      Content: string | null
      fileUrl: string | null
      community: number | null
      user: string | null
      caption: string | null
      status: string | null
      confirmationToken: string | null
    }, ExtArgs["result"]["pendingPost"]>
    composites: {}
  }


  type PendingPostGetPayload<S extends boolean | null | undefined | PendingPostDefaultArgs> = $Result.GetResult<Prisma.$PendingPostPayload, S>

  type PendingPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PendingPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PendingPostCountAggregateInputType | true
    }

  export interface PendingPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PendingPost'], meta: { name: 'PendingPost' } }
    /**
     * Find zero or one PendingPost that matches the filter.
     * @param {PendingPostFindUniqueArgs} args - Arguments to find a PendingPost
     * @example
     * // Get one PendingPost
     * const pendingPost = await prisma.pendingPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PendingPostFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PendingPostFindUniqueArgs<ExtArgs>>
    ): Prisma__PendingPostClient<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PendingPost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PendingPostFindUniqueOrThrowArgs} args - Arguments to find a PendingPost
     * @example
     * // Get one PendingPost
     * const pendingPost = await prisma.pendingPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PendingPostFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingPostFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PendingPostClient<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PendingPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostFindFirstArgs} args - Arguments to find a PendingPost
     * @example
     * // Get one PendingPost
     * const pendingPost = await prisma.pendingPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PendingPostFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingPostFindFirstArgs<ExtArgs>>
    ): Prisma__PendingPostClient<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PendingPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostFindFirstOrThrowArgs} args - Arguments to find a PendingPost
     * @example
     * // Get one PendingPost
     * const pendingPost = await prisma.pendingPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PendingPostFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingPostFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PendingPostClient<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PendingPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingPosts
     * const pendingPosts = await prisma.pendingPost.findMany()
     * 
     * // Get first 10 PendingPosts
     * const pendingPosts = await prisma.pendingPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingPostWithIdOnly = await prisma.pendingPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PendingPostFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingPostFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PendingPost.
     * @param {PendingPostCreateArgs} args - Arguments to create a PendingPost.
     * @example
     * // Create one PendingPost
     * const PendingPost = await prisma.pendingPost.create({
     *   data: {
     *     // ... data to create a PendingPost
     *   }
     * })
     * 
    **/
    create<T extends PendingPostCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PendingPostCreateArgs<ExtArgs>>
    ): Prisma__PendingPostClient<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PendingPosts.
     *     @param {PendingPostCreateManyArgs} args - Arguments to create many PendingPosts.
     *     @example
     *     // Create many PendingPosts
     *     const pendingPost = await prisma.pendingPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PendingPostCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingPostCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PendingPost.
     * @param {PendingPostDeleteArgs} args - Arguments to delete one PendingPost.
     * @example
     * // Delete one PendingPost
     * const PendingPost = await prisma.pendingPost.delete({
     *   where: {
     *     // ... filter to delete one PendingPost
     *   }
     * })
     * 
    **/
    delete<T extends PendingPostDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PendingPostDeleteArgs<ExtArgs>>
    ): Prisma__PendingPostClient<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PendingPost.
     * @param {PendingPostUpdateArgs} args - Arguments to update one PendingPost.
     * @example
     * // Update one PendingPost
     * const pendingPost = await prisma.pendingPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PendingPostUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PendingPostUpdateArgs<ExtArgs>>
    ): Prisma__PendingPostClient<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PendingPosts.
     * @param {PendingPostDeleteManyArgs} args - Arguments to filter PendingPosts to delete.
     * @example
     * // Delete a few PendingPosts
     * const { count } = await prisma.pendingPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PendingPostDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingPostDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingPosts
     * const pendingPost = await prisma.pendingPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PendingPostUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PendingPostUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PendingPost.
     * @param {PendingPostUpsertArgs} args - Arguments to update or create a PendingPost.
     * @example
     * // Update or create a PendingPost
     * const pendingPost = await prisma.pendingPost.upsert({
     *   create: {
     *     // ... data to create a PendingPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingPost we want to update
     *   }
     * })
    **/
    upsert<T extends PendingPostUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PendingPostUpsertArgs<ExtArgs>>
    ): Prisma__PendingPostClient<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PendingPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostCountArgs} args - Arguments to filter PendingPosts to count.
     * @example
     * // Count the number of PendingPosts
     * const count = await prisma.pendingPost.count({
     *   where: {
     *     // ... the filter for the PendingPosts we want to count
     *   }
     * })
    **/
    count<T extends PendingPostCountArgs>(
      args?: Subset<T, PendingPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingPostAggregateArgs>(args: Subset<T, PendingPostAggregateArgs>): Prisma.PrismaPromise<GetPendingPostAggregateType<T>>

    /**
     * Group by PendingPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingPostGroupByArgs['orderBy'] }
        : { orderBy?: PendingPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PendingPost model
   */
  readonly fields: PendingPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendingPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Community<T extends PendingPost$CommunityArgs<ExtArgs> = {}>(args?: Subset<T, PendingPost$CommunityArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    User<T extends PendingPost$UserArgs<ExtArgs> = {}>(args?: Subset<T, PendingPost$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PendingPost model
   */ 
  interface PendingPostFieldRefs {
    readonly id: FieldRef<"PendingPost", 'Int'>
    readonly Content: FieldRef<"PendingPost", 'String'>
    readonly fileUrl: FieldRef<"PendingPost", 'String'>
    readonly community: FieldRef<"PendingPost", 'Int'>
    readonly user: FieldRef<"PendingPost", 'String'>
    readonly caption: FieldRef<"PendingPost", 'String'>
    readonly status: FieldRef<"PendingPost", 'String'>
    readonly confirmationToken: FieldRef<"PendingPost", 'String'>
  }
    

  // Custom InputTypes

  /**
   * PendingPost findUnique
   */
  export type PendingPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    /**
     * Filter, which PendingPost to fetch.
     */
    where: PendingPostWhereUniqueInput
  }


  /**
   * PendingPost findUniqueOrThrow
   */
  export type PendingPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    /**
     * Filter, which PendingPost to fetch.
     */
    where: PendingPostWhereUniqueInput
  }


  /**
   * PendingPost findFirst
   */
  export type PendingPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    /**
     * Filter, which PendingPost to fetch.
     */
    where?: PendingPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPosts to fetch.
     */
    orderBy?: PendingPostOrderByWithRelationInput | PendingPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingPosts.
     */
    cursor?: PendingPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingPosts.
     */
    distinct?: PendingPostScalarFieldEnum | PendingPostScalarFieldEnum[]
  }


  /**
   * PendingPost findFirstOrThrow
   */
  export type PendingPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    /**
     * Filter, which PendingPost to fetch.
     */
    where?: PendingPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPosts to fetch.
     */
    orderBy?: PendingPostOrderByWithRelationInput | PendingPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingPosts.
     */
    cursor?: PendingPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingPosts.
     */
    distinct?: PendingPostScalarFieldEnum | PendingPostScalarFieldEnum[]
  }


  /**
   * PendingPost findMany
   */
  export type PendingPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    /**
     * Filter, which PendingPosts to fetch.
     */
    where?: PendingPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPosts to fetch.
     */
    orderBy?: PendingPostOrderByWithRelationInput | PendingPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingPosts.
     */
    cursor?: PendingPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPosts.
     */
    skip?: number
    distinct?: PendingPostScalarFieldEnum | PendingPostScalarFieldEnum[]
  }


  /**
   * PendingPost create
   */
  export type PendingPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    /**
     * The data needed to create a PendingPost.
     */
    data?: XOR<PendingPostCreateInput, PendingPostUncheckedCreateInput>
  }


  /**
   * PendingPost createMany
   */
  export type PendingPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PendingPosts.
     */
    data: PendingPostCreateManyInput | PendingPostCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PendingPost update
   */
  export type PendingPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    /**
     * The data needed to update a PendingPost.
     */
    data: XOR<PendingPostUpdateInput, PendingPostUncheckedUpdateInput>
    /**
     * Choose, which PendingPost to update.
     */
    where: PendingPostWhereUniqueInput
  }


  /**
   * PendingPost updateMany
   */
  export type PendingPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PendingPosts.
     */
    data: XOR<PendingPostUpdateManyMutationInput, PendingPostUncheckedUpdateManyInput>
    /**
     * Filter which PendingPosts to update
     */
    where?: PendingPostWhereInput
  }


  /**
   * PendingPost upsert
   */
  export type PendingPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    /**
     * The filter to search for the PendingPost to update in case it exists.
     */
    where: PendingPostWhereUniqueInput
    /**
     * In case the PendingPost found by the `where` argument doesn't exist, create a new PendingPost with this data.
     */
    create: XOR<PendingPostCreateInput, PendingPostUncheckedCreateInput>
    /**
     * In case the PendingPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendingPostUpdateInput, PendingPostUncheckedUpdateInput>
  }


  /**
   * PendingPost delete
   */
  export type PendingPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    /**
     * Filter which PendingPost to delete.
     */
    where: PendingPostWhereUniqueInput
  }


  /**
   * PendingPost deleteMany
   */
  export type PendingPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingPosts to delete
     */
    where?: PendingPostWhereInput
  }


  /**
   * PendingPost.Community
   */
  export type PendingPost$CommunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    where?: CommunityWhereInput
  }


  /**
   * PendingPost.User
   */
  export type PendingPost$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * PendingPost without action
   */
  export type PendingPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
  }



  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    id: number | null
    community: number | null
  }

  export type PostSumAggregateOutputType = {
    id: number | null
    community: number | null
  }

  export type PostMinAggregateOutputType = {
    id: number | null
    Content: string | null
    fileUrl: string | null
    community: number | null
    user: string | null
    caption: string | null
  }

  export type PostMaxAggregateOutputType = {
    id: number | null
    Content: string | null
    fileUrl: string | null
    community: number | null
    user: string | null
    caption: string | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    Content: number
    fileUrl: number
    community: number
    user: number
    caption: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    id?: true
    community?: true
  }

  export type PostSumAggregateInputType = {
    id?: true
    community?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    Content?: true
    fileUrl?: true
    community?: true
    user?: true
    caption?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    Content?: true
    fileUrl?: true
    community?: true
    user?: true
    caption?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    Content?: true
    fileUrl?: true
    community?: true
    user?: true
    caption?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: number
    Content: string | null
    fileUrl: string | null
    community: number | null
    user: string | null
    caption: string | null
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Content?: boolean
    fileUrl?: boolean
    community?: boolean
    user?: boolean
    caption?: boolean
    Comment?: boolean | Post$CommentArgs<ExtArgs>
    Community?: boolean | Post$CommunityArgs<ExtArgs>
    User?: boolean | Post$UserArgs<ExtArgs>
    Report?: boolean | Post$ReportArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    Content?: boolean
    fileUrl?: boolean
    community?: boolean
    user?: boolean
    caption?: boolean
  }

  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | Post$CommentArgs<ExtArgs>
    Community?: boolean | Post$CommunityArgs<ExtArgs>
    User?: boolean | Post$UserArgs<ExtArgs>
    Report?: boolean | Post$ReportArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      Comment: Prisma.$CommentPayload<ExtArgs>[]
      Community: Prisma.$CommunityPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs> | null
      Report: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      Content: string | null
      fileUrl: string | null
      community: number | null
      user: string | null
      caption: string | null
    }, ExtArgs["result"]["post"]>
    composites: {}
  }


  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Post that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
    **/
    create<T extends PostCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PostCreateArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Posts.
     *     @param {PostCreateManyArgs} args - Arguments to create many Posts.
     *     @example
     *     // Create many Posts
     *     const post = await prisma.post.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
    **/
    delete<T extends PostDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PostDeleteArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PostUpdateArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
    **/
    upsert<T extends PostUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PostUpsertArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Comment<T extends Post$CommentArgs<ExtArgs> = {}>(args?: Subset<T, Post$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null>;

    Community<T extends Post$CommunityArgs<ExtArgs> = {}>(args?: Subset<T, Post$CommunityArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    User<T extends Post$UserArgs<ExtArgs> = {}>(args?: Subset<T, Post$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Report<T extends Post$ReportArgs<ExtArgs> = {}>(args?: Subset<T, Post$ReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Post model
   */ 
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'Int'>
    readonly Content: FieldRef<"Post", 'String'>
    readonly fileUrl: FieldRef<"Post", 'String'>
    readonly community: FieldRef<"Post", 'Int'>
    readonly user: FieldRef<"Post", 'String'>
    readonly caption: FieldRef<"Post", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }


  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }


  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }


  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data?: XOR<PostCreateInput, PostUncheckedCreateInput>
  }


  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }


  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }


  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }


  /**
   * Post.Comment
   */
  export type Post$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Post.Community
   */
  export type Post$CommunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    where?: CommunityWhereInput
  }


  /**
   * Post.User
   */
  export type Post$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Post.Report
   */
  export type Post$ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
  }



  /**
   * Model Preferences
   */

  export type AggregatePreferences = {
    _count: PreferencesCountAggregateOutputType | null
    _avg: PreferencesAvgAggregateOutputType | null
    _sum: PreferencesSumAggregateOutputType | null
    _min: PreferencesMinAggregateOutputType | null
    _max: PreferencesMaxAggregateOutputType | null
  }

  export type PreferencesAvgAggregateOutputType = {
    id: number | null
  }

  export type PreferencesSumAggregateOutputType = {
    id: number | null
  }

  export type PreferencesMinAggregateOutputType = {
    id: number | null
    user: string | null
  }

  export type PreferencesMaxAggregateOutputType = {
    id: number | null
    user: string | null
  }

  export type PreferencesCountAggregateOutputType = {
    id: number
    user: number
    _all: number
  }


  export type PreferencesAvgAggregateInputType = {
    id?: true
  }

  export type PreferencesSumAggregateInputType = {
    id?: true
  }

  export type PreferencesMinAggregateInputType = {
    id?: true
    user?: true
  }

  export type PreferencesMaxAggregateInputType = {
    id?: true
    user?: true
  }

  export type PreferencesCountAggregateInputType = {
    id?: true
    user?: true
    _all?: true
  }

  export type PreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Preferences to aggregate.
     */
    where?: PreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preferences to fetch.
     */
    orderBy?: PreferencesOrderByWithRelationInput | PreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Preferences
    **/
    _count?: true | PreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreferencesMaxAggregateInputType
  }

  export type GetPreferencesAggregateType<T extends PreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregatePreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreferences[P]>
      : GetScalarType<T[P], AggregatePreferences[P]>
  }




  export type PreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferencesWhereInput
    orderBy?: PreferencesOrderByWithAggregationInput | PreferencesOrderByWithAggregationInput[]
    by: PreferencesScalarFieldEnum[] | PreferencesScalarFieldEnum
    having?: PreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreferencesCountAggregateInputType | true
    _avg?: PreferencesAvgAggregateInputType
    _sum?: PreferencesSumAggregateInputType
    _min?: PreferencesMinAggregateInputType
    _max?: PreferencesMaxAggregateInputType
  }

  export type PreferencesGroupByOutputType = {
    id: number
    user: string | null
    _count: PreferencesCountAggregateOutputType | null
    _avg: PreferencesAvgAggregateOutputType | null
    _sum: PreferencesSumAggregateOutputType | null
    _min: PreferencesMinAggregateOutputType | null
    _max: PreferencesMaxAggregateOutputType | null
  }

  type GetPreferencesGroupByPayload<T extends PreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], PreferencesGroupByOutputType[P]>
        }
      >
    >


  export type PreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user?: boolean
    User?: boolean | Preferences$UserArgs<ExtArgs>
  }, ExtArgs["result"]["preferences"]>

  export type PreferencesSelectScalar = {
    id?: boolean
    user?: boolean
  }

  export type PreferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Preferences$UserArgs<ExtArgs>
  }


  export type $PreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Preferences"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user: string | null
    }, ExtArgs["result"]["preferences"]>
    composites: {}
  }


  type PreferencesGetPayload<S extends boolean | null | undefined | PreferencesDefaultArgs> = $Result.GetResult<Prisma.$PreferencesPayload, S>

  type PreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PreferencesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PreferencesCountAggregateInputType | true
    }

  export interface PreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Preferences'], meta: { name: 'Preferences' } }
    /**
     * Find zero or one Preferences that matches the filter.
     * @param {PreferencesFindUniqueArgs} args - Arguments to find a Preferences
     * @example
     * // Get one Preferences
     * const preferences = await prisma.preferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PreferencesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PreferencesFindUniqueArgs<ExtArgs>>
    ): Prisma__PreferencesClient<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Preferences that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PreferencesFindUniqueOrThrowArgs} args - Arguments to find a Preferences
     * @example
     * // Get one Preferences
     * const preferences = await prisma.preferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PreferencesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferencesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PreferencesClient<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesFindFirstArgs} args - Arguments to find a Preferences
     * @example
     * // Get one Preferences
     * const preferences = await prisma.preferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PreferencesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferencesFindFirstArgs<ExtArgs>>
    ): Prisma__PreferencesClient<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Preferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesFindFirstOrThrowArgs} args - Arguments to find a Preferences
     * @example
     * // Get one Preferences
     * const preferences = await prisma.preferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PreferencesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferencesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PreferencesClient<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Preferences
     * const preferences = await prisma.preferences.findMany()
     * 
     * // Get first 10 Preferences
     * const preferences = await prisma.preferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preferencesWithIdOnly = await prisma.preferences.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PreferencesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferencesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Preferences.
     * @param {PreferencesCreateArgs} args - Arguments to create a Preferences.
     * @example
     * // Create one Preferences
     * const Preferences = await prisma.preferences.create({
     *   data: {
     *     // ... data to create a Preferences
     *   }
     * })
     * 
    **/
    create<T extends PreferencesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PreferencesCreateArgs<ExtArgs>>
    ): Prisma__PreferencesClient<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Preferences.
     *     @param {PreferencesCreateManyArgs} args - Arguments to create many Preferences.
     *     @example
     *     // Create many Preferences
     *     const preferences = await prisma.preferences.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PreferencesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferencesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Preferences.
     * @param {PreferencesDeleteArgs} args - Arguments to delete one Preferences.
     * @example
     * // Delete one Preferences
     * const Preferences = await prisma.preferences.delete({
     *   where: {
     *     // ... filter to delete one Preferences
     *   }
     * })
     * 
    **/
    delete<T extends PreferencesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PreferencesDeleteArgs<ExtArgs>>
    ): Prisma__PreferencesClient<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Preferences.
     * @param {PreferencesUpdateArgs} args - Arguments to update one Preferences.
     * @example
     * // Update one Preferences
     * const preferences = await prisma.preferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PreferencesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PreferencesUpdateArgs<ExtArgs>>
    ): Prisma__PreferencesClient<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Preferences.
     * @param {PreferencesDeleteManyArgs} args - Arguments to filter Preferences to delete.
     * @example
     * // Delete a few Preferences
     * const { count } = await prisma.preferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PreferencesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferencesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Preferences
     * const preferences = await prisma.preferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PreferencesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PreferencesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Preferences.
     * @param {PreferencesUpsertArgs} args - Arguments to update or create a Preferences.
     * @example
     * // Update or create a Preferences
     * const preferences = await prisma.preferences.upsert({
     *   create: {
     *     // ... data to create a Preferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Preferences we want to update
     *   }
     * })
    **/
    upsert<T extends PreferencesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PreferencesUpsertArgs<ExtArgs>>
    ): Prisma__PreferencesClient<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesCountArgs} args - Arguments to filter Preferences to count.
     * @example
     * // Count the number of Preferences
     * const count = await prisma.preferences.count({
     *   where: {
     *     // ... the filter for the Preferences we want to count
     *   }
     * })
    **/
    count<T extends PreferencesCountArgs>(
      args?: Subset<T, PreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreferencesAggregateArgs>(args: Subset<T, PreferencesAggregateArgs>): Prisma.PrismaPromise<GetPreferencesAggregateType<T>>

    /**
     * Group by Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreferencesGroupByArgs['orderBy'] }
        : { orderBy?: PreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Preferences model
   */
  readonly fields: PreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Preferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    User<T extends Preferences$UserArgs<ExtArgs> = {}>(args?: Subset<T, Preferences$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Preferences model
   */ 
  interface PreferencesFieldRefs {
    readonly id: FieldRef<"Preferences", 'Int'>
    readonly user: FieldRef<"Preferences", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Preferences findUnique
   */
  export type PreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreferencesInclude<ExtArgs> | null
    /**
     * Filter, which Preferences to fetch.
     */
    where: PreferencesWhereUniqueInput
  }


  /**
   * Preferences findUniqueOrThrow
   */
  export type PreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreferencesInclude<ExtArgs> | null
    /**
     * Filter, which Preferences to fetch.
     */
    where: PreferencesWhereUniqueInput
  }


  /**
   * Preferences findFirst
   */
  export type PreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreferencesInclude<ExtArgs> | null
    /**
     * Filter, which Preferences to fetch.
     */
    where?: PreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preferences to fetch.
     */
    orderBy?: PreferencesOrderByWithRelationInput | PreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Preferences.
     */
    cursor?: PreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Preferences.
     */
    distinct?: PreferencesScalarFieldEnum | PreferencesScalarFieldEnum[]
  }


  /**
   * Preferences findFirstOrThrow
   */
  export type PreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreferencesInclude<ExtArgs> | null
    /**
     * Filter, which Preferences to fetch.
     */
    where?: PreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preferences to fetch.
     */
    orderBy?: PreferencesOrderByWithRelationInput | PreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Preferences.
     */
    cursor?: PreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Preferences.
     */
    distinct?: PreferencesScalarFieldEnum | PreferencesScalarFieldEnum[]
  }


  /**
   * Preferences findMany
   */
  export type PreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreferencesInclude<ExtArgs> | null
    /**
     * Filter, which Preferences to fetch.
     */
    where?: PreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preferences to fetch.
     */
    orderBy?: PreferencesOrderByWithRelationInput | PreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Preferences.
     */
    cursor?: PreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preferences.
     */
    skip?: number
    distinct?: PreferencesScalarFieldEnum | PreferencesScalarFieldEnum[]
  }


  /**
   * Preferences create
   */
  export type PreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a Preferences.
     */
    data?: XOR<PreferencesCreateInput, PreferencesUncheckedCreateInput>
  }


  /**
   * Preferences createMany
   */
  export type PreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Preferences.
     */
    data: PreferencesCreateManyInput | PreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Preferences update
   */
  export type PreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a Preferences.
     */
    data: XOR<PreferencesUpdateInput, PreferencesUncheckedUpdateInput>
    /**
     * Choose, which Preferences to update.
     */
    where: PreferencesWhereUniqueInput
  }


  /**
   * Preferences updateMany
   */
  export type PreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Preferences.
     */
    data: XOR<PreferencesUpdateManyMutationInput, PreferencesUncheckedUpdateManyInput>
    /**
     * Filter which Preferences to update
     */
    where?: PreferencesWhereInput
  }


  /**
   * Preferences upsert
   */
  export type PreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the Preferences to update in case it exists.
     */
    where: PreferencesWhereUniqueInput
    /**
     * In case the Preferences found by the `where` argument doesn't exist, create a new Preferences with this data.
     */
    create: XOR<PreferencesCreateInput, PreferencesUncheckedCreateInput>
    /**
     * In case the Preferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PreferencesUpdateInput, PreferencesUncheckedUpdateInput>
  }


  /**
   * Preferences delete
   */
  export type PreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreferencesInclude<ExtArgs> | null
    /**
     * Filter which Preferences to delete.
     */
    where: PreferencesWhereUniqueInput
  }


  /**
   * Preferences deleteMany
   */
  export type PreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Preferences to delete
     */
    where?: PreferencesWhereInput
  }


  /**
   * Preferences.User
   */
  export type Preferences$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Preferences without action
   */
  export type PreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreferencesInclude<ExtArgs> | null
  }



  /**
   * Model Relationship
   */

  export type AggregateRelationship = {
    _count: RelationshipCountAggregateOutputType | null
    _avg: RelationshipAvgAggregateOutputType | null
    _sum: RelationshipSumAggregateOutputType | null
    _min: RelationshipMinAggregateOutputType | null
    _max: RelationshipMaxAggregateOutputType | null
  }

  export type RelationshipAvgAggregateOutputType = {
    id: number | null
  }

  export type RelationshipSumAggregateOutputType = {
    id: number | null
  }

  export type RelationshipMinAggregateOutputType = {
    id: number | null
    follower: string | null
    following: string | null
  }

  export type RelationshipMaxAggregateOutputType = {
    id: number | null
    follower: string | null
    following: string | null
  }

  export type RelationshipCountAggregateOutputType = {
    id: number
    follower: number
    following: number
    _all: number
  }


  export type RelationshipAvgAggregateInputType = {
    id?: true
  }

  export type RelationshipSumAggregateInputType = {
    id?: true
  }

  export type RelationshipMinAggregateInputType = {
    id?: true
    follower?: true
    following?: true
  }

  export type RelationshipMaxAggregateInputType = {
    id?: true
    follower?: true
    following?: true
  }

  export type RelationshipCountAggregateInputType = {
    id?: true
    follower?: true
    following?: true
    _all?: true
  }

  export type RelationshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Relationship to aggregate.
     */
    where?: RelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relationships to fetch.
     */
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Relationships
    **/
    _count?: true | RelationshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelationshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelationshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelationshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelationshipMaxAggregateInputType
  }

  export type GetRelationshipAggregateType<T extends RelationshipAggregateArgs> = {
        [P in keyof T & keyof AggregateRelationship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelationship[P]>
      : GetScalarType<T[P], AggregateRelationship[P]>
  }




  export type RelationshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationshipWhereInput
    orderBy?: RelationshipOrderByWithAggregationInput | RelationshipOrderByWithAggregationInput[]
    by: RelationshipScalarFieldEnum[] | RelationshipScalarFieldEnum
    having?: RelationshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelationshipCountAggregateInputType | true
    _avg?: RelationshipAvgAggregateInputType
    _sum?: RelationshipSumAggregateInputType
    _min?: RelationshipMinAggregateInputType
    _max?: RelationshipMaxAggregateInputType
  }

  export type RelationshipGroupByOutputType = {
    id: number
    follower: string | null
    following: string | null
    _count: RelationshipCountAggregateOutputType | null
    _avg: RelationshipAvgAggregateOutputType | null
    _sum: RelationshipSumAggregateOutputType | null
    _min: RelationshipMinAggregateOutputType | null
    _max: RelationshipMaxAggregateOutputType | null
  }

  type GetRelationshipGroupByPayload<T extends RelationshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelationshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelationshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelationshipGroupByOutputType[P]>
            : GetScalarType<T[P], RelationshipGroupByOutputType[P]>
        }
      >
    >


  export type RelationshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    follower?: boolean
    following?: boolean
    User_Relationship_followerToUser?: boolean | Relationship$User_Relationship_followerToUserArgs<ExtArgs>
    User_Relationship_followingToUser?: boolean | Relationship$User_Relationship_followingToUserArgs<ExtArgs>
  }, ExtArgs["result"]["relationship"]>

  export type RelationshipSelectScalar = {
    id?: boolean
    follower?: boolean
    following?: boolean
  }

  export type RelationshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User_Relationship_followerToUser?: boolean | Relationship$User_Relationship_followerToUserArgs<ExtArgs>
    User_Relationship_followingToUser?: boolean | Relationship$User_Relationship_followingToUserArgs<ExtArgs>
  }


  export type $RelationshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Relationship"
    objects: {
      User_Relationship_followerToUser: Prisma.$UserPayload<ExtArgs> | null
      User_Relationship_followingToUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      follower: string | null
      following: string | null
    }, ExtArgs["result"]["relationship"]>
    composites: {}
  }


  type RelationshipGetPayload<S extends boolean | null | undefined | RelationshipDefaultArgs> = $Result.GetResult<Prisma.$RelationshipPayload, S>

  type RelationshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RelationshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RelationshipCountAggregateInputType | true
    }

  export interface RelationshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Relationship'], meta: { name: 'Relationship' } }
    /**
     * Find zero or one Relationship that matches the filter.
     * @param {RelationshipFindUniqueArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RelationshipFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RelationshipFindUniqueArgs<ExtArgs>>
    ): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Relationship that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RelationshipFindUniqueOrThrowArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RelationshipFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RelationshipFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Relationship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipFindFirstArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RelationshipFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RelationshipFindFirstArgs<ExtArgs>>
    ): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Relationship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipFindFirstOrThrowArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RelationshipFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RelationshipFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Relationships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Relationships
     * const relationships = await prisma.relationship.findMany()
     * 
     * // Get first 10 Relationships
     * const relationships = await prisma.relationship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relationshipWithIdOnly = await prisma.relationship.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RelationshipFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RelationshipFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Relationship.
     * @param {RelationshipCreateArgs} args - Arguments to create a Relationship.
     * @example
     * // Create one Relationship
     * const Relationship = await prisma.relationship.create({
     *   data: {
     *     // ... data to create a Relationship
     *   }
     * })
     * 
    **/
    create<T extends RelationshipCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RelationshipCreateArgs<ExtArgs>>
    ): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Relationships.
     *     @param {RelationshipCreateManyArgs} args - Arguments to create many Relationships.
     *     @example
     *     // Create many Relationships
     *     const relationship = await prisma.relationship.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RelationshipCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RelationshipCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Relationship.
     * @param {RelationshipDeleteArgs} args - Arguments to delete one Relationship.
     * @example
     * // Delete one Relationship
     * const Relationship = await prisma.relationship.delete({
     *   where: {
     *     // ... filter to delete one Relationship
     *   }
     * })
     * 
    **/
    delete<T extends RelationshipDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RelationshipDeleteArgs<ExtArgs>>
    ): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Relationship.
     * @param {RelationshipUpdateArgs} args - Arguments to update one Relationship.
     * @example
     * // Update one Relationship
     * const relationship = await prisma.relationship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RelationshipUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RelationshipUpdateArgs<ExtArgs>>
    ): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Relationships.
     * @param {RelationshipDeleteManyArgs} args - Arguments to filter Relationships to delete.
     * @example
     * // Delete a few Relationships
     * const { count } = await prisma.relationship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RelationshipDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RelationshipDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Relationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Relationships
     * const relationship = await prisma.relationship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RelationshipUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RelationshipUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Relationship.
     * @param {RelationshipUpsertArgs} args - Arguments to update or create a Relationship.
     * @example
     * // Update or create a Relationship
     * const relationship = await prisma.relationship.upsert({
     *   create: {
     *     // ... data to create a Relationship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Relationship we want to update
     *   }
     * })
    **/
    upsert<T extends RelationshipUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RelationshipUpsertArgs<ExtArgs>>
    ): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Relationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipCountArgs} args - Arguments to filter Relationships to count.
     * @example
     * // Count the number of Relationships
     * const count = await prisma.relationship.count({
     *   where: {
     *     // ... the filter for the Relationships we want to count
     *   }
     * })
    **/
    count<T extends RelationshipCountArgs>(
      args?: Subset<T, RelationshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelationshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Relationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelationshipAggregateArgs>(args: Subset<T, RelationshipAggregateArgs>): Prisma.PrismaPromise<GetRelationshipAggregateType<T>>

    /**
     * Group by Relationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelationshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelationshipGroupByArgs['orderBy'] }
        : { orderBy?: RelationshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelationshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelationshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Relationship model
   */
  readonly fields: RelationshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Relationship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelationshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    User_Relationship_followerToUser<T extends Relationship$User_Relationship_followerToUserArgs<ExtArgs> = {}>(args?: Subset<T, Relationship$User_Relationship_followerToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    User_Relationship_followingToUser<T extends Relationship$User_Relationship_followingToUserArgs<ExtArgs> = {}>(args?: Subset<T, Relationship$User_Relationship_followingToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Relationship model
   */ 
  interface RelationshipFieldRefs {
    readonly id: FieldRef<"Relationship", 'Int'>
    readonly follower: FieldRef<"Relationship", 'String'>
    readonly following: FieldRef<"Relationship", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Relationship findUnique
   */
  export type RelationshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * Filter, which Relationship to fetch.
     */
    where: RelationshipWhereUniqueInput
  }


  /**
   * Relationship findUniqueOrThrow
   */
  export type RelationshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * Filter, which Relationship to fetch.
     */
    where: RelationshipWhereUniqueInput
  }


  /**
   * Relationship findFirst
   */
  export type RelationshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * Filter, which Relationship to fetch.
     */
    where?: RelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relationships to fetch.
     */
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Relationships.
     */
    cursor?: RelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Relationships.
     */
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
  }


  /**
   * Relationship findFirstOrThrow
   */
  export type RelationshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * Filter, which Relationship to fetch.
     */
    where?: RelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relationships to fetch.
     */
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Relationships.
     */
    cursor?: RelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Relationships.
     */
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
  }


  /**
   * Relationship findMany
   */
  export type RelationshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * Filter, which Relationships to fetch.
     */
    where?: RelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relationships to fetch.
     */
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Relationships.
     */
    cursor?: RelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relationships.
     */
    skip?: number
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
  }


  /**
   * Relationship create
   */
  export type RelationshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Relationship.
     */
    data?: XOR<RelationshipCreateInput, RelationshipUncheckedCreateInput>
  }


  /**
   * Relationship createMany
   */
  export type RelationshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Relationships.
     */
    data: RelationshipCreateManyInput | RelationshipCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Relationship update
   */
  export type RelationshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Relationship.
     */
    data: XOR<RelationshipUpdateInput, RelationshipUncheckedUpdateInput>
    /**
     * Choose, which Relationship to update.
     */
    where: RelationshipWhereUniqueInput
  }


  /**
   * Relationship updateMany
   */
  export type RelationshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Relationships.
     */
    data: XOR<RelationshipUpdateManyMutationInput, RelationshipUncheckedUpdateManyInput>
    /**
     * Filter which Relationships to update
     */
    where?: RelationshipWhereInput
  }


  /**
   * Relationship upsert
   */
  export type RelationshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Relationship to update in case it exists.
     */
    where: RelationshipWhereUniqueInput
    /**
     * In case the Relationship found by the `where` argument doesn't exist, create a new Relationship with this data.
     */
    create: XOR<RelationshipCreateInput, RelationshipUncheckedCreateInput>
    /**
     * In case the Relationship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelationshipUpdateInput, RelationshipUncheckedUpdateInput>
  }


  /**
   * Relationship delete
   */
  export type RelationshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * Filter which Relationship to delete.
     */
    where: RelationshipWhereUniqueInput
  }


  /**
   * Relationship deleteMany
   */
  export type RelationshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Relationships to delete
     */
    where?: RelationshipWhereInput
  }


  /**
   * Relationship.User_Relationship_followerToUser
   */
  export type Relationship$User_Relationship_followerToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Relationship.User_Relationship_followingToUser
   */
  export type Relationship$User_Relationship_followingToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Relationship without action
   */
  export type RelationshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelationshipInclude<ExtArgs> | null
  }



  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    id: number | null
    post: number | null
    community: number | null
  }

  export type ReportSumAggregateOutputType = {
    id: number | null
    post: number | null
    community: number | null
  }

  export type ReportMinAggregateOutputType = {
    id: number | null
    reportedBy: string | null
    post: number | null
    community: number | null
    reportReason: string | null
    reportDate: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: number | null
    reportedBy: string | null
    post: number | null
    community: number | null
    reportReason: string | null
    reportDate: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    reportedBy: number
    post: number
    community: number
    reportReason: number
    reportDate: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    id?: true
    post?: true
    community?: true
  }

  export type ReportSumAggregateInputType = {
    id?: true
    post?: true
    community?: true
  }

  export type ReportMinAggregateInputType = {
    id?: true
    reportedBy?: true
    post?: true
    community?: true
    reportReason?: true
    reportDate?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    reportedBy?: true
    post?: true
    community?: true
    reportReason?: true
    reportDate?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    reportedBy?: true
    post?: true
    community?: true
    reportReason?: true
    reportDate?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: number
    reportedBy: string | null
    post: number | null
    community: number | null
    reportReason: string | null
    reportDate: Date | null
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportedBy?: boolean
    post?: boolean
    community?: boolean
    reportReason?: boolean
    reportDate?: boolean
    Community?: boolean | Report$CommunityArgs<ExtArgs>
    Post?: boolean | Report$PostArgs<ExtArgs>
    User?: boolean | Report$UserArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    reportedBy?: boolean
    post?: boolean
    community?: boolean
    reportReason?: boolean
    reportDate?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Community?: boolean | Report$CommunityArgs<ExtArgs>
    Post?: boolean | Report$PostArgs<ExtArgs>
    User?: boolean | Report$UserArgs<ExtArgs>
  }


  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      Community: Prisma.$CommunityPayload<ExtArgs> | null
      Post: Prisma.$PostPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reportedBy: string | null
      post: number | null
      community: number | null
      reportReason: string | null
      reportDate: Date | null
    }, ExtArgs["result"]["report"]>
    composites: {}
  }


  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
    **/
    create<T extends ReportCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportCreateArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reports.
     *     @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     *     @example
     *     // Create many Reports
     *     const report = await prisma.report.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReportCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
    **/
    delete<T extends ReportDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
    **/
    upsert<T extends ReportUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Community<T extends Report$CommunityArgs<ExtArgs> = {}>(args?: Subset<T, Report$CommunityArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Post<T extends Report$PostArgs<ExtArgs> = {}>(args?: Subset<T, Report$PostArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    User<T extends Report$UserArgs<ExtArgs> = {}>(args?: Subset<T, Report$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'Int'>
    readonly reportedBy: FieldRef<"Report", 'String'>
    readonly post: FieldRef<"Report", 'Int'>
    readonly community: FieldRef<"Report", 'Int'>
    readonly reportReason: FieldRef<"Report", 'String'>
    readonly reportDate: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data?: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }


  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }


  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }


  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }


  /**
   * Report.Community
   */
  export type Report$CommunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    where?: CommunityWhereInput
  }


  /**
   * Report.Post
   */
  export type Report$PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
  }


  /**
   * Report.User
   */
  export type Report$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
  }



  /**
   * Model Token
   */

  export type AggregateToken = {
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  export type TokenAvgAggregateOutputType = {
    id: number | null
  }

  export type TokenSumAggregateOutputType = {
    id: number | null
  }

  export type TokenMinAggregateOutputType = {
    id: number | null
    user: string | null
    refreshToken: string | null
    accessToken: string | null
    createdAt: Date | null
  }

  export type TokenMaxAggregateOutputType = {
    id: number | null
    user: string | null
    refreshToken: string | null
    accessToken: string | null
    createdAt: Date | null
  }

  export type TokenCountAggregateOutputType = {
    id: number
    user: number
    refreshToken: number
    accessToken: number
    createdAt: number
    _all: number
  }


  export type TokenAvgAggregateInputType = {
    id?: true
  }

  export type TokenSumAggregateInputType = {
    id?: true
  }

  export type TokenMinAggregateInputType = {
    id?: true
    user?: true
    refreshToken?: true
    accessToken?: true
    createdAt?: true
  }

  export type TokenMaxAggregateInputType = {
    id?: true
    user?: true
    refreshToken?: true
    accessToken?: true
    createdAt?: true
  }

  export type TokenCountAggregateInputType = {
    id?: true
    user?: true
    refreshToken?: true
    accessToken?: true
    createdAt?: true
    _all?: true
  }

  export type TokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Token to aggregate.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tokens
    **/
    _count?: true | TokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMaxAggregateInputType
  }

  export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
        [P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken[P]>
      : GetScalarType<T[P], AggregateToken[P]>
  }




  export type TokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithAggregationInput | TokenOrderByWithAggregationInput[]
    by: TokenScalarFieldEnum[] | TokenScalarFieldEnum
    having?: TokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenCountAggregateInputType | true
    _avg?: TokenAvgAggregateInputType
    _sum?: TokenSumAggregateInputType
    _min?: TokenMinAggregateInputType
    _max?: TokenMaxAggregateInputType
  }

  export type TokenGroupByOutputType = {
    id: number
    user: string | null
    refreshToken: string | null
    accessToken: string | null
    createdAt: Date | null
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  type GetTokenGroupByPayload<T extends TokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenGroupByOutputType[P]>
            : GetScalarType<T[P], TokenGroupByOutputType[P]>
        }
      >
    >


  export type TokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    createdAt?: boolean
    User?: boolean | Token$UserArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectScalar = {
    id?: boolean
    user?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    createdAt?: boolean
  }

  export type TokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Token$UserArgs<ExtArgs>
  }


  export type $TokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Token"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user: string | null
      refreshToken: string | null
      accessToken: string | null
      createdAt: Date | null
    }, ExtArgs["result"]["token"]>
    composites: {}
  }


  type TokenGetPayload<S extends boolean | null | undefined | TokenDefaultArgs> = $Result.GetResult<Prisma.$TokenPayload, S>

  type TokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TokenCountAggregateInputType | true
    }

  export interface TokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Token'], meta: { name: 'Token' } }
    /**
     * Find zero or one Token that matches the filter.
     * @param {TokenFindUniqueArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TokenFindUniqueArgs<ExtArgs>>
    ): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Token that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TokenFindUniqueOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TokenFindFirstArgs<ExtArgs>>
    ): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.token.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenWithIdOnly = await prisma.token.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Token.
     * @param {TokenCreateArgs} args - Arguments to create a Token.
     * @example
     * // Create one Token
     * const Token = await prisma.token.create({
     *   data: {
     *     // ... data to create a Token
     *   }
     * })
     * 
    **/
    create<T extends TokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TokenCreateArgs<ExtArgs>>
    ): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tokens.
     *     @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
     *     @example
     *     // Create many Tokens
     *     const token = await prisma.token.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Token.
     * @param {TokenDeleteArgs} args - Arguments to delete one Token.
     * @example
     * // Delete one Token
     * const Token = await prisma.token.delete({
     *   where: {
     *     // ... filter to delete one Token
     *   }
     * })
     * 
    **/
    delete<T extends TokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TokenDeleteArgs<ExtArgs>>
    ): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Token.
     * @param {TokenUpdateArgs} args - Arguments to update one Token.
     * @example
     * // Update one Token
     * const token = await prisma.token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TokenUpdateArgs<ExtArgs>>
    ): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tokens.
     * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Token.
     * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
     * @example
     * // Update or create a Token
     * const token = await prisma.token.upsert({
     *   create: {
     *     // ... data to create a Token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token we want to update
     *   }
     * })
    **/
    upsert<T extends TokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TokenUpsertArgs<ExtArgs>>
    ): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.token.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends TokenCountArgs>(
      args?: Subset<T, TokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): Prisma.PrismaPromise<GetTokenAggregateType<T>>

    /**
     * Group by Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenGroupByArgs['orderBy'] }
        : { orderBy?: TokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Token model
   */
  readonly fields: TokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    User<T extends Token$UserArgs<ExtArgs> = {}>(args?: Subset<T, Token$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Token model
   */ 
  interface TokenFieldRefs {
    readonly id: FieldRef<"Token", 'Int'>
    readonly user: FieldRef<"Token", 'String'>
    readonly refreshToken: FieldRef<"Token", 'String'>
    readonly accessToken: FieldRef<"Token", 'String'>
    readonly createdAt: FieldRef<"Token", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Token findUnique
   */
  export type TokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }


  /**
   * Token findUniqueOrThrow
   */
  export type TokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }


  /**
   * Token findFirst
   */
  export type TokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }


  /**
   * Token findFirstOrThrow
   */
  export type TokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }


  /**
   * Token findMany
   */
  export type TokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Tokens to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }


  /**
   * Token create
   */
  export type TokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to create a Token.
     */
    data?: XOR<TokenCreateInput, TokenUncheckedCreateInput>
  }


  /**
   * Token createMany
   */
  export type TokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Token update
   */
  export type TokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to update a Token.
     */
    data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    /**
     * Choose, which Token to update.
     */
    where: TokenWhereUniqueInput
  }


  /**
   * Token updateMany
   */
  export type TokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
  }


  /**
   * Token upsert
   */
  export type TokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The filter to search for the Token to update in case it exists.
     */
    where: TokenWhereUniqueInput
    /**
     * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
     */
    create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    /**
     * In case the Token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
  }


  /**
   * Token delete
   */
  export type TokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter which Token to delete.
     */
    where: TokenWhereUniqueInput
  }


  /**
   * Token deleteMany
   */
  export type TokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tokens to delete
     */
    where?: TokenWhereInput
  }


  /**
   * Token.User
   */
  export type Token$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Token without action
   */
  export type TokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
  }



  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    height: number | null
    weight: number | null
  }

  export type UserSumAggregateOutputType = {
    height: number | null
    weight: number | null
  }

  export type UserMinAggregateOutputType = {
    username: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    avatarUrl: string | null
    bio: string | null
    role: string | null
    createdAt: Date | null
    isEmailVerified: boolean | null
    height: number | null
    weight: number | null
  }

  export type UserMaxAggregateOutputType = {
    username: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    avatarUrl: string | null
    bio: string | null
    role: string | null
    createdAt: Date | null
    isEmailVerified: boolean | null
    height: number | null
    weight: number | null
  }

  export type UserCountAggregateOutputType = {
    username: number
    firstName: number
    lastName: number
    email: number
    password: number
    avatarUrl: number
    bio: number
    role: number
    createdAt: number
    isEmailVerified: number
    height: number
    weight: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    height?: true
    weight?: true
  }

  export type UserSumAggregateInputType = {
    height?: true
    weight?: true
  }

  export type UserMinAggregateInputType = {
    username?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    avatarUrl?: true
    bio?: true
    role?: true
    createdAt?: true
    isEmailVerified?: true
    height?: true
    weight?: true
  }

  export type UserMaxAggregateInputType = {
    username?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    avatarUrl?: true
    bio?: true
    role?: true
    createdAt?: true
    isEmailVerified?: true
    height?: true
    weight?: true
  }

  export type UserCountAggregateInputType = {
    username?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    avatarUrl?: true
    bio?: true
    role?: true
    createdAt?: true
    isEmailVerified?: true
    height?: true
    weight?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    username: string
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    avatarUrl: string | null
    bio: string | null
    role: string | null
    createdAt: Date | null
    isEmailVerified: boolean | null
    height: number | null
    weight: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    avatarUrl?: boolean
    bio?: boolean
    role?: boolean
    createdAt?: boolean
    isEmailVerified?: boolean
    height?: boolean
    weight?: boolean
    BannedUsers?: boolean | User$BannedUsersArgs<ExtArgs>
    CommunityRequest?: boolean | User$CommunityRequestArgs<ExtArgs>
    Context?: boolean | User$ContextArgs<ExtArgs>
    LeaderboardEntry?: boolean | User$LeaderboardEntryArgs<ExtArgs>
    PendingPost?: boolean | User$PendingPostArgs<ExtArgs>
    Post?: boolean | User$PostArgs<ExtArgs>
    Preferences?: boolean | User$PreferencesArgs<ExtArgs>
    Relationship_Relationship_followerToUser?: boolean | User$Relationship_Relationship_followerToUserArgs<ExtArgs>
    Relationship_Relationship_followingToUser?: boolean | User$Relationship_Relationship_followingToUserArgs<ExtArgs>
    Report?: boolean | User$ReportArgs<ExtArgs>
    Token?: boolean | User$TokenArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    avatarUrl?: boolean
    bio?: boolean
    role?: boolean
    createdAt?: boolean
    isEmailVerified?: boolean
    height?: boolean
    weight?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BannedUsers?: boolean | User$BannedUsersArgs<ExtArgs>
    CommunityRequest?: boolean | User$CommunityRequestArgs<ExtArgs>
    Context?: boolean | User$ContextArgs<ExtArgs>
    LeaderboardEntry?: boolean | User$LeaderboardEntryArgs<ExtArgs>
    PendingPost?: boolean | User$PendingPostArgs<ExtArgs>
    Post?: boolean | User$PostArgs<ExtArgs>
    Preferences?: boolean | User$PreferencesArgs<ExtArgs>
    Relationship_Relationship_followerToUser?: boolean | User$Relationship_Relationship_followerToUserArgs<ExtArgs>
    Relationship_Relationship_followingToUser?: boolean | User$Relationship_Relationship_followingToUserArgs<ExtArgs>
    Report?: boolean | User$ReportArgs<ExtArgs>
    Token?: boolean | User$TokenArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      BannedUsers: Prisma.$BannedUsersPayload<ExtArgs>[]
      CommunityRequest: Prisma.$CommunityRequestPayload<ExtArgs>[]
      Context: Prisma.$ContextPayload<ExtArgs>[]
      LeaderboardEntry: Prisma.$LeaderboardEntryPayload<ExtArgs>[]
      PendingPost: Prisma.$PendingPostPayload<ExtArgs>[]
      Post: Prisma.$PostPayload<ExtArgs>[]
      Preferences: Prisma.$PreferencesPayload<ExtArgs>[]
      Relationship_Relationship_followerToUser: Prisma.$RelationshipPayload<ExtArgs>[]
      Relationship_Relationship_followingToUser: Prisma.$RelationshipPayload<ExtArgs>[]
      Report: Prisma.$ReportPayload<ExtArgs>[]
      Token: Prisma.$TokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      username: string
      firstName: string | null
      lastName: string | null
      email: string | null
      password: string | null
      avatarUrl: string | null
      bio: string | null
      role: string | null
      createdAt: Date | null
      isEmailVerified: boolean | null
      height: number | null
      weight: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const userWithUsernameOnly = await prisma.user.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    BannedUsers<T extends User$BannedUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$BannedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'findMany'> | Null>;

    CommunityRequest<T extends User$CommunityRequestArgs<ExtArgs> = {}>(args?: Subset<T, User$CommunityRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'findMany'> | Null>;

    Context<T extends User$ContextArgs<ExtArgs> = {}>(args?: Subset<T, User$ContextArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'findMany'> | Null>;

    LeaderboardEntry<T extends User$LeaderboardEntryArgs<ExtArgs> = {}>(args?: Subset<T, User$LeaderboardEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, 'findMany'> | Null>;

    PendingPost<T extends User$PendingPostArgs<ExtArgs> = {}>(args?: Subset<T, User$PendingPostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'findMany'> | Null>;

    Post<T extends User$PostArgs<ExtArgs> = {}>(args?: Subset<T, User$PostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findMany'> | Null>;

    Preferences<T extends User$PreferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$PreferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'findMany'> | Null>;

    Relationship_Relationship_followerToUser<T extends User$Relationship_Relationship_followerToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Relationship_Relationship_followerToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'findMany'> | Null>;

    Relationship_Relationship_followingToUser<T extends User$Relationship_Relationship_followingToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Relationship_Relationship_followingToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'findMany'> | Null>;

    Report<T extends User$ReportArgs<ExtArgs> = {}>(args?: Subset<T, User$ReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findMany'> | Null>;

    Token<T extends User$TokenArgs<ExtArgs> = {}>(args?: Subset<T, User$TokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly username: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly isEmailVerified: FieldRef<"User", 'Boolean'>
    readonly height: FieldRef<"User", 'Float'>
    readonly weight: FieldRef<"User", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.BannedUsers
   */
  export type User$BannedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    where?: BannedUsersWhereInput
    orderBy?: BannedUsersOrderByWithRelationInput | BannedUsersOrderByWithRelationInput[]
    cursor?: BannedUsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannedUsersScalarFieldEnum | BannedUsersScalarFieldEnum[]
  }


  /**
   * User.CommunityRequest
   */
  export type User$CommunityRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    where?: CommunityRequestWhereInput
    orderBy?: CommunityRequestOrderByWithRelationInput | CommunityRequestOrderByWithRelationInput[]
    cursor?: CommunityRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityRequestScalarFieldEnum | CommunityRequestScalarFieldEnum[]
  }


  /**
   * User.Context
   */
  export type User$ContextArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextInclude<ExtArgs> | null
    where?: ContextWhereInput
    orderBy?: ContextOrderByWithRelationInput | ContextOrderByWithRelationInput[]
    cursor?: ContextWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContextScalarFieldEnum | ContextScalarFieldEnum[]
  }


  /**
   * User.LeaderboardEntry
   */
  export type User$LeaderboardEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    where?: LeaderboardEntryWhereInput
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    cursor?: LeaderboardEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }


  /**
   * User.PendingPost
   */
  export type User$PendingPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    where?: PendingPostWhereInput
    orderBy?: PendingPostOrderByWithRelationInput | PendingPostOrderByWithRelationInput[]
    cursor?: PendingPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendingPostScalarFieldEnum | PendingPostScalarFieldEnum[]
  }


  /**
   * User.Post
   */
  export type User$PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }


  /**
   * User.Preferences
   */
  export type User$PreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PreferencesInclude<ExtArgs> | null
    where?: PreferencesWhereInput
    orderBy?: PreferencesOrderByWithRelationInput | PreferencesOrderByWithRelationInput[]
    cursor?: PreferencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreferencesScalarFieldEnum | PreferencesScalarFieldEnum[]
  }


  /**
   * User.Relationship_Relationship_followerToUser
   */
  export type User$Relationship_Relationship_followerToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelationshipInclude<ExtArgs> | null
    where?: RelationshipWhereInput
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    cursor?: RelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
  }


  /**
   * User.Relationship_Relationship_followingToUser
   */
  export type User$Relationship_Relationship_followingToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelationshipInclude<ExtArgs> | null
    where?: RelationshipWhereInput
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    cursor?: RelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
  }


  /**
   * User.Report
   */
  export type User$ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * User.Token
   */
  export type User$TokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    cursor?: TokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const AdminTokenScalarFieldEnum: {
    id: 'id',
    user: 'user',
    accessToken: 'accessToken'
  };

  export type AdminTokenScalarFieldEnum = (typeof AdminTokenScalarFieldEnum)[keyof typeof AdminTokenScalarFieldEnum]


  export const BannedUsersScalarFieldEnum: {
    id: 'id',
    community: 'community',
    user: 'user'
  };

  export type BannedUsersScalarFieldEnum = (typeof BannedUsersScalarFieldEnum)[keyof typeof BannedUsersScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    body: 'body',
    user: 'user',
    post: 'post'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const CommunityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type CommunityScalarFieldEnum = (typeof CommunityScalarFieldEnum)[keyof typeof CommunityScalarFieldEnum]


  export const CommunityRequestScalarFieldEnum: {
    id: 'id',
    user: 'user',
    community: 'community',
    isVerified: 'isVerified',
    isRequested: 'isRequested'
  };

  export type CommunityRequestScalarFieldEnum = (typeof CommunityRequestScalarFieldEnum)[keyof typeof CommunityRequestScalarFieldEnum]


  export const ContextScalarFieldEnum: {
    id: 'id',
    user: 'user',
    email: 'email',
    ip: 'ip',
    country: 'country',
    city: 'city',
    browser: 'browser',
    platform: 'platform',
    os: 'os',
    device: 'device',
    deviceType: 'deviceType',
    isTrusted: 'isTrusted'
  };

  export type ContextScalarFieldEnum = (typeof ContextScalarFieldEnum)[keyof typeof ContextScalarFieldEnum]


  export const LeaderboardScalarFieldEnum: {
    id: 'id',
    community: 'community',
    tracking: 'tracking'
  };

  export type LeaderboardScalarFieldEnum = (typeof LeaderboardScalarFieldEnum)[keyof typeof LeaderboardScalarFieldEnum]


  export const LeaderboardEntryScalarFieldEnum: {
    id: 'id',
    user: 'user',
    community: 'community',
    entryUrl: 'entryUrl',
    verifiedBy: 'verifiedBy',
    isVerified: 'isVerified',
    rank: 'rank'
  };

  export type LeaderboardEntryScalarFieldEnum = (typeof LeaderboardEntryScalarFieldEnum)[keyof typeof LeaderboardEntryScalarFieldEnum]


  export const LikeScalarFieldEnum: {
    id: 'id',
    user: 'user',
    post: 'post'
  };

  export type LikeScalarFieldEnum = (typeof LikeScalarFieldEnum)[keyof typeof LikeScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    email: 'email',
    context: 'context',
    message: 'message',
    type: 'type',
    level: 'level',
    timestamp: 'timestamp'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const PendingPostScalarFieldEnum: {
    id: 'id',
    Content: 'Content',
    fileUrl: 'fileUrl',
    community: 'community',
    user: 'user',
    caption: 'caption',
    status: 'status',
    confirmationToken: 'confirmationToken'
  };

  export type PendingPostScalarFieldEnum = (typeof PendingPostScalarFieldEnum)[keyof typeof PendingPostScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    Content: 'Content',
    fileUrl: 'fileUrl',
    community: 'community',
    user: 'user',
    caption: 'caption'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const PreferencesScalarFieldEnum: {
    id: 'id',
    user: 'user'
  };

  export type PreferencesScalarFieldEnum = (typeof PreferencesScalarFieldEnum)[keyof typeof PreferencesScalarFieldEnum]


  export const RelationshipScalarFieldEnum: {
    id: 'id',
    follower: 'follower',
    following: 'following'
  };

  export type RelationshipScalarFieldEnum = (typeof RelationshipScalarFieldEnum)[keyof typeof RelationshipScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    reportedBy: 'reportedBy',
    post: 'post',
    community: 'community',
    reportReason: 'reportReason',
    reportDate: 'reportDate'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const TokenScalarFieldEnum: {
    id: 'id',
    user: 'user',
    refreshToken: 'refreshToken',
    accessToken: 'accessToken',
    createdAt: 'createdAt'
  };

  export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


  export const UserScalarFieldEnum: {
    username: 'username',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    password: 'password',
    avatarUrl: 'avatarUrl',
    bio: 'bio',
    role: 'role',
    createdAt: 'createdAt',
    isEmailVerified: 'isEmailVerified',
    height: 'height',
    weight: 'weight'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    username?: StringNullableFilter<"Admin"> | string | null
    password?: StringNullableFilter<"Admin"> | string | null
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    username?: StringNullableFilter<"Admin"> | string | null
    password?: StringNullableFilter<"Admin"> | string | null
  }, "id">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    username?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    password?: StringNullableWithAggregatesFilter<"Admin"> | string | null
  }

  export type AdminTokenWhereInput = {
    AND?: AdminTokenWhereInput | AdminTokenWhereInput[]
    OR?: AdminTokenWhereInput[]
    NOT?: AdminTokenWhereInput | AdminTokenWhereInput[]
    id?: IntFilter<"AdminToken"> | number
    user?: StringNullableFilter<"AdminToken"> | string | null
    accessToken?: StringNullableFilter<"AdminToken"> | string | null
  }

  export type AdminTokenOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
  }

  export type AdminTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdminTokenWhereInput | AdminTokenWhereInput[]
    OR?: AdminTokenWhereInput[]
    NOT?: AdminTokenWhereInput | AdminTokenWhereInput[]
    user?: StringNullableFilter<"AdminToken"> | string | null
    accessToken?: StringNullableFilter<"AdminToken"> | string | null
  }, "id">

  export type AdminTokenOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    _count?: AdminTokenCountOrderByAggregateInput
    _avg?: AdminTokenAvgOrderByAggregateInput
    _max?: AdminTokenMaxOrderByAggregateInput
    _min?: AdminTokenMinOrderByAggregateInput
    _sum?: AdminTokenSumOrderByAggregateInput
  }

  export type AdminTokenScalarWhereWithAggregatesInput = {
    AND?: AdminTokenScalarWhereWithAggregatesInput | AdminTokenScalarWhereWithAggregatesInput[]
    OR?: AdminTokenScalarWhereWithAggregatesInput[]
    NOT?: AdminTokenScalarWhereWithAggregatesInput | AdminTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AdminToken"> | number
    user?: StringNullableWithAggregatesFilter<"AdminToken"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"AdminToken"> | string | null
  }

  export type BannedUsersWhereInput = {
    AND?: BannedUsersWhereInput | BannedUsersWhereInput[]
    OR?: BannedUsersWhereInput[]
    NOT?: BannedUsersWhereInput | BannedUsersWhereInput[]
    id?: IntFilter<"BannedUsers"> | number
    community?: IntFilter<"BannedUsers"> | number
    user?: StringFilter<"BannedUsers"> | string
    Community?: XOR<CommunityRelationFilter, CommunityWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BannedUsersOrderByWithRelationInput = {
    id?: SortOrder
    community?: SortOrder
    user?: SortOrder
    Community?: CommunityOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type BannedUsersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BannedUsersWhereInput | BannedUsersWhereInput[]
    OR?: BannedUsersWhereInput[]
    NOT?: BannedUsersWhereInput | BannedUsersWhereInput[]
    community?: IntFilter<"BannedUsers"> | number
    user?: StringFilter<"BannedUsers"> | string
    Community?: XOR<CommunityRelationFilter, CommunityWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type BannedUsersOrderByWithAggregationInput = {
    id?: SortOrder
    community?: SortOrder
    user?: SortOrder
    _count?: BannedUsersCountOrderByAggregateInput
    _avg?: BannedUsersAvgOrderByAggregateInput
    _max?: BannedUsersMaxOrderByAggregateInput
    _min?: BannedUsersMinOrderByAggregateInput
    _sum?: BannedUsersSumOrderByAggregateInput
  }

  export type BannedUsersScalarWhereWithAggregatesInput = {
    AND?: BannedUsersScalarWhereWithAggregatesInput | BannedUsersScalarWhereWithAggregatesInput[]
    OR?: BannedUsersScalarWhereWithAggregatesInput[]
    NOT?: BannedUsersScalarWhereWithAggregatesInput | BannedUsersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BannedUsers"> | number
    community?: IntWithAggregatesFilter<"BannedUsers"> | number
    user?: StringWithAggregatesFilter<"BannedUsers"> | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    body?: StringNullableFilter<"Comment"> | string | null
    user?: StringNullableFilter<"Comment"> | string | null
    post?: IntNullableFilter<"Comment"> | number | null
    Post?: XOR<PostNullableRelationFilter, PostWhereInput> | null
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    body?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    post?: SortOrderInput | SortOrder
    Post?: PostOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    body?: StringNullableFilter<"Comment"> | string | null
    user?: StringNullableFilter<"Comment"> | string | null
    post?: IntNullableFilter<"Comment"> | number | null
    Post?: XOR<PostNullableRelationFilter, PostWhereInput> | null
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    body?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    post?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    body?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    user?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    post?: IntNullableWithAggregatesFilter<"Comment"> | number | null
  }

  export type CommunityWhereInput = {
    AND?: CommunityWhereInput | CommunityWhereInput[]
    OR?: CommunityWhereInput[]
    NOT?: CommunityWhereInput | CommunityWhereInput[]
    id?: IntFilter<"Community"> | number
    name?: StringNullableFilter<"Community"> | string | null
    description?: StringNullableFilter<"Community"> | string | null
    BannedUsers?: BannedUsersListRelationFilter
    CommunityRequest?: CommunityRequestListRelationFilter
    Leaderboard?: LeaderboardListRelationFilter
    LeaderboardEntry?: LeaderboardEntryListRelationFilter
    PendingPost?: PendingPostListRelationFilter
    Post?: PostListRelationFilter
    Report?: ReportListRelationFilter
  }

  export type CommunityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    BannedUsers?: BannedUsersOrderByRelationAggregateInput
    CommunityRequest?: CommunityRequestOrderByRelationAggregateInput
    Leaderboard?: LeaderboardOrderByRelationAggregateInput
    LeaderboardEntry?: LeaderboardEntryOrderByRelationAggregateInput
    PendingPost?: PendingPostOrderByRelationAggregateInput
    Post?: PostOrderByRelationAggregateInput
    Report?: ReportOrderByRelationAggregateInput
  }

  export type CommunityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommunityWhereInput | CommunityWhereInput[]
    OR?: CommunityWhereInput[]
    NOT?: CommunityWhereInput | CommunityWhereInput[]
    name?: StringNullableFilter<"Community"> | string | null
    description?: StringNullableFilter<"Community"> | string | null
    BannedUsers?: BannedUsersListRelationFilter
    CommunityRequest?: CommunityRequestListRelationFilter
    Leaderboard?: LeaderboardListRelationFilter
    LeaderboardEntry?: LeaderboardEntryListRelationFilter
    PendingPost?: PendingPostListRelationFilter
    Post?: PostListRelationFilter
    Report?: ReportListRelationFilter
  }, "id">

  export type CommunityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: CommunityCountOrderByAggregateInput
    _avg?: CommunityAvgOrderByAggregateInput
    _max?: CommunityMaxOrderByAggregateInput
    _min?: CommunityMinOrderByAggregateInput
    _sum?: CommunitySumOrderByAggregateInput
  }

  export type CommunityScalarWhereWithAggregatesInput = {
    AND?: CommunityScalarWhereWithAggregatesInput | CommunityScalarWhereWithAggregatesInput[]
    OR?: CommunityScalarWhereWithAggregatesInput[]
    NOT?: CommunityScalarWhereWithAggregatesInput | CommunityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Community"> | number
    name?: StringNullableWithAggregatesFilter<"Community"> | string | null
    description?: StringNullableWithAggregatesFilter<"Community"> | string | null
  }

  export type CommunityRequestWhereInput = {
    AND?: CommunityRequestWhereInput | CommunityRequestWhereInput[]
    OR?: CommunityRequestWhereInput[]
    NOT?: CommunityRequestWhereInput | CommunityRequestWhereInput[]
    id?: IntFilter<"CommunityRequest"> | number
    user?: StringNullableFilter<"CommunityRequest"> | string | null
    community?: IntNullableFilter<"CommunityRequest"> | number | null
    isVerified?: BoolNullableFilter<"CommunityRequest"> | boolean | null
    isRequested?: BoolNullableFilter<"CommunityRequest"> | boolean | null
    Community?: XOR<CommunityNullableRelationFilter, CommunityWhereInput> | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type CommunityRequestOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    community?: SortOrderInput | SortOrder
    isVerified?: SortOrderInput | SortOrder
    isRequested?: SortOrderInput | SortOrder
    Community?: CommunityOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type CommunityRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommunityRequestWhereInput | CommunityRequestWhereInput[]
    OR?: CommunityRequestWhereInput[]
    NOT?: CommunityRequestWhereInput | CommunityRequestWhereInput[]
    user?: StringNullableFilter<"CommunityRequest"> | string | null
    community?: IntNullableFilter<"CommunityRequest"> | number | null
    isVerified?: BoolNullableFilter<"CommunityRequest"> | boolean | null
    isRequested?: BoolNullableFilter<"CommunityRequest"> | boolean | null
    Community?: XOR<CommunityNullableRelationFilter, CommunityWhereInput> | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type CommunityRequestOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    community?: SortOrderInput | SortOrder
    isVerified?: SortOrderInput | SortOrder
    isRequested?: SortOrderInput | SortOrder
    _count?: CommunityRequestCountOrderByAggregateInput
    _avg?: CommunityRequestAvgOrderByAggregateInput
    _max?: CommunityRequestMaxOrderByAggregateInput
    _min?: CommunityRequestMinOrderByAggregateInput
    _sum?: CommunityRequestSumOrderByAggregateInput
  }

  export type CommunityRequestScalarWhereWithAggregatesInput = {
    AND?: CommunityRequestScalarWhereWithAggregatesInput | CommunityRequestScalarWhereWithAggregatesInput[]
    OR?: CommunityRequestScalarWhereWithAggregatesInput[]
    NOT?: CommunityRequestScalarWhereWithAggregatesInput | CommunityRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CommunityRequest"> | number
    user?: StringNullableWithAggregatesFilter<"CommunityRequest"> | string | null
    community?: IntNullableWithAggregatesFilter<"CommunityRequest"> | number | null
    isVerified?: BoolNullableWithAggregatesFilter<"CommunityRequest"> | boolean | null
    isRequested?: BoolNullableWithAggregatesFilter<"CommunityRequest"> | boolean | null
  }

  export type ContextWhereInput = {
    AND?: ContextWhereInput | ContextWhereInput[]
    OR?: ContextWhereInput[]
    NOT?: ContextWhereInput | ContextWhereInput[]
    id?: IntFilter<"Context"> | number
    user?: StringNullableFilter<"Context"> | string | null
    email?: StringNullableFilter<"Context"> | string | null
    ip?: StringNullableFilter<"Context"> | string | null
    country?: StringNullableFilter<"Context"> | string | null
    city?: StringNullableFilter<"Context"> | string | null
    browser?: StringNullableFilter<"Context"> | string | null
    platform?: StringNullableFilter<"Context"> | string | null
    os?: StringNullableFilter<"Context"> | string | null
    device?: StringNullableFilter<"Context"> | string | null
    deviceType?: StringNullableFilter<"Context"> | string | null
    isTrusted?: BoolNullableFilter<"Context"> | boolean | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ContextOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    isTrusted?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type ContextWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContextWhereInput | ContextWhereInput[]
    OR?: ContextWhereInput[]
    NOT?: ContextWhereInput | ContextWhereInput[]
    user?: StringNullableFilter<"Context"> | string | null
    email?: StringNullableFilter<"Context"> | string | null
    ip?: StringNullableFilter<"Context"> | string | null
    country?: StringNullableFilter<"Context"> | string | null
    city?: StringNullableFilter<"Context"> | string | null
    browser?: StringNullableFilter<"Context"> | string | null
    platform?: StringNullableFilter<"Context"> | string | null
    os?: StringNullableFilter<"Context"> | string | null
    device?: StringNullableFilter<"Context"> | string | null
    deviceType?: StringNullableFilter<"Context"> | string | null
    isTrusted?: BoolNullableFilter<"Context"> | boolean | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ContextOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    isTrusted?: SortOrderInput | SortOrder
    _count?: ContextCountOrderByAggregateInput
    _avg?: ContextAvgOrderByAggregateInput
    _max?: ContextMaxOrderByAggregateInput
    _min?: ContextMinOrderByAggregateInput
    _sum?: ContextSumOrderByAggregateInput
  }

  export type ContextScalarWhereWithAggregatesInput = {
    AND?: ContextScalarWhereWithAggregatesInput | ContextScalarWhereWithAggregatesInput[]
    OR?: ContextScalarWhereWithAggregatesInput[]
    NOT?: ContextScalarWhereWithAggregatesInput | ContextScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Context"> | number
    user?: StringNullableWithAggregatesFilter<"Context"> | string | null
    email?: StringNullableWithAggregatesFilter<"Context"> | string | null
    ip?: StringNullableWithAggregatesFilter<"Context"> | string | null
    country?: StringNullableWithAggregatesFilter<"Context"> | string | null
    city?: StringNullableWithAggregatesFilter<"Context"> | string | null
    browser?: StringNullableWithAggregatesFilter<"Context"> | string | null
    platform?: StringNullableWithAggregatesFilter<"Context"> | string | null
    os?: StringNullableWithAggregatesFilter<"Context"> | string | null
    device?: StringNullableWithAggregatesFilter<"Context"> | string | null
    deviceType?: StringNullableWithAggregatesFilter<"Context"> | string | null
    isTrusted?: BoolNullableWithAggregatesFilter<"Context"> | boolean | null
  }

  export type LeaderboardWhereInput = {
    AND?: LeaderboardWhereInput | LeaderboardWhereInput[]
    OR?: LeaderboardWhereInput[]
    NOT?: LeaderboardWhereInput | LeaderboardWhereInput[]
    id?: IntFilter<"Leaderboard"> | number
    community?: IntFilter<"Leaderboard"> | number
    tracking?: StringNullableFilter<"Leaderboard"> | string | null
    Community?: XOR<CommunityRelationFilter, CommunityWhereInput>
  }

  export type LeaderboardOrderByWithRelationInput = {
    id?: SortOrder
    community?: SortOrder
    tracking?: SortOrderInput | SortOrder
    Community?: CommunityOrderByWithRelationInput
  }

  export type LeaderboardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LeaderboardWhereInput | LeaderboardWhereInput[]
    OR?: LeaderboardWhereInput[]
    NOT?: LeaderboardWhereInput | LeaderboardWhereInput[]
    community?: IntFilter<"Leaderboard"> | number
    tracking?: StringNullableFilter<"Leaderboard"> | string | null
    Community?: XOR<CommunityRelationFilter, CommunityWhereInput>
  }, "id">

  export type LeaderboardOrderByWithAggregationInput = {
    id?: SortOrder
    community?: SortOrder
    tracking?: SortOrderInput | SortOrder
    _count?: LeaderboardCountOrderByAggregateInput
    _avg?: LeaderboardAvgOrderByAggregateInput
    _max?: LeaderboardMaxOrderByAggregateInput
    _min?: LeaderboardMinOrderByAggregateInput
    _sum?: LeaderboardSumOrderByAggregateInput
  }

  export type LeaderboardScalarWhereWithAggregatesInput = {
    AND?: LeaderboardScalarWhereWithAggregatesInput | LeaderboardScalarWhereWithAggregatesInput[]
    OR?: LeaderboardScalarWhereWithAggregatesInput[]
    NOT?: LeaderboardScalarWhereWithAggregatesInput | LeaderboardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Leaderboard"> | number
    community?: IntWithAggregatesFilter<"Leaderboard"> | number
    tracking?: StringNullableWithAggregatesFilter<"Leaderboard"> | string | null
  }

  export type LeaderboardEntryWhereInput = {
    AND?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    OR?: LeaderboardEntryWhereInput[]
    NOT?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    id?: IntFilter<"LeaderboardEntry"> | number
    user?: StringNullableFilter<"LeaderboardEntry"> | string | null
    community?: IntNullableFilter<"LeaderboardEntry"> | number | null
    entryUrl?: StringNullableFilter<"LeaderboardEntry"> | string | null
    verifiedBy?: IntNullableFilter<"LeaderboardEntry"> | number | null
    isVerified?: BoolNullableFilter<"LeaderboardEntry"> | boolean | null
    rank?: IntNullableFilter<"LeaderboardEntry"> | number | null
    Community?: XOR<CommunityNullableRelationFilter, CommunityWhereInput> | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type LeaderboardEntryOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    community?: SortOrderInput | SortOrder
    entryUrl?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    isVerified?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    Community?: CommunityOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type LeaderboardEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    OR?: LeaderboardEntryWhereInput[]
    NOT?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    user?: StringNullableFilter<"LeaderboardEntry"> | string | null
    community?: IntNullableFilter<"LeaderboardEntry"> | number | null
    entryUrl?: StringNullableFilter<"LeaderboardEntry"> | string | null
    verifiedBy?: IntNullableFilter<"LeaderboardEntry"> | number | null
    isVerified?: BoolNullableFilter<"LeaderboardEntry"> | boolean | null
    rank?: IntNullableFilter<"LeaderboardEntry"> | number | null
    Community?: XOR<CommunityNullableRelationFilter, CommunityWhereInput> | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type LeaderboardEntryOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    community?: SortOrderInput | SortOrder
    entryUrl?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    isVerified?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    _count?: LeaderboardEntryCountOrderByAggregateInput
    _avg?: LeaderboardEntryAvgOrderByAggregateInput
    _max?: LeaderboardEntryMaxOrderByAggregateInput
    _min?: LeaderboardEntryMinOrderByAggregateInput
    _sum?: LeaderboardEntrySumOrderByAggregateInput
  }

  export type LeaderboardEntryScalarWhereWithAggregatesInput = {
    AND?: LeaderboardEntryScalarWhereWithAggregatesInput | LeaderboardEntryScalarWhereWithAggregatesInput[]
    OR?: LeaderboardEntryScalarWhereWithAggregatesInput[]
    NOT?: LeaderboardEntryScalarWhereWithAggregatesInput | LeaderboardEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LeaderboardEntry"> | number
    user?: StringNullableWithAggregatesFilter<"LeaderboardEntry"> | string | null
    community?: IntNullableWithAggregatesFilter<"LeaderboardEntry"> | number | null
    entryUrl?: StringNullableWithAggregatesFilter<"LeaderboardEntry"> | string | null
    verifiedBy?: IntNullableWithAggregatesFilter<"LeaderboardEntry"> | number | null
    isVerified?: BoolNullableWithAggregatesFilter<"LeaderboardEntry"> | boolean | null
    rank?: IntNullableWithAggregatesFilter<"LeaderboardEntry"> | number | null
  }

  export type LikeWhereInput = {
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    id?: IntFilter<"Like"> | number
    user?: StringNullableFilter<"Like"> | string | null
    post?: IntNullableFilter<"Like"> | number | null
  }

  export type LikeOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    post?: SortOrderInput | SortOrder
  }

  export type LikeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    user?: StringNullableFilter<"Like"> | string | null
    post?: IntNullableFilter<"Like"> | number | null
  }, "id">

  export type LikeOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    post?: SortOrderInput | SortOrder
    _count?: LikeCountOrderByAggregateInput
    _avg?: LikeAvgOrderByAggregateInput
    _max?: LikeMaxOrderByAggregateInput
    _min?: LikeMinOrderByAggregateInput
    _sum?: LikeSumOrderByAggregateInput
  }

  export type LikeScalarWhereWithAggregatesInput = {
    AND?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    OR?: LikeScalarWhereWithAggregatesInput[]
    NOT?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Like"> | number
    user?: StringNullableWithAggregatesFilter<"Like"> | string | null
    post?: IntNullableWithAggregatesFilter<"Like"> | number | null
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    id?: IntFilter<"Log"> | number
    email?: StringNullableFilter<"Log"> | string | null
    context?: StringNullableFilter<"Log"> | string | null
    message?: StringNullableFilter<"Log"> | string | null
    type?: StringNullableFilter<"Log"> | string | null
    level?: StringNullableFilter<"Log"> | string | null
    timestamp?: DateTimeNullableFilter<"Log"> | Date | string | null
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    context?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    email?: StringNullableFilter<"Log"> | string | null
    context?: StringNullableFilter<"Log"> | string | null
    message?: StringNullableFilter<"Log"> | string | null
    type?: StringNullableFilter<"Log"> | string | null
    level?: StringNullableFilter<"Log"> | string | null
    timestamp?: DateTimeNullableFilter<"Log"> | Date | string | null
  }, "id">

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    context?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    _count?: LogCountOrderByAggregateInput
    _avg?: LogAvgOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
    _sum?: LogSumOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Log"> | number
    email?: StringNullableWithAggregatesFilter<"Log"> | string | null
    context?: StringNullableWithAggregatesFilter<"Log"> | string | null
    message?: StringNullableWithAggregatesFilter<"Log"> | string | null
    type?: StringNullableWithAggregatesFilter<"Log"> | string | null
    level?: StringNullableWithAggregatesFilter<"Log"> | string | null
    timestamp?: DateTimeNullableWithAggregatesFilter<"Log"> | Date | string | null
  }

  export type PendingPostWhereInput = {
    AND?: PendingPostWhereInput | PendingPostWhereInput[]
    OR?: PendingPostWhereInput[]
    NOT?: PendingPostWhereInput | PendingPostWhereInput[]
    id?: IntFilter<"PendingPost"> | number
    Content?: StringNullableFilter<"PendingPost"> | string | null
    fileUrl?: StringNullableFilter<"PendingPost"> | string | null
    community?: IntNullableFilter<"PendingPost"> | number | null
    user?: StringNullableFilter<"PendingPost"> | string | null
    caption?: StringNullableFilter<"PendingPost"> | string | null
    status?: StringNullableFilter<"PendingPost"> | string | null
    confirmationToken?: StringNullableFilter<"PendingPost"> | string | null
    Community?: XOR<CommunityNullableRelationFilter, CommunityWhereInput> | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type PendingPostOrderByWithRelationInput = {
    id?: SortOrder
    Content?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    community?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    confirmationToken?: SortOrderInput | SortOrder
    Community?: CommunityOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type PendingPostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PendingPostWhereInput | PendingPostWhereInput[]
    OR?: PendingPostWhereInput[]
    NOT?: PendingPostWhereInput | PendingPostWhereInput[]
    Content?: StringNullableFilter<"PendingPost"> | string | null
    fileUrl?: StringNullableFilter<"PendingPost"> | string | null
    community?: IntNullableFilter<"PendingPost"> | number | null
    user?: StringNullableFilter<"PendingPost"> | string | null
    caption?: StringNullableFilter<"PendingPost"> | string | null
    status?: StringNullableFilter<"PendingPost"> | string | null
    confirmationToken?: StringNullableFilter<"PendingPost"> | string | null
    Community?: XOR<CommunityNullableRelationFilter, CommunityWhereInput> | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type PendingPostOrderByWithAggregationInput = {
    id?: SortOrder
    Content?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    community?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    confirmationToken?: SortOrderInput | SortOrder
    _count?: PendingPostCountOrderByAggregateInput
    _avg?: PendingPostAvgOrderByAggregateInput
    _max?: PendingPostMaxOrderByAggregateInput
    _min?: PendingPostMinOrderByAggregateInput
    _sum?: PendingPostSumOrderByAggregateInput
  }

  export type PendingPostScalarWhereWithAggregatesInput = {
    AND?: PendingPostScalarWhereWithAggregatesInput | PendingPostScalarWhereWithAggregatesInput[]
    OR?: PendingPostScalarWhereWithAggregatesInput[]
    NOT?: PendingPostScalarWhereWithAggregatesInput | PendingPostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PendingPost"> | number
    Content?: StringNullableWithAggregatesFilter<"PendingPost"> | string | null
    fileUrl?: StringNullableWithAggregatesFilter<"PendingPost"> | string | null
    community?: IntNullableWithAggregatesFilter<"PendingPost"> | number | null
    user?: StringNullableWithAggregatesFilter<"PendingPost"> | string | null
    caption?: StringNullableWithAggregatesFilter<"PendingPost"> | string | null
    status?: StringNullableWithAggregatesFilter<"PendingPost"> | string | null
    confirmationToken?: StringNullableWithAggregatesFilter<"PendingPost"> | string | null
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: IntFilter<"Post"> | number
    Content?: StringNullableFilter<"Post"> | string | null
    fileUrl?: StringNullableFilter<"Post"> | string | null
    community?: IntNullableFilter<"Post"> | number | null
    user?: StringNullableFilter<"Post"> | string | null
    caption?: StringNullableFilter<"Post"> | string | null
    Comment?: CommentListRelationFilter
    Community?: XOR<CommunityNullableRelationFilter, CommunityWhereInput> | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    Report?: ReportListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    Content?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    community?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    Comment?: CommentOrderByRelationAggregateInput
    Community?: CommunityOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    Report?: ReportOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    Content?: StringNullableFilter<"Post"> | string | null
    fileUrl?: StringNullableFilter<"Post"> | string | null
    community?: IntNullableFilter<"Post"> | number | null
    user?: StringNullableFilter<"Post"> | string | null
    caption?: StringNullableFilter<"Post"> | string | null
    Comment?: CommentListRelationFilter
    Community?: XOR<CommunityNullableRelationFilter, CommunityWhereInput> | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    Report?: ReportListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    Content?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    community?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Post"> | number
    Content?: StringNullableWithAggregatesFilter<"Post"> | string | null
    fileUrl?: StringNullableWithAggregatesFilter<"Post"> | string | null
    community?: IntNullableWithAggregatesFilter<"Post"> | number | null
    user?: StringNullableWithAggregatesFilter<"Post"> | string | null
    caption?: StringNullableWithAggregatesFilter<"Post"> | string | null
  }

  export type PreferencesWhereInput = {
    AND?: PreferencesWhereInput | PreferencesWhereInput[]
    OR?: PreferencesWhereInput[]
    NOT?: PreferencesWhereInput | PreferencesWhereInput[]
    id?: IntFilter<"Preferences"> | number
    user?: StringNullableFilter<"Preferences"> | string | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type PreferencesOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type PreferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PreferencesWhereInput | PreferencesWhereInput[]
    OR?: PreferencesWhereInput[]
    NOT?: PreferencesWhereInput | PreferencesWhereInput[]
    user?: StringNullableFilter<"Preferences"> | string | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type PreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    _count?: PreferencesCountOrderByAggregateInput
    _avg?: PreferencesAvgOrderByAggregateInput
    _max?: PreferencesMaxOrderByAggregateInput
    _min?: PreferencesMinOrderByAggregateInput
    _sum?: PreferencesSumOrderByAggregateInput
  }

  export type PreferencesScalarWhereWithAggregatesInput = {
    AND?: PreferencesScalarWhereWithAggregatesInput | PreferencesScalarWhereWithAggregatesInput[]
    OR?: PreferencesScalarWhereWithAggregatesInput[]
    NOT?: PreferencesScalarWhereWithAggregatesInput | PreferencesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Preferences"> | number
    user?: StringNullableWithAggregatesFilter<"Preferences"> | string | null
  }

  export type RelationshipWhereInput = {
    AND?: RelationshipWhereInput | RelationshipWhereInput[]
    OR?: RelationshipWhereInput[]
    NOT?: RelationshipWhereInput | RelationshipWhereInput[]
    id?: IntFilter<"Relationship"> | number
    follower?: StringNullableFilter<"Relationship"> | string | null
    following?: StringNullableFilter<"Relationship"> | string | null
    User_Relationship_followerToUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    User_Relationship_followingToUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type RelationshipOrderByWithRelationInput = {
    id?: SortOrder
    follower?: SortOrderInput | SortOrder
    following?: SortOrderInput | SortOrder
    User_Relationship_followerToUser?: UserOrderByWithRelationInput
    User_Relationship_followingToUser?: UserOrderByWithRelationInput
  }

  export type RelationshipWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RelationshipWhereInput | RelationshipWhereInput[]
    OR?: RelationshipWhereInput[]
    NOT?: RelationshipWhereInput | RelationshipWhereInput[]
    follower?: StringNullableFilter<"Relationship"> | string | null
    following?: StringNullableFilter<"Relationship"> | string | null
    User_Relationship_followerToUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    User_Relationship_followingToUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type RelationshipOrderByWithAggregationInput = {
    id?: SortOrder
    follower?: SortOrderInput | SortOrder
    following?: SortOrderInput | SortOrder
    _count?: RelationshipCountOrderByAggregateInput
    _avg?: RelationshipAvgOrderByAggregateInput
    _max?: RelationshipMaxOrderByAggregateInput
    _min?: RelationshipMinOrderByAggregateInput
    _sum?: RelationshipSumOrderByAggregateInput
  }

  export type RelationshipScalarWhereWithAggregatesInput = {
    AND?: RelationshipScalarWhereWithAggregatesInput | RelationshipScalarWhereWithAggregatesInput[]
    OR?: RelationshipScalarWhereWithAggregatesInput[]
    NOT?: RelationshipScalarWhereWithAggregatesInput | RelationshipScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Relationship"> | number
    follower?: StringNullableWithAggregatesFilter<"Relationship"> | string | null
    following?: StringNullableWithAggregatesFilter<"Relationship"> | string | null
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: IntFilter<"Report"> | number
    reportedBy?: StringNullableFilter<"Report"> | string | null
    post?: IntNullableFilter<"Report"> | number | null
    community?: IntNullableFilter<"Report"> | number | null
    reportReason?: StringNullableFilter<"Report"> | string | null
    reportDate?: DateTimeNullableFilter<"Report"> | Date | string | null
    Community?: XOR<CommunityNullableRelationFilter, CommunityWhereInput> | null
    Post?: XOR<PostNullableRelationFilter, PostWhereInput> | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    reportedBy?: SortOrderInput | SortOrder
    post?: SortOrderInput | SortOrder
    community?: SortOrderInput | SortOrder
    reportReason?: SortOrderInput | SortOrder
    reportDate?: SortOrderInput | SortOrder
    Community?: CommunityOrderByWithRelationInput
    Post?: PostOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    reportedBy?: StringNullableFilter<"Report"> | string | null
    post?: IntNullableFilter<"Report"> | number | null
    community?: IntNullableFilter<"Report"> | number | null
    reportReason?: StringNullableFilter<"Report"> | string | null
    reportDate?: DateTimeNullableFilter<"Report"> | Date | string | null
    Community?: XOR<CommunityNullableRelationFilter, CommunityWhereInput> | null
    Post?: XOR<PostNullableRelationFilter, PostWhereInput> | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    reportedBy?: SortOrderInput | SortOrder
    post?: SortOrderInput | SortOrder
    community?: SortOrderInput | SortOrder
    reportReason?: SortOrderInput | SortOrder
    reportDate?: SortOrderInput | SortOrder
    _count?: ReportCountOrderByAggregateInput
    _avg?: ReportAvgOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
    _sum?: ReportSumOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Report"> | number
    reportedBy?: StringNullableWithAggregatesFilter<"Report"> | string | null
    post?: IntNullableWithAggregatesFilter<"Report"> | number | null
    community?: IntNullableWithAggregatesFilter<"Report"> | number | null
    reportReason?: StringNullableWithAggregatesFilter<"Report"> | string | null
    reportDate?: DateTimeNullableWithAggregatesFilter<"Report"> | Date | string | null
  }

  export type TokenWhereInput = {
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    id?: IntFilter<"Token"> | number
    user?: StringNullableFilter<"Token"> | string | null
    refreshToken?: StringNullableFilter<"Token"> | string | null
    accessToken?: StringNullableFilter<"Token"> | string | null
    createdAt?: DateTimeNullableFilter<"Token"> | Date | string | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type TokenOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type TokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    user?: StringNullableFilter<"Token"> | string | null
    refreshToken?: StringNullableFilter<"Token"> | string | null
    accessToken?: StringNullableFilter<"Token"> | string | null
    createdAt?: DateTimeNullableFilter<"Token"> | Date | string | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type TokenOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: TokenCountOrderByAggregateInput
    _avg?: TokenAvgOrderByAggregateInput
    _max?: TokenMaxOrderByAggregateInput
    _min?: TokenMinOrderByAggregateInput
    _sum?: TokenSumOrderByAggregateInput
  }

  export type TokenScalarWhereWithAggregatesInput = {
    AND?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    OR?: TokenScalarWhereWithAggregatesInput[]
    NOT?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Token"> | number
    user?: StringNullableWithAggregatesFilter<"Token"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Token"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"Token"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Token"> | Date | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    username?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    role?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isEmailVerified?: BoolNullableFilter<"User"> | boolean | null
    height?: FloatNullableFilter<"User"> | number | null
    weight?: FloatNullableFilter<"User"> | number | null
    BannedUsers?: BannedUsersListRelationFilter
    CommunityRequest?: CommunityRequestListRelationFilter
    Context?: ContextListRelationFilter
    LeaderboardEntry?: LeaderboardEntryListRelationFilter
    PendingPost?: PendingPostListRelationFilter
    Post?: PostListRelationFilter
    Preferences?: PreferencesListRelationFilter
    Relationship_Relationship_followerToUser?: RelationshipListRelationFilter
    Relationship_Relationship_followingToUser?: RelationshipListRelationFilter
    Report?: ReportListRelationFilter
    Token?: TokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    username?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    isEmailVerified?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    BannedUsers?: BannedUsersOrderByRelationAggregateInput
    CommunityRequest?: CommunityRequestOrderByRelationAggregateInput
    Context?: ContextOrderByRelationAggregateInput
    LeaderboardEntry?: LeaderboardEntryOrderByRelationAggregateInput
    PendingPost?: PendingPostOrderByRelationAggregateInput
    Post?: PostOrderByRelationAggregateInput
    Preferences?: PreferencesOrderByRelationAggregateInput
    Relationship_Relationship_followerToUser?: RelationshipOrderByRelationAggregateInput
    Relationship_Relationship_followingToUser?: RelationshipOrderByRelationAggregateInput
    Report?: ReportOrderByRelationAggregateInput
    Token?: TokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    role?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isEmailVerified?: BoolNullableFilter<"User"> | boolean | null
    height?: FloatNullableFilter<"User"> | number | null
    weight?: FloatNullableFilter<"User"> | number | null
    BannedUsers?: BannedUsersListRelationFilter
    CommunityRequest?: CommunityRequestListRelationFilter
    Context?: ContextListRelationFilter
    LeaderboardEntry?: LeaderboardEntryListRelationFilter
    PendingPost?: PendingPostListRelationFilter
    Post?: PostListRelationFilter
    Preferences?: PreferencesListRelationFilter
    Relationship_Relationship_followerToUser?: RelationshipListRelationFilter
    Relationship_Relationship_followingToUser?: RelationshipListRelationFilter
    Report?: ReportListRelationFilter
    Token?: TokenListRelationFilter
  }, "username">

  export type UserOrderByWithAggregationInput = {
    username?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    isEmailVerified?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    username?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isEmailVerified?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    height?: FloatNullableWithAggregatesFilter<"User"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"User"> | number | null
  }

  export type AdminCreateInput = {
    username?: string | null
    password?: string | null
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    username?: string | null
    password?: string | null
  }

  export type AdminUpdateInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminCreateManyInput = {
    id?: number
    username?: string | null
    password?: string | null
  }

  export type AdminUpdateManyMutationInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminTokenCreateInput = {
    user?: string | null
    accessToken?: string | null
  }

  export type AdminTokenUncheckedCreateInput = {
    id?: number
    user?: string | null
    accessToken?: string | null
  }

  export type AdminTokenUpdateInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminTokenCreateManyInput = {
    id?: number
    user?: string | null
    accessToken?: string | null
  }

  export type AdminTokenUpdateManyMutationInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BannedUsersCreateInput = {
    Community: CommunityCreateNestedOneWithoutBannedUsersInput
    User: UserCreateNestedOneWithoutBannedUsersInput
  }

  export type BannedUsersUncheckedCreateInput = {
    id?: number
    community: number
    user: string
  }

  export type BannedUsersUpdateInput = {
    Community?: CommunityUpdateOneRequiredWithoutBannedUsersNestedInput
    User?: UserUpdateOneRequiredWithoutBannedUsersNestedInput
  }

  export type BannedUsersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
  }

  export type BannedUsersCreateManyInput = {
    id?: number
    community: number
    user: string
  }

  export type BannedUsersUpdateManyMutationInput = {

  }

  export type BannedUsersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateInput = {
    body?: string | null
    user?: string | null
    Post?: PostCreateNestedOneWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    body?: string | null
    user?: string | null
    post?: number | null
  }

  export type CommentUpdateInput = {
    body?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    Post?: PostUpdateOneWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    post?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommentCreateManyInput = {
    id?: number
    body?: string | null
    user?: string | null
    post?: number | null
  }

  export type CommentUpdateManyMutationInput = {
    body?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    post?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommunityCreateInput = {
    name?: string | null
    description?: string | null
    BannedUsers?: BannedUsersCreateNestedManyWithoutCommunityInput
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutCommunityInput
    Leaderboard?: LeaderboardCreateNestedManyWithoutCommunityInput
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutCommunityInput
    PendingPost?: PendingPostCreateNestedManyWithoutCommunityInput
    Post?: PostCreateNestedManyWithoutCommunityInput
    Report?: ReportCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateInput = {
    id?: number
    name?: string | null
    description?: string | null
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutCommunityInput
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutCommunityInput
    Leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutCommunityInput
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutCommunityInput
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutCommunityInput
    Post?: PostUncheckedCreateNestedManyWithoutCommunityInput
    Report?: ReportUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    BannedUsers?: BannedUsersUpdateManyWithoutCommunityNestedInput
    CommunityRequest?: CommunityRequestUpdateManyWithoutCommunityNestedInput
    Leaderboard?: LeaderboardUpdateManyWithoutCommunityNestedInput
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutCommunityNestedInput
    PendingPost?: PendingPostUpdateManyWithoutCommunityNestedInput
    Post?: PostUpdateManyWithoutCommunityNestedInput
    Report?: ReportUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutCommunityNestedInput
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutCommunityNestedInput
    Leaderboard?: LeaderboardUncheckedUpdateManyWithoutCommunityNestedInput
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutCommunityNestedInput
    PendingPost?: PendingPostUncheckedUpdateManyWithoutCommunityNestedInput
    Post?: PostUncheckedUpdateManyWithoutCommunityNestedInput
    Report?: ReportUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityCreateManyInput = {
    id?: number
    name?: string | null
    description?: string | null
  }

  export type CommunityUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunityRequestCreateInput = {
    isVerified?: boolean | null
    isRequested?: boolean | null
    Community?: CommunityCreateNestedOneWithoutCommunityRequestInput
    User?: UserCreateNestedOneWithoutCommunityRequestInput
  }

  export type CommunityRequestUncheckedCreateInput = {
    id?: number
    user?: string | null
    community?: number | null
    isVerified?: boolean | null
    isRequested?: boolean | null
  }

  export type CommunityRequestUpdateInput = {
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRequested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Community?: CommunityUpdateOneWithoutCommunityRequestNestedInput
    User?: UserUpdateOneWithoutCommunityRequestNestedInput
  }

  export type CommunityRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRequested?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CommunityRequestCreateManyInput = {
    id?: number
    user?: string | null
    community?: number | null
    isVerified?: boolean | null
    isRequested?: boolean | null
  }

  export type CommunityRequestUpdateManyMutationInput = {
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRequested?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CommunityRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRequested?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ContextCreateInput = {
    email?: string | null
    ip?: string | null
    country?: string | null
    city?: string | null
    browser?: string | null
    platform?: string | null
    os?: string | null
    device?: string | null
    deviceType?: string | null
    isTrusted?: boolean | null
    User?: UserCreateNestedOneWithoutContextInput
  }

  export type ContextUncheckedCreateInput = {
    id?: number
    user?: string | null
    email?: string | null
    ip?: string | null
    country?: string | null
    city?: string | null
    browser?: string | null
    platform?: string | null
    os?: string | null
    device?: string | null
    deviceType?: string | null
    isTrusted?: boolean | null
  }

  export type ContextUpdateInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    User?: UserUpdateOneWithoutContextNestedInput
  }

  export type ContextUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ContextCreateManyInput = {
    id?: number
    user?: string | null
    email?: string | null
    ip?: string | null
    country?: string | null
    city?: string | null
    browser?: string | null
    platform?: string | null
    os?: string | null
    device?: string | null
    deviceType?: string | null
    isTrusted?: boolean | null
  }

  export type ContextUpdateManyMutationInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ContextUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type LeaderboardCreateInput = {
    tracking?: string | null
    Community: CommunityCreateNestedOneWithoutLeaderboardInput
  }

  export type LeaderboardUncheckedCreateInput = {
    id?: number
    community: number
    tracking?: string | null
  }

  export type LeaderboardUpdateInput = {
    tracking?: NullableStringFieldUpdateOperationsInput | string | null
    Community?: CommunityUpdateOneRequiredWithoutLeaderboardNestedInput
  }

  export type LeaderboardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
    tracking?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeaderboardCreateManyInput = {
    id?: number
    community: number
    tracking?: string | null
  }

  export type LeaderboardUpdateManyMutationInput = {
    tracking?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeaderboardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
    tracking?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeaderboardEntryCreateInput = {
    entryUrl?: string | null
    verifiedBy?: number | null
    isVerified?: boolean | null
    rank?: number | null
    Community?: CommunityCreateNestedOneWithoutLeaderboardEntryInput
    User?: UserCreateNestedOneWithoutLeaderboardEntryInput
  }

  export type LeaderboardEntryUncheckedCreateInput = {
    id?: number
    user?: string | null
    community?: number | null
    entryUrl?: string | null
    verifiedBy?: number | null
    isVerified?: boolean | null
    rank?: number | null
  }

  export type LeaderboardEntryUpdateInput = {
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    Community?: CommunityUpdateOneWithoutLeaderboardEntryNestedInput
    User?: UserUpdateOneWithoutLeaderboardEntryNestedInput
  }

  export type LeaderboardEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LeaderboardEntryCreateManyInput = {
    id?: number
    user?: string | null
    community?: number | null
    entryUrl?: string | null
    verifiedBy?: number | null
    isVerified?: boolean | null
    rank?: number | null
  }

  export type LeaderboardEntryUpdateManyMutationInput = {
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LeaderboardEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LikeCreateInput = {
    user?: string | null
    post?: number | null
  }

  export type LikeUncheckedCreateInput = {
    id?: number
    user?: string | null
    post?: number | null
  }

  export type LikeUpdateInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    post?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LikeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    post?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LikeCreateManyInput = {
    id?: number
    user?: string | null
    post?: number | null
  }

  export type LikeUpdateManyMutationInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    post?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LikeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    post?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LogCreateInput = {
    email?: string | null
    context?: string | null
    message?: string | null
    type?: string | null
    level?: string | null
    timestamp?: Date | string | null
  }

  export type LogUncheckedCreateInput = {
    id?: number
    email?: string | null
    context?: string | null
    message?: string | null
    type?: string | null
    level?: string | null
    timestamp?: Date | string | null
  }

  export type LogUpdateInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogCreateManyInput = {
    id?: number
    email?: string | null
    context?: string | null
    message?: string | null
    type?: string | null
    level?: string | null
    timestamp?: Date | string | null
  }

  export type LogUpdateManyMutationInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PendingPostCreateInput = {
    Content?: string | null
    fileUrl?: string | null
    caption?: string | null
    status?: string | null
    confirmationToken?: string | null
    Community?: CommunityCreateNestedOneWithoutPendingPostInput
    User?: UserCreateNestedOneWithoutPendingPostInput
  }

  export type PendingPostUncheckedCreateInput = {
    id?: number
    Content?: string | null
    fileUrl?: string | null
    community?: number | null
    user?: string | null
    caption?: string | null
    status?: string | null
    confirmationToken?: string | null
  }

  export type PendingPostUpdateInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationToken?: NullableStringFieldUpdateOperationsInput | string | null
    Community?: CommunityUpdateOneWithoutPendingPostNestedInput
    User?: UserUpdateOneWithoutPendingPostNestedInput
  }

  export type PendingPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PendingPostCreateManyInput = {
    id?: number
    Content?: string | null
    fileUrl?: string | null
    community?: number | null
    user?: string | null
    caption?: string | null
    status?: string | null
    confirmationToken?: string | null
  }

  export type PendingPostUpdateManyMutationInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PendingPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostCreateInput = {
    Content?: string | null
    fileUrl?: string | null
    caption?: string | null
    Comment?: CommentCreateNestedManyWithoutPostInput
    Community?: CommunityCreateNestedOneWithoutPostInput
    User?: UserCreateNestedOneWithoutPostInput
    Report?: ReportCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: number
    Content?: string | null
    fileUrl?: string | null
    community?: number | null
    user?: string | null
    caption?: string | null
    Comment?: CommentUncheckedCreateNestedManyWithoutPostInput
    Report?: ReportUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: CommentUpdateManyWithoutPostNestedInput
    Community?: CommunityUpdateOneWithoutPostNestedInput
    User?: UserUpdateOneWithoutPostNestedInput
    Report?: ReportUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: CommentUncheckedUpdateManyWithoutPostNestedInput
    Report?: ReportUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: number
    Content?: string | null
    fileUrl?: string | null
    community?: number | null
    user?: string | null
    caption?: string | null
  }

  export type PostUpdateManyMutationInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PreferencesCreateInput = {
    User?: UserCreateNestedOneWithoutPreferencesInput
  }

  export type PreferencesUncheckedCreateInput = {
    id?: number
    user?: string | null
  }

  export type PreferencesUpdateInput = {
    User?: UserUpdateOneWithoutPreferencesNestedInput
  }

  export type PreferencesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PreferencesCreateManyInput = {
    id?: number
    user?: string | null
  }

  export type PreferencesUpdateManyMutationInput = {

  }

  export type PreferencesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RelationshipCreateInput = {
    User_Relationship_followerToUser?: UserCreateNestedOneWithoutRelationship_Relationship_followerToUserInput
    User_Relationship_followingToUser?: UserCreateNestedOneWithoutRelationship_Relationship_followingToUserInput
  }

  export type RelationshipUncheckedCreateInput = {
    id?: number
    follower?: string | null
    following?: string | null
  }

  export type RelationshipUpdateInput = {
    User_Relationship_followerToUser?: UserUpdateOneWithoutRelationship_Relationship_followerToUserNestedInput
    User_Relationship_followingToUser?: UserUpdateOneWithoutRelationship_Relationship_followingToUserNestedInput
  }

  export type RelationshipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    follower?: NullableStringFieldUpdateOperationsInput | string | null
    following?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RelationshipCreateManyInput = {
    id?: number
    follower?: string | null
    following?: string | null
  }

  export type RelationshipUpdateManyMutationInput = {

  }

  export type RelationshipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    follower?: NullableStringFieldUpdateOperationsInput | string | null
    following?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportCreateInput = {
    reportReason?: string | null
    reportDate?: Date | string | null
    Community?: CommunityCreateNestedOneWithoutReportInput
    Post?: PostCreateNestedOneWithoutReportInput
    User?: UserCreateNestedOneWithoutReportInput
  }

  export type ReportUncheckedCreateInput = {
    id?: number
    reportedBy?: string | null
    post?: number | null
    community?: number | null
    reportReason?: string | null
    reportDate?: Date | string | null
  }

  export type ReportUpdateInput = {
    reportReason?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Community?: CommunityUpdateOneWithoutReportNestedInput
    Post?: PostUpdateOneWithoutReportNestedInput
    User?: UserUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedBy?: NullableStringFieldUpdateOperationsInput | string | null
    post?: NullableIntFieldUpdateOperationsInput | number | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    reportReason?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportCreateManyInput = {
    id?: number
    reportedBy?: string | null
    post?: number | null
    community?: number | null
    reportReason?: string | null
    reportDate?: Date | string | null
  }

  export type ReportUpdateManyMutationInput = {
    reportReason?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedBy?: NullableStringFieldUpdateOperationsInput | string | null
    post?: NullableIntFieldUpdateOperationsInput | number | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    reportReason?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TokenCreateInput = {
    refreshToken?: string | null
    accessToken?: string | null
    createdAt?: Date | string | null
    User?: UserCreateNestedOneWithoutTokenInput
  }

  export type TokenUncheckedCreateInput = {
    id?: number
    user?: string | null
    refreshToken?: string | null
    accessToken?: string | null
    createdAt?: Date | string | null
  }

  export type TokenUpdateInput = {
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TokenCreateManyInput = {
    id?: number
    user?: string | null
    refreshToken?: string | null
    accessToken?: string | null
    createdAt?: Date | string | null
  }

  export type TokenUpdateManyMutationInput = {
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutUserInput
    Context?: ContextCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
    Preferences?: PreferencesCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Token?: TokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutUserInput
    Context?: ContextUncheckedCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
    Preferences?: PreferencesUncheckedCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUpdateManyWithoutUserNestedInput
    Context?: ContextUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Token?: TokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutUserNestedInput
    Context?: ContextUncheckedUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUncheckedUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UserUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type AdminTokenCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    accessToken?: SortOrder
  }

  export type AdminTokenAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    accessToken?: SortOrder
  }

  export type AdminTokenMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    accessToken?: SortOrder
  }

  export type AdminTokenSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type CommunityRelationFilter = {
    is?: CommunityWhereInput
    isNot?: CommunityWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BannedUsersCountOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    user?: SortOrder
  }

  export type BannedUsersAvgOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type BannedUsersMaxOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    user?: SortOrder
  }

  export type BannedUsersMinOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    user?: SortOrder
  }

  export type BannedUsersSumOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PostNullableRelationFilter = {
    is?: PostWhereInput | null
    isNot?: PostWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    user?: SortOrder
    post?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    post?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    user?: SortOrder
    post?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    user?: SortOrder
    post?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    post?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BannedUsersListRelationFilter = {
    every?: BannedUsersWhereInput
    some?: BannedUsersWhereInput
    none?: BannedUsersWhereInput
  }

  export type CommunityRequestListRelationFilter = {
    every?: CommunityRequestWhereInput
    some?: CommunityRequestWhereInput
    none?: CommunityRequestWhereInput
  }

  export type LeaderboardListRelationFilter = {
    every?: LeaderboardWhereInput
    some?: LeaderboardWhereInput
    none?: LeaderboardWhereInput
  }

  export type LeaderboardEntryListRelationFilter = {
    every?: LeaderboardEntryWhereInput
    some?: LeaderboardEntryWhereInput
    none?: LeaderboardEntryWhereInput
  }

  export type PendingPostListRelationFilter = {
    every?: PendingPostWhereInput
    some?: PendingPostWhereInput
    none?: PendingPostWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type BannedUsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaderboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaderboardEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PendingPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CommunityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CommunityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CommunityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CommunitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type CommunityNullableRelationFilter = {
    is?: CommunityWhereInput | null
    isNot?: CommunityWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CommunityRequestCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    community?: SortOrder
    isVerified?: SortOrder
    isRequested?: SortOrder
  }

  export type CommunityRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type CommunityRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    community?: SortOrder
    isVerified?: SortOrder
    isRequested?: SortOrder
  }

  export type CommunityRequestMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    community?: SortOrder
    isVerified?: SortOrder
    isRequested?: SortOrder
  }

  export type CommunityRequestSumOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ContextCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    email?: SortOrder
    ip?: SortOrder
    country?: SortOrder
    city?: SortOrder
    browser?: SortOrder
    platform?: SortOrder
    os?: SortOrder
    device?: SortOrder
    deviceType?: SortOrder
    isTrusted?: SortOrder
  }

  export type ContextAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContextMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    email?: SortOrder
    ip?: SortOrder
    country?: SortOrder
    city?: SortOrder
    browser?: SortOrder
    platform?: SortOrder
    os?: SortOrder
    device?: SortOrder
    deviceType?: SortOrder
    isTrusted?: SortOrder
  }

  export type ContextMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    email?: SortOrder
    ip?: SortOrder
    country?: SortOrder
    city?: SortOrder
    browser?: SortOrder
    platform?: SortOrder
    os?: SortOrder
    device?: SortOrder
    deviceType?: SortOrder
    isTrusted?: SortOrder
  }

  export type ContextSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LeaderboardCountOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    tracking?: SortOrder
  }

  export type LeaderboardAvgOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type LeaderboardMaxOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    tracking?: SortOrder
  }

  export type LeaderboardMinOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    tracking?: SortOrder
  }

  export type LeaderboardSumOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type LeaderboardEntryCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    community?: SortOrder
    entryUrl?: SortOrder
    verifiedBy?: SortOrder
    isVerified?: SortOrder
    rank?: SortOrder
  }

  export type LeaderboardEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    verifiedBy?: SortOrder
    rank?: SortOrder
  }

  export type LeaderboardEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    community?: SortOrder
    entryUrl?: SortOrder
    verifiedBy?: SortOrder
    isVerified?: SortOrder
    rank?: SortOrder
  }

  export type LeaderboardEntryMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    community?: SortOrder
    entryUrl?: SortOrder
    verifiedBy?: SortOrder
    isVerified?: SortOrder
    rank?: SortOrder
  }

  export type LeaderboardEntrySumOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    verifiedBy?: SortOrder
    rank?: SortOrder
  }

  export type LikeCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    post?: SortOrder
  }

  export type LikeAvgOrderByAggregateInput = {
    id?: SortOrder
    post?: SortOrder
  }

  export type LikeMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    post?: SortOrder
  }

  export type LikeMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    post?: SortOrder
  }

  export type LikeSumOrderByAggregateInput = {
    id?: SortOrder
    post?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    context?: SortOrder
    message?: SortOrder
    type?: SortOrder
    level?: SortOrder
    timestamp?: SortOrder
  }

  export type LogAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    context?: SortOrder
    message?: SortOrder
    type?: SortOrder
    level?: SortOrder
    timestamp?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    context?: SortOrder
    message?: SortOrder
    type?: SortOrder
    level?: SortOrder
    timestamp?: SortOrder
  }

  export type LogSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PendingPostCountOrderByAggregateInput = {
    id?: SortOrder
    Content?: SortOrder
    fileUrl?: SortOrder
    community?: SortOrder
    user?: SortOrder
    caption?: SortOrder
    status?: SortOrder
    confirmationToken?: SortOrder
  }

  export type PendingPostAvgOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type PendingPostMaxOrderByAggregateInput = {
    id?: SortOrder
    Content?: SortOrder
    fileUrl?: SortOrder
    community?: SortOrder
    user?: SortOrder
    caption?: SortOrder
    status?: SortOrder
    confirmationToken?: SortOrder
  }

  export type PendingPostMinOrderByAggregateInput = {
    id?: SortOrder
    Content?: SortOrder
    fileUrl?: SortOrder
    community?: SortOrder
    user?: SortOrder
    caption?: SortOrder
    status?: SortOrder
    confirmationToken?: SortOrder
  }

  export type PendingPostSumOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    Content?: SortOrder
    fileUrl?: SortOrder
    community?: SortOrder
    user?: SortOrder
    caption?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    Content?: SortOrder
    fileUrl?: SortOrder
    community?: SortOrder
    user?: SortOrder
    caption?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    Content?: SortOrder
    fileUrl?: SortOrder
    community?: SortOrder
    user?: SortOrder
    caption?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type PreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
  }

  export type PreferencesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
  }

  export type PreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
  }

  export type PreferencesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RelationshipCountOrderByAggregateInput = {
    id?: SortOrder
    follower?: SortOrder
    following?: SortOrder
  }

  export type RelationshipAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RelationshipMaxOrderByAggregateInput = {
    id?: SortOrder
    follower?: SortOrder
    following?: SortOrder
  }

  export type RelationshipMinOrderByAggregateInput = {
    id?: SortOrder
    follower?: SortOrder
    following?: SortOrder
  }

  export type RelationshipSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    reportedBy?: SortOrder
    post?: SortOrder
    community?: SortOrder
    reportReason?: SortOrder
    reportDate?: SortOrder
  }

  export type ReportAvgOrderByAggregateInput = {
    id?: SortOrder
    post?: SortOrder
    community?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reportedBy?: SortOrder
    post?: SortOrder
    community?: SortOrder
    reportReason?: SortOrder
    reportDate?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    reportedBy?: SortOrder
    post?: SortOrder
    community?: SortOrder
    reportReason?: SortOrder
    reportDate?: SortOrder
  }

  export type ReportSumOrderByAggregateInput = {
    id?: SortOrder
    post?: SortOrder
    community?: SortOrder
  }

  export type TokenCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
  }

  export type TokenAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TokenMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
  }

  export type TokenMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
  }

  export type TokenSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ContextListRelationFilter = {
    every?: ContextWhereInput
    some?: ContextWhereInput
    none?: ContextWhereInput
  }

  export type PreferencesListRelationFilter = {
    every?: PreferencesWhereInput
    some?: PreferencesWhereInput
    none?: PreferencesWhereInput
  }

  export type RelationshipListRelationFilter = {
    every?: RelationshipWhereInput
    some?: RelationshipWhereInput
    none?: RelationshipWhereInput
  }

  export type TokenListRelationFilter = {
    every?: TokenWhereInput
    some?: TokenWhereInput
    none?: TokenWhereInput
  }

  export type ContextOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PreferencesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RelationshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    isEmailVerified?: SortOrder
    height?: SortOrder
    weight?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    height?: SortOrder
    weight?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    isEmailVerified?: SortOrder
    height?: SortOrder
    weight?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    isEmailVerified?: SortOrder
    height?: SortOrder
    weight?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    height?: SortOrder
    weight?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CommunityCreateNestedOneWithoutBannedUsersInput = {
    create?: XOR<CommunityCreateWithoutBannedUsersInput, CommunityUncheckedCreateWithoutBannedUsersInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutBannedUsersInput
    connect?: CommunityWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBannedUsersInput = {
    create?: XOR<UserCreateWithoutBannedUsersInput, UserUncheckedCreateWithoutBannedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutBannedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityUpdateOneRequiredWithoutBannedUsersNestedInput = {
    create?: XOR<CommunityCreateWithoutBannedUsersInput, CommunityUncheckedCreateWithoutBannedUsersInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutBannedUsersInput
    upsert?: CommunityUpsertWithoutBannedUsersInput
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutBannedUsersInput, CommunityUpdateWithoutBannedUsersInput>, CommunityUncheckedUpdateWithoutBannedUsersInput>
  }

  export type UserUpdateOneRequiredWithoutBannedUsersNestedInput = {
    create?: XOR<UserCreateWithoutBannedUsersInput, UserUncheckedCreateWithoutBannedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutBannedUsersInput
    upsert?: UserUpsertWithoutBannedUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBannedUsersInput, UserUpdateWithoutBannedUsersInput>, UserUncheckedUpdateWithoutBannedUsersInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type PostCreateNestedOneWithoutCommentInput = {
    create?: XOR<PostCreateWithoutCommentInput, PostUncheckedCreateWithoutCommentInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentInput
    connect?: PostWhereUniqueInput
  }

  export type PostUpdateOneWithoutCommentNestedInput = {
    create?: XOR<PostCreateWithoutCommentInput, PostUncheckedCreateWithoutCommentInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentInput
    upsert?: PostUpsertWithoutCommentInput
    disconnect?: PostWhereInput | boolean
    delete?: PostWhereInput | boolean
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentInput, PostUpdateWithoutCommentInput>, PostUncheckedUpdateWithoutCommentInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BannedUsersCreateNestedManyWithoutCommunityInput = {
    create?: XOR<BannedUsersCreateWithoutCommunityInput, BannedUsersUncheckedCreateWithoutCommunityInput> | BannedUsersCreateWithoutCommunityInput[] | BannedUsersUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: BannedUsersCreateOrConnectWithoutCommunityInput | BannedUsersCreateOrConnectWithoutCommunityInput[]
    createMany?: BannedUsersCreateManyCommunityInputEnvelope
    connect?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
  }

  export type CommunityRequestCreateNestedManyWithoutCommunityInput = {
    create?: XOR<CommunityRequestCreateWithoutCommunityInput, CommunityRequestUncheckedCreateWithoutCommunityInput> | CommunityRequestCreateWithoutCommunityInput[] | CommunityRequestUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityRequestCreateOrConnectWithoutCommunityInput | CommunityRequestCreateOrConnectWithoutCommunityInput[]
    createMany?: CommunityRequestCreateManyCommunityInputEnvelope
    connect?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
  }

  export type LeaderboardCreateNestedManyWithoutCommunityInput = {
    create?: XOR<LeaderboardCreateWithoutCommunityInput, LeaderboardUncheckedCreateWithoutCommunityInput> | LeaderboardCreateWithoutCommunityInput[] | LeaderboardUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutCommunityInput | LeaderboardCreateOrConnectWithoutCommunityInput[]
    createMany?: LeaderboardCreateManyCommunityInputEnvelope
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
  }

  export type LeaderboardEntryCreateNestedManyWithoutCommunityInput = {
    create?: XOR<LeaderboardEntryCreateWithoutCommunityInput, LeaderboardEntryUncheckedCreateWithoutCommunityInput> | LeaderboardEntryCreateWithoutCommunityInput[] | LeaderboardEntryUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutCommunityInput | LeaderboardEntryCreateOrConnectWithoutCommunityInput[]
    createMany?: LeaderboardEntryCreateManyCommunityInputEnvelope
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
  }

  export type PendingPostCreateNestedManyWithoutCommunityInput = {
    create?: XOR<PendingPostCreateWithoutCommunityInput, PendingPostUncheckedCreateWithoutCommunityInput> | PendingPostCreateWithoutCommunityInput[] | PendingPostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PendingPostCreateOrConnectWithoutCommunityInput | PendingPostCreateOrConnectWithoutCommunityInput[]
    createMany?: PendingPostCreateManyCommunityInputEnvelope
    connect?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutCommunityInput = {
    create?: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput> | PostCreateWithoutCommunityInput[] | PostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCommunityInput | PostCreateOrConnectWithoutCommunityInput[]
    createMany?: PostCreateManyCommunityInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutCommunityInput = {
    create?: XOR<ReportCreateWithoutCommunityInput, ReportUncheckedCreateWithoutCommunityInput> | ReportCreateWithoutCommunityInput[] | ReportUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCommunityInput | ReportCreateOrConnectWithoutCommunityInput[]
    createMany?: ReportCreateManyCommunityInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type BannedUsersUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<BannedUsersCreateWithoutCommunityInput, BannedUsersUncheckedCreateWithoutCommunityInput> | BannedUsersCreateWithoutCommunityInput[] | BannedUsersUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: BannedUsersCreateOrConnectWithoutCommunityInput | BannedUsersCreateOrConnectWithoutCommunityInput[]
    createMany?: BannedUsersCreateManyCommunityInputEnvelope
    connect?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
  }

  export type CommunityRequestUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<CommunityRequestCreateWithoutCommunityInput, CommunityRequestUncheckedCreateWithoutCommunityInput> | CommunityRequestCreateWithoutCommunityInput[] | CommunityRequestUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityRequestCreateOrConnectWithoutCommunityInput | CommunityRequestCreateOrConnectWithoutCommunityInput[]
    createMany?: CommunityRequestCreateManyCommunityInputEnvelope
    connect?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
  }

  export type LeaderboardUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<LeaderboardCreateWithoutCommunityInput, LeaderboardUncheckedCreateWithoutCommunityInput> | LeaderboardCreateWithoutCommunityInput[] | LeaderboardUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutCommunityInput | LeaderboardCreateOrConnectWithoutCommunityInput[]
    createMany?: LeaderboardCreateManyCommunityInputEnvelope
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
  }

  export type LeaderboardEntryUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<LeaderboardEntryCreateWithoutCommunityInput, LeaderboardEntryUncheckedCreateWithoutCommunityInput> | LeaderboardEntryCreateWithoutCommunityInput[] | LeaderboardEntryUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutCommunityInput | LeaderboardEntryCreateOrConnectWithoutCommunityInput[]
    createMany?: LeaderboardEntryCreateManyCommunityInputEnvelope
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
  }

  export type PendingPostUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<PendingPostCreateWithoutCommunityInput, PendingPostUncheckedCreateWithoutCommunityInput> | PendingPostCreateWithoutCommunityInput[] | PendingPostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PendingPostCreateOrConnectWithoutCommunityInput | PendingPostCreateOrConnectWithoutCommunityInput[]
    createMany?: PendingPostCreateManyCommunityInputEnvelope
    connect?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput> | PostCreateWithoutCommunityInput[] | PostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCommunityInput | PostCreateOrConnectWithoutCommunityInput[]
    createMany?: PostCreateManyCommunityInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<ReportCreateWithoutCommunityInput, ReportUncheckedCreateWithoutCommunityInput> | ReportCreateWithoutCommunityInput[] | ReportUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCommunityInput | ReportCreateOrConnectWithoutCommunityInput[]
    createMany?: ReportCreateManyCommunityInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type BannedUsersUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<BannedUsersCreateWithoutCommunityInput, BannedUsersUncheckedCreateWithoutCommunityInput> | BannedUsersCreateWithoutCommunityInput[] | BannedUsersUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: BannedUsersCreateOrConnectWithoutCommunityInput | BannedUsersCreateOrConnectWithoutCommunityInput[]
    upsert?: BannedUsersUpsertWithWhereUniqueWithoutCommunityInput | BannedUsersUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: BannedUsersCreateManyCommunityInputEnvelope
    set?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    disconnect?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    delete?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    connect?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    update?: BannedUsersUpdateWithWhereUniqueWithoutCommunityInput | BannedUsersUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: BannedUsersUpdateManyWithWhereWithoutCommunityInput | BannedUsersUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: BannedUsersScalarWhereInput | BannedUsersScalarWhereInput[]
  }

  export type CommunityRequestUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<CommunityRequestCreateWithoutCommunityInput, CommunityRequestUncheckedCreateWithoutCommunityInput> | CommunityRequestCreateWithoutCommunityInput[] | CommunityRequestUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityRequestCreateOrConnectWithoutCommunityInput | CommunityRequestCreateOrConnectWithoutCommunityInput[]
    upsert?: CommunityRequestUpsertWithWhereUniqueWithoutCommunityInput | CommunityRequestUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: CommunityRequestCreateManyCommunityInputEnvelope
    set?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    disconnect?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    delete?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    connect?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    update?: CommunityRequestUpdateWithWhereUniqueWithoutCommunityInput | CommunityRequestUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: CommunityRequestUpdateManyWithWhereWithoutCommunityInput | CommunityRequestUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: CommunityRequestScalarWhereInput | CommunityRequestScalarWhereInput[]
  }

  export type LeaderboardUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<LeaderboardCreateWithoutCommunityInput, LeaderboardUncheckedCreateWithoutCommunityInput> | LeaderboardCreateWithoutCommunityInput[] | LeaderboardUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutCommunityInput | LeaderboardCreateOrConnectWithoutCommunityInput[]
    upsert?: LeaderboardUpsertWithWhereUniqueWithoutCommunityInput | LeaderboardUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: LeaderboardCreateManyCommunityInputEnvelope
    set?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    disconnect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    delete?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    update?: LeaderboardUpdateWithWhereUniqueWithoutCommunityInput | LeaderboardUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: LeaderboardUpdateManyWithWhereWithoutCommunityInput | LeaderboardUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: LeaderboardScalarWhereInput | LeaderboardScalarWhereInput[]
  }

  export type LeaderboardEntryUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<LeaderboardEntryCreateWithoutCommunityInput, LeaderboardEntryUncheckedCreateWithoutCommunityInput> | LeaderboardEntryCreateWithoutCommunityInput[] | LeaderboardEntryUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutCommunityInput | LeaderboardEntryCreateOrConnectWithoutCommunityInput[]
    upsert?: LeaderboardEntryUpsertWithWhereUniqueWithoutCommunityInput | LeaderboardEntryUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: LeaderboardEntryCreateManyCommunityInputEnvelope
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    disconnect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    delete?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    update?: LeaderboardEntryUpdateWithWhereUniqueWithoutCommunityInput | LeaderboardEntryUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: LeaderboardEntryUpdateManyWithWhereWithoutCommunityInput | LeaderboardEntryUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
  }

  export type PendingPostUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<PendingPostCreateWithoutCommunityInput, PendingPostUncheckedCreateWithoutCommunityInput> | PendingPostCreateWithoutCommunityInput[] | PendingPostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PendingPostCreateOrConnectWithoutCommunityInput | PendingPostCreateOrConnectWithoutCommunityInput[]
    upsert?: PendingPostUpsertWithWhereUniqueWithoutCommunityInput | PendingPostUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: PendingPostCreateManyCommunityInputEnvelope
    set?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    disconnect?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    delete?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    connect?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    update?: PendingPostUpdateWithWhereUniqueWithoutCommunityInput | PendingPostUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: PendingPostUpdateManyWithWhereWithoutCommunityInput | PendingPostUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: PendingPostScalarWhereInput | PendingPostScalarWhereInput[]
  }

  export type PostUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput> | PostCreateWithoutCommunityInput[] | PostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCommunityInput | PostCreateOrConnectWithoutCommunityInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutCommunityInput | PostUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: PostCreateManyCommunityInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutCommunityInput | PostUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: PostUpdateManyWithWhereWithoutCommunityInput | PostUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<ReportCreateWithoutCommunityInput, ReportUncheckedCreateWithoutCommunityInput> | ReportCreateWithoutCommunityInput[] | ReportUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCommunityInput | ReportCreateOrConnectWithoutCommunityInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutCommunityInput | ReportUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: ReportCreateManyCommunityInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutCommunityInput | ReportUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutCommunityInput | ReportUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type BannedUsersUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<BannedUsersCreateWithoutCommunityInput, BannedUsersUncheckedCreateWithoutCommunityInput> | BannedUsersCreateWithoutCommunityInput[] | BannedUsersUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: BannedUsersCreateOrConnectWithoutCommunityInput | BannedUsersCreateOrConnectWithoutCommunityInput[]
    upsert?: BannedUsersUpsertWithWhereUniqueWithoutCommunityInput | BannedUsersUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: BannedUsersCreateManyCommunityInputEnvelope
    set?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    disconnect?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    delete?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    connect?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    update?: BannedUsersUpdateWithWhereUniqueWithoutCommunityInput | BannedUsersUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: BannedUsersUpdateManyWithWhereWithoutCommunityInput | BannedUsersUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: BannedUsersScalarWhereInput | BannedUsersScalarWhereInput[]
  }

  export type CommunityRequestUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<CommunityRequestCreateWithoutCommunityInput, CommunityRequestUncheckedCreateWithoutCommunityInput> | CommunityRequestCreateWithoutCommunityInput[] | CommunityRequestUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityRequestCreateOrConnectWithoutCommunityInput | CommunityRequestCreateOrConnectWithoutCommunityInput[]
    upsert?: CommunityRequestUpsertWithWhereUniqueWithoutCommunityInput | CommunityRequestUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: CommunityRequestCreateManyCommunityInputEnvelope
    set?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    disconnect?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    delete?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    connect?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    update?: CommunityRequestUpdateWithWhereUniqueWithoutCommunityInput | CommunityRequestUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: CommunityRequestUpdateManyWithWhereWithoutCommunityInput | CommunityRequestUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: CommunityRequestScalarWhereInput | CommunityRequestScalarWhereInput[]
  }

  export type LeaderboardUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<LeaderboardCreateWithoutCommunityInput, LeaderboardUncheckedCreateWithoutCommunityInput> | LeaderboardCreateWithoutCommunityInput[] | LeaderboardUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutCommunityInput | LeaderboardCreateOrConnectWithoutCommunityInput[]
    upsert?: LeaderboardUpsertWithWhereUniqueWithoutCommunityInput | LeaderboardUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: LeaderboardCreateManyCommunityInputEnvelope
    set?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    disconnect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    delete?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    update?: LeaderboardUpdateWithWhereUniqueWithoutCommunityInput | LeaderboardUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: LeaderboardUpdateManyWithWhereWithoutCommunityInput | LeaderboardUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: LeaderboardScalarWhereInput | LeaderboardScalarWhereInput[]
  }

  export type LeaderboardEntryUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<LeaderboardEntryCreateWithoutCommunityInput, LeaderboardEntryUncheckedCreateWithoutCommunityInput> | LeaderboardEntryCreateWithoutCommunityInput[] | LeaderboardEntryUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutCommunityInput | LeaderboardEntryCreateOrConnectWithoutCommunityInput[]
    upsert?: LeaderboardEntryUpsertWithWhereUniqueWithoutCommunityInput | LeaderboardEntryUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: LeaderboardEntryCreateManyCommunityInputEnvelope
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    disconnect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    delete?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    update?: LeaderboardEntryUpdateWithWhereUniqueWithoutCommunityInput | LeaderboardEntryUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: LeaderboardEntryUpdateManyWithWhereWithoutCommunityInput | LeaderboardEntryUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
  }

  export type PendingPostUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<PendingPostCreateWithoutCommunityInput, PendingPostUncheckedCreateWithoutCommunityInput> | PendingPostCreateWithoutCommunityInput[] | PendingPostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PendingPostCreateOrConnectWithoutCommunityInput | PendingPostCreateOrConnectWithoutCommunityInput[]
    upsert?: PendingPostUpsertWithWhereUniqueWithoutCommunityInput | PendingPostUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: PendingPostCreateManyCommunityInputEnvelope
    set?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    disconnect?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    delete?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    connect?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    update?: PendingPostUpdateWithWhereUniqueWithoutCommunityInput | PendingPostUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: PendingPostUpdateManyWithWhereWithoutCommunityInput | PendingPostUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: PendingPostScalarWhereInput | PendingPostScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput> | PostCreateWithoutCommunityInput[] | PostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCommunityInput | PostCreateOrConnectWithoutCommunityInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutCommunityInput | PostUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: PostCreateManyCommunityInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutCommunityInput | PostUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: PostUpdateManyWithWhereWithoutCommunityInput | PostUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<ReportCreateWithoutCommunityInput, ReportUncheckedCreateWithoutCommunityInput> | ReportCreateWithoutCommunityInput[] | ReportUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCommunityInput | ReportCreateOrConnectWithoutCommunityInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutCommunityInput | ReportUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: ReportCreateManyCommunityInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutCommunityInput | ReportUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutCommunityInput | ReportUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type CommunityCreateNestedOneWithoutCommunityRequestInput = {
    create?: XOR<CommunityCreateWithoutCommunityRequestInput, CommunityUncheckedCreateWithoutCommunityRequestInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutCommunityRequestInput
    connect?: CommunityWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunityRequestInput = {
    create?: XOR<UserCreateWithoutCommunityRequestInput, UserUncheckedCreateWithoutCommunityRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityRequestInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type CommunityUpdateOneWithoutCommunityRequestNestedInput = {
    create?: XOR<CommunityCreateWithoutCommunityRequestInput, CommunityUncheckedCreateWithoutCommunityRequestInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutCommunityRequestInput
    upsert?: CommunityUpsertWithoutCommunityRequestInput
    disconnect?: CommunityWhereInput | boolean
    delete?: CommunityWhereInput | boolean
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutCommunityRequestInput, CommunityUpdateWithoutCommunityRequestInput>, CommunityUncheckedUpdateWithoutCommunityRequestInput>
  }

  export type UserUpdateOneWithoutCommunityRequestNestedInput = {
    create?: XOR<UserCreateWithoutCommunityRequestInput, UserUncheckedCreateWithoutCommunityRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityRequestInput
    upsert?: UserUpsertWithoutCommunityRequestInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommunityRequestInput, UserUpdateWithoutCommunityRequestInput>, UserUncheckedUpdateWithoutCommunityRequestInput>
  }

  export type UserCreateNestedOneWithoutContextInput = {
    create?: XOR<UserCreateWithoutContextInput, UserUncheckedCreateWithoutContextInput>
    connectOrCreate?: UserCreateOrConnectWithoutContextInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutContextNestedInput = {
    create?: XOR<UserCreateWithoutContextInput, UserUncheckedCreateWithoutContextInput>
    connectOrCreate?: UserCreateOrConnectWithoutContextInput
    upsert?: UserUpsertWithoutContextInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContextInput, UserUpdateWithoutContextInput>, UserUncheckedUpdateWithoutContextInput>
  }

  export type CommunityCreateNestedOneWithoutLeaderboardInput = {
    create?: XOR<CommunityCreateWithoutLeaderboardInput, CommunityUncheckedCreateWithoutLeaderboardInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutLeaderboardInput
    connect?: CommunityWhereUniqueInput
  }

  export type CommunityUpdateOneRequiredWithoutLeaderboardNestedInput = {
    create?: XOR<CommunityCreateWithoutLeaderboardInput, CommunityUncheckedCreateWithoutLeaderboardInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutLeaderboardInput
    upsert?: CommunityUpsertWithoutLeaderboardInput
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutLeaderboardInput, CommunityUpdateWithoutLeaderboardInput>, CommunityUncheckedUpdateWithoutLeaderboardInput>
  }

  export type CommunityCreateNestedOneWithoutLeaderboardEntryInput = {
    create?: XOR<CommunityCreateWithoutLeaderboardEntryInput, CommunityUncheckedCreateWithoutLeaderboardEntryInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutLeaderboardEntryInput
    connect?: CommunityWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLeaderboardEntryInput = {
    create?: XOR<UserCreateWithoutLeaderboardEntryInput, UserUncheckedCreateWithoutLeaderboardEntryInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardEntryInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityUpdateOneWithoutLeaderboardEntryNestedInput = {
    create?: XOR<CommunityCreateWithoutLeaderboardEntryInput, CommunityUncheckedCreateWithoutLeaderboardEntryInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutLeaderboardEntryInput
    upsert?: CommunityUpsertWithoutLeaderboardEntryInput
    disconnect?: CommunityWhereInput | boolean
    delete?: CommunityWhereInput | boolean
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutLeaderboardEntryInput, CommunityUpdateWithoutLeaderboardEntryInput>, CommunityUncheckedUpdateWithoutLeaderboardEntryInput>
  }

  export type UserUpdateOneWithoutLeaderboardEntryNestedInput = {
    create?: XOR<UserCreateWithoutLeaderboardEntryInput, UserUncheckedCreateWithoutLeaderboardEntryInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardEntryInput
    upsert?: UserUpsertWithoutLeaderboardEntryInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaderboardEntryInput, UserUpdateWithoutLeaderboardEntryInput>, UserUncheckedUpdateWithoutLeaderboardEntryInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CommunityCreateNestedOneWithoutPendingPostInput = {
    create?: XOR<CommunityCreateWithoutPendingPostInput, CommunityUncheckedCreateWithoutPendingPostInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutPendingPostInput
    connect?: CommunityWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPendingPostInput = {
    create?: XOR<UserCreateWithoutPendingPostInput, UserUncheckedCreateWithoutPendingPostInput>
    connectOrCreate?: UserCreateOrConnectWithoutPendingPostInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityUpdateOneWithoutPendingPostNestedInput = {
    create?: XOR<CommunityCreateWithoutPendingPostInput, CommunityUncheckedCreateWithoutPendingPostInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutPendingPostInput
    upsert?: CommunityUpsertWithoutPendingPostInput
    disconnect?: CommunityWhereInput | boolean
    delete?: CommunityWhereInput | boolean
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutPendingPostInput, CommunityUpdateWithoutPendingPostInput>, CommunityUncheckedUpdateWithoutPendingPostInput>
  }

  export type UserUpdateOneWithoutPendingPostNestedInput = {
    create?: XOR<UserCreateWithoutPendingPostInput, UserUncheckedCreateWithoutPendingPostInput>
    connectOrCreate?: UserCreateOrConnectWithoutPendingPostInput
    upsert?: UserUpsertWithoutPendingPostInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPendingPostInput, UserUpdateWithoutPendingPostInput>, UserUncheckedUpdateWithoutPendingPostInput>
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommunityCreateNestedOneWithoutPostInput = {
    create?: XOR<CommunityCreateWithoutPostInput, CommunityUncheckedCreateWithoutPostInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutPostInput
    connect?: CommunityWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPostInput = {
    create?: XOR<UserCreateWithoutPostInput, UserUncheckedCreateWithoutPostInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostInput
    connect?: UserWhereUniqueInput
  }

  export type ReportCreateNestedManyWithoutPostInput = {
    create?: XOR<ReportCreateWithoutPostInput, ReportUncheckedCreateWithoutPostInput> | ReportCreateWithoutPostInput[] | ReportUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutPostInput | ReportCreateOrConnectWithoutPostInput[]
    createMany?: ReportCreateManyPostInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<ReportCreateWithoutPostInput, ReportUncheckedCreateWithoutPostInput> | ReportCreateWithoutPostInput[] | ReportUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutPostInput | ReportCreateOrConnectWithoutPostInput[]
    createMany?: ReportCreateManyPostInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommunityUpdateOneWithoutPostNestedInput = {
    create?: XOR<CommunityCreateWithoutPostInput, CommunityUncheckedCreateWithoutPostInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutPostInput
    upsert?: CommunityUpsertWithoutPostInput
    disconnect?: CommunityWhereInput | boolean
    delete?: CommunityWhereInput | boolean
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutPostInput, CommunityUpdateWithoutPostInput>, CommunityUncheckedUpdateWithoutPostInput>
  }

  export type UserUpdateOneWithoutPostNestedInput = {
    create?: XOR<UserCreateWithoutPostInput, UserUncheckedCreateWithoutPostInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostInput
    upsert?: UserUpsertWithoutPostInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostInput, UserUpdateWithoutPostInput>, UserUncheckedUpdateWithoutPostInput>
  }

  export type ReportUpdateManyWithoutPostNestedInput = {
    create?: XOR<ReportCreateWithoutPostInput, ReportUncheckedCreateWithoutPostInput> | ReportCreateWithoutPostInput[] | ReportUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutPostInput | ReportCreateOrConnectWithoutPostInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutPostInput | ReportUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ReportCreateManyPostInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutPostInput | ReportUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutPostInput | ReportUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<ReportCreateWithoutPostInput, ReportUncheckedCreateWithoutPostInput> | ReportCreateWithoutPostInput[] | ReportUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutPostInput | ReportCreateOrConnectWithoutPostInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutPostInput | ReportUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ReportCreateManyPostInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutPostInput | ReportUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutPostInput | ReportUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPreferencesInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    upsert?: UserUpsertWithoutPreferencesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPreferencesInput, UserUpdateWithoutPreferencesInput>, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserCreateNestedOneWithoutRelationship_Relationship_followerToUserInput = {
    create?: XOR<UserCreateWithoutRelationship_Relationship_followerToUserInput, UserUncheckedCreateWithoutRelationship_Relationship_followerToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutRelationship_Relationship_followerToUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRelationship_Relationship_followingToUserInput = {
    create?: XOR<UserCreateWithoutRelationship_Relationship_followingToUserInput, UserUncheckedCreateWithoutRelationship_Relationship_followingToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutRelationship_Relationship_followingToUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutRelationship_Relationship_followerToUserNestedInput = {
    create?: XOR<UserCreateWithoutRelationship_Relationship_followerToUserInput, UserUncheckedCreateWithoutRelationship_Relationship_followerToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutRelationship_Relationship_followerToUserInput
    upsert?: UserUpsertWithoutRelationship_Relationship_followerToUserInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRelationship_Relationship_followerToUserInput, UserUpdateWithoutRelationship_Relationship_followerToUserInput>, UserUncheckedUpdateWithoutRelationship_Relationship_followerToUserInput>
  }

  export type UserUpdateOneWithoutRelationship_Relationship_followingToUserNestedInput = {
    create?: XOR<UserCreateWithoutRelationship_Relationship_followingToUserInput, UserUncheckedCreateWithoutRelationship_Relationship_followingToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutRelationship_Relationship_followingToUserInput
    upsert?: UserUpsertWithoutRelationship_Relationship_followingToUserInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRelationship_Relationship_followingToUserInput, UserUpdateWithoutRelationship_Relationship_followingToUserInput>, UserUncheckedUpdateWithoutRelationship_Relationship_followingToUserInput>
  }

  export type CommunityCreateNestedOneWithoutReportInput = {
    create?: XOR<CommunityCreateWithoutReportInput, CommunityUncheckedCreateWithoutReportInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutReportInput
    connect?: CommunityWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutReportInput = {
    create?: XOR<PostCreateWithoutReportInput, PostUncheckedCreateWithoutReportInput>
    connectOrCreate?: PostCreateOrConnectWithoutReportInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportInput = {
    create?: XOR<UserCreateWithoutReportInput, UserUncheckedCreateWithoutReportInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityUpdateOneWithoutReportNestedInput = {
    create?: XOR<CommunityCreateWithoutReportInput, CommunityUncheckedCreateWithoutReportInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutReportInput
    upsert?: CommunityUpsertWithoutReportInput
    disconnect?: CommunityWhereInput | boolean
    delete?: CommunityWhereInput | boolean
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutReportInput, CommunityUpdateWithoutReportInput>, CommunityUncheckedUpdateWithoutReportInput>
  }

  export type PostUpdateOneWithoutReportNestedInput = {
    create?: XOR<PostCreateWithoutReportInput, PostUncheckedCreateWithoutReportInput>
    connectOrCreate?: PostCreateOrConnectWithoutReportInput
    upsert?: PostUpsertWithoutReportInput
    disconnect?: PostWhereInput | boolean
    delete?: PostWhereInput | boolean
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutReportInput, PostUpdateWithoutReportInput>, PostUncheckedUpdateWithoutReportInput>
  }

  export type UserUpdateOneWithoutReportNestedInput = {
    create?: XOR<UserCreateWithoutReportInput, UserUncheckedCreateWithoutReportInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportInput
    upsert?: UserUpsertWithoutReportInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportInput, UserUpdateWithoutReportInput>, UserUncheckedUpdateWithoutReportInput>
  }

  export type UserCreateNestedOneWithoutTokenInput = {
    create?: XOR<UserCreateWithoutTokenInput, UserUncheckedCreateWithoutTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutTokenNestedInput = {
    create?: XOR<UserCreateWithoutTokenInput, UserUncheckedCreateWithoutTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokenInput
    upsert?: UserUpsertWithoutTokenInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTokenInput, UserUpdateWithoutTokenInput>, UserUncheckedUpdateWithoutTokenInput>
  }

  export type BannedUsersCreateNestedManyWithoutUserInput = {
    create?: XOR<BannedUsersCreateWithoutUserInput, BannedUsersUncheckedCreateWithoutUserInput> | BannedUsersCreateWithoutUserInput[] | BannedUsersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BannedUsersCreateOrConnectWithoutUserInput | BannedUsersCreateOrConnectWithoutUserInput[]
    createMany?: BannedUsersCreateManyUserInputEnvelope
    connect?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
  }

  export type CommunityRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<CommunityRequestCreateWithoutUserInput, CommunityRequestUncheckedCreateWithoutUserInput> | CommunityRequestCreateWithoutUserInput[] | CommunityRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityRequestCreateOrConnectWithoutUserInput | CommunityRequestCreateOrConnectWithoutUserInput[]
    createMany?: CommunityRequestCreateManyUserInputEnvelope
    connect?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
  }

  export type ContextCreateNestedManyWithoutUserInput = {
    create?: XOR<ContextCreateWithoutUserInput, ContextUncheckedCreateWithoutUserInput> | ContextCreateWithoutUserInput[] | ContextUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContextCreateOrConnectWithoutUserInput | ContextCreateOrConnectWithoutUserInput[]
    createMany?: ContextCreateManyUserInputEnvelope
    connect?: ContextWhereUniqueInput | ContextWhereUniqueInput[]
  }

  export type LeaderboardEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
  }

  export type PendingPostCreateNestedManyWithoutUserInput = {
    create?: XOR<PendingPostCreateWithoutUserInput, PendingPostUncheckedCreateWithoutUserInput> | PendingPostCreateWithoutUserInput[] | PendingPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PendingPostCreateOrConnectWithoutUserInput | PendingPostCreateOrConnectWithoutUserInput[]
    createMany?: PendingPostCreateManyUserInputEnvelope
    connect?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutUserInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PreferencesCreateNestedManyWithoutUserInput = {
    create?: XOR<PreferencesCreateWithoutUserInput, PreferencesUncheckedCreateWithoutUserInput> | PreferencesCreateWithoutUserInput[] | PreferencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PreferencesCreateOrConnectWithoutUserInput | PreferencesCreateOrConnectWithoutUserInput[]
    createMany?: PreferencesCreateManyUserInputEnvelope
    connect?: PreferencesWhereUniqueInput | PreferencesWhereUniqueInput[]
  }

  export type RelationshipCreateNestedManyWithoutUser_Relationship_followerToUserInput = {
    create?: XOR<RelationshipCreateWithoutUser_Relationship_followerToUserInput, RelationshipUncheckedCreateWithoutUser_Relationship_followerToUserInput> | RelationshipCreateWithoutUser_Relationship_followerToUserInput[] | RelationshipUncheckedCreateWithoutUser_Relationship_followerToUserInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutUser_Relationship_followerToUserInput | RelationshipCreateOrConnectWithoutUser_Relationship_followerToUserInput[]
    createMany?: RelationshipCreateManyUser_Relationship_followerToUserInputEnvelope
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
  }

  export type RelationshipCreateNestedManyWithoutUser_Relationship_followingToUserInput = {
    create?: XOR<RelationshipCreateWithoutUser_Relationship_followingToUserInput, RelationshipUncheckedCreateWithoutUser_Relationship_followingToUserInput> | RelationshipCreateWithoutUser_Relationship_followingToUserInput[] | RelationshipUncheckedCreateWithoutUser_Relationship_followingToUserInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutUser_Relationship_followingToUserInput | RelationshipCreateOrConnectWithoutUser_Relationship_followingToUserInput[]
    createMany?: RelationshipCreateManyUser_Relationship_followingToUserInputEnvelope
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type TokenCreateNestedManyWithoutUserInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type BannedUsersUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BannedUsersCreateWithoutUserInput, BannedUsersUncheckedCreateWithoutUserInput> | BannedUsersCreateWithoutUserInput[] | BannedUsersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BannedUsersCreateOrConnectWithoutUserInput | BannedUsersCreateOrConnectWithoutUserInput[]
    createMany?: BannedUsersCreateManyUserInputEnvelope
    connect?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
  }

  export type CommunityRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommunityRequestCreateWithoutUserInput, CommunityRequestUncheckedCreateWithoutUserInput> | CommunityRequestCreateWithoutUserInput[] | CommunityRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityRequestCreateOrConnectWithoutUserInput | CommunityRequestCreateOrConnectWithoutUserInput[]
    createMany?: CommunityRequestCreateManyUserInputEnvelope
    connect?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
  }

  export type ContextUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContextCreateWithoutUserInput, ContextUncheckedCreateWithoutUserInput> | ContextCreateWithoutUserInput[] | ContextUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContextCreateOrConnectWithoutUserInput | ContextCreateOrConnectWithoutUserInput[]
    createMany?: ContextCreateManyUserInputEnvelope
    connect?: ContextWhereUniqueInput | ContextWhereUniqueInput[]
  }

  export type LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
  }

  export type PendingPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PendingPostCreateWithoutUserInput, PendingPostUncheckedCreateWithoutUserInput> | PendingPostCreateWithoutUserInput[] | PendingPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PendingPostCreateOrConnectWithoutUserInput | PendingPostCreateOrConnectWithoutUserInput[]
    createMany?: PendingPostCreateManyUserInputEnvelope
    connect?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PreferencesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PreferencesCreateWithoutUserInput, PreferencesUncheckedCreateWithoutUserInput> | PreferencesCreateWithoutUserInput[] | PreferencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PreferencesCreateOrConnectWithoutUserInput | PreferencesCreateOrConnectWithoutUserInput[]
    createMany?: PreferencesCreateManyUserInputEnvelope
    connect?: PreferencesWhereUniqueInput | PreferencesWhereUniqueInput[]
  }

  export type RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followerToUserInput = {
    create?: XOR<RelationshipCreateWithoutUser_Relationship_followerToUserInput, RelationshipUncheckedCreateWithoutUser_Relationship_followerToUserInput> | RelationshipCreateWithoutUser_Relationship_followerToUserInput[] | RelationshipUncheckedCreateWithoutUser_Relationship_followerToUserInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutUser_Relationship_followerToUserInput | RelationshipCreateOrConnectWithoutUser_Relationship_followerToUserInput[]
    createMany?: RelationshipCreateManyUser_Relationship_followerToUserInputEnvelope
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
  }

  export type RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followingToUserInput = {
    create?: XOR<RelationshipCreateWithoutUser_Relationship_followingToUserInput, RelationshipUncheckedCreateWithoutUser_Relationship_followingToUserInput> | RelationshipCreateWithoutUser_Relationship_followingToUserInput[] | RelationshipUncheckedCreateWithoutUser_Relationship_followingToUserInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutUser_Relationship_followingToUserInput | RelationshipCreateOrConnectWithoutUser_Relationship_followingToUserInput[]
    createMany?: RelationshipCreateManyUser_Relationship_followingToUserInputEnvelope
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type TokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BannedUsersUpdateManyWithoutUserNestedInput = {
    create?: XOR<BannedUsersCreateWithoutUserInput, BannedUsersUncheckedCreateWithoutUserInput> | BannedUsersCreateWithoutUserInput[] | BannedUsersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BannedUsersCreateOrConnectWithoutUserInput | BannedUsersCreateOrConnectWithoutUserInput[]
    upsert?: BannedUsersUpsertWithWhereUniqueWithoutUserInput | BannedUsersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BannedUsersCreateManyUserInputEnvelope
    set?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    disconnect?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    delete?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    connect?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    update?: BannedUsersUpdateWithWhereUniqueWithoutUserInput | BannedUsersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BannedUsersUpdateManyWithWhereWithoutUserInput | BannedUsersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BannedUsersScalarWhereInput | BannedUsersScalarWhereInput[]
  }

  export type CommunityRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommunityRequestCreateWithoutUserInput, CommunityRequestUncheckedCreateWithoutUserInput> | CommunityRequestCreateWithoutUserInput[] | CommunityRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityRequestCreateOrConnectWithoutUserInput | CommunityRequestCreateOrConnectWithoutUserInput[]
    upsert?: CommunityRequestUpsertWithWhereUniqueWithoutUserInput | CommunityRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommunityRequestCreateManyUserInputEnvelope
    set?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    disconnect?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    delete?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    connect?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    update?: CommunityRequestUpdateWithWhereUniqueWithoutUserInput | CommunityRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommunityRequestUpdateManyWithWhereWithoutUserInput | CommunityRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommunityRequestScalarWhereInput | CommunityRequestScalarWhereInput[]
  }

  export type ContextUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContextCreateWithoutUserInput, ContextUncheckedCreateWithoutUserInput> | ContextCreateWithoutUserInput[] | ContextUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContextCreateOrConnectWithoutUserInput | ContextCreateOrConnectWithoutUserInput[]
    upsert?: ContextUpsertWithWhereUniqueWithoutUserInput | ContextUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContextCreateManyUserInputEnvelope
    set?: ContextWhereUniqueInput | ContextWhereUniqueInput[]
    disconnect?: ContextWhereUniqueInput | ContextWhereUniqueInput[]
    delete?: ContextWhereUniqueInput | ContextWhereUniqueInput[]
    connect?: ContextWhereUniqueInput | ContextWhereUniqueInput[]
    update?: ContextUpdateWithWhereUniqueWithoutUserInput | ContextUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContextUpdateManyWithWhereWithoutUserInput | ContextUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContextScalarWhereInput | ContextScalarWhereInput[]
  }

  export type LeaderboardEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    upsert?: LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput | LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    disconnect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    delete?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    update?: LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput | LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaderboardEntryUpdateManyWithWhereWithoutUserInput | LeaderboardEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
  }

  export type PendingPostUpdateManyWithoutUserNestedInput = {
    create?: XOR<PendingPostCreateWithoutUserInput, PendingPostUncheckedCreateWithoutUserInput> | PendingPostCreateWithoutUserInput[] | PendingPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PendingPostCreateOrConnectWithoutUserInput | PendingPostCreateOrConnectWithoutUserInput[]
    upsert?: PendingPostUpsertWithWhereUniqueWithoutUserInput | PendingPostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PendingPostCreateManyUserInputEnvelope
    set?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    disconnect?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    delete?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    connect?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    update?: PendingPostUpdateWithWhereUniqueWithoutUserInput | PendingPostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PendingPostUpdateManyWithWhereWithoutUserInput | PendingPostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PendingPostScalarWhereInput | PendingPostScalarWhereInput[]
  }

  export type PostUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutUserInput | PostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutUserInput | PostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpdateManyWithWhereWithoutUserInput | PostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PreferencesUpdateManyWithoutUserNestedInput = {
    create?: XOR<PreferencesCreateWithoutUserInput, PreferencesUncheckedCreateWithoutUserInput> | PreferencesCreateWithoutUserInput[] | PreferencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PreferencesCreateOrConnectWithoutUserInput | PreferencesCreateOrConnectWithoutUserInput[]
    upsert?: PreferencesUpsertWithWhereUniqueWithoutUserInput | PreferencesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PreferencesCreateManyUserInputEnvelope
    set?: PreferencesWhereUniqueInput | PreferencesWhereUniqueInput[]
    disconnect?: PreferencesWhereUniqueInput | PreferencesWhereUniqueInput[]
    delete?: PreferencesWhereUniqueInput | PreferencesWhereUniqueInput[]
    connect?: PreferencesWhereUniqueInput | PreferencesWhereUniqueInput[]
    update?: PreferencesUpdateWithWhereUniqueWithoutUserInput | PreferencesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PreferencesUpdateManyWithWhereWithoutUserInput | PreferencesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PreferencesScalarWhereInput | PreferencesScalarWhereInput[]
  }

  export type RelationshipUpdateManyWithoutUser_Relationship_followerToUserNestedInput = {
    create?: XOR<RelationshipCreateWithoutUser_Relationship_followerToUserInput, RelationshipUncheckedCreateWithoutUser_Relationship_followerToUserInput> | RelationshipCreateWithoutUser_Relationship_followerToUserInput[] | RelationshipUncheckedCreateWithoutUser_Relationship_followerToUserInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutUser_Relationship_followerToUserInput | RelationshipCreateOrConnectWithoutUser_Relationship_followerToUserInput[]
    upsert?: RelationshipUpsertWithWhereUniqueWithoutUser_Relationship_followerToUserInput | RelationshipUpsertWithWhereUniqueWithoutUser_Relationship_followerToUserInput[]
    createMany?: RelationshipCreateManyUser_Relationship_followerToUserInputEnvelope
    set?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    disconnect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    delete?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    update?: RelationshipUpdateWithWhereUniqueWithoutUser_Relationship_followerToUserInput | RelationshipUpdateWithWhereUniqueWithoutUser_Relationship_followerToUserInput[]
    updateMany?: RelationshipUpdateManyWithWhereWithoutUser_Relationship_followerToUserInput | RelationshipUpdateManyWithWhereWithoutUser_Relationship_followerToUserInput[]
    deleteMany?: RelationshipScalarWhereInput | RelationshipScalarWhereInput[]
  }

  export type RelationshipUpdateManyWithoutUser_Relationship_followingToUserNestedInput = {
    create?: XOR<RelationshipCreateWithoutUser_Relationship_followingToUserInput, RelationshipUncheckedCreateWithoutUser_Relationship_followingToUserInput> | RelationshipCreateWithoutUser_Relationship_followingToUserInput[] | RelationshipUncheckedCreateWithoutUser_Relationship_followingToUserInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutUser_Relationship_followingToUserInput | RelationshipCreateOrConnectWithoutUser_Relationship_followingToUserInput[]
    upsert?: RelationshipUpsertWithWhereUniqueWithoutUser_Relationship_followingToUserInput | RelationshipUpsertWithWhereUniqueWithoutUser_Relationship_followingToUserInput[]
    createMany?: RelationshipCreateManyUser_Relationship_followingToUserInputEnvelope
    set?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    disconnect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    delete?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    update?: RelationshipUpdateWithWhereUniqueWithoutUser_Relationship_followingToUserInput | RelationshipUpdateWithWhereUniqueWithoutUser_Relationship_followingToUserInput[]
    updateMany?: RelationshipUpdateManyWithWhereWithoutUser_Relationship_followingToUserInput | RelationshipUpdateManyWithWhereWithoutUser_Relationship_followingToUserInput[]
    deleteMany?: RelationshipScalarWhereInput | RelationshipScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutUserInput | ReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutUserInput | ReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutUserInput | ReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type TokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutUserInput | TokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutUserInput | TokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutUserInput | TokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type BannedUsersUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BannedUsersCreateWithoutUserInput, BannedUsersUncheckedCreateWithoutUserInput> | BannedUsersCreateWithoutUserInput[] | BannedUsersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BannedUsersCreateOrConnectWithoutUserInput | BannedUsersCreateOrConnectWithoutUserInput[]
    upsert?: BannedUsersUpsertWithWhereUniqueWithoutUserInput | BannedUsersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BannedUsersCreateManyUserInputEnvelope
    set?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    disconnect?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    delete?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    connect?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    update?: BannedUsersUpdateWithWhereUniqueWithoutUserInput | BannedUsersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BannedUsersUpdateManyWithWhereWithoutUserInput | BannedUsersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BannedUsersScalarWhereInput | BannedUsersScalarWhereInput[]
  }

  export type CommunityRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommunityRequestCreateWithoutUserInput, CommunityRequestUncheckedCreateWithoutUserInput> | CommunityRequestCreateWithoutUserInput[] | CommunityRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityRequestCreateOrConnectWithoutUserInput | CommunityRequestCreateOrConnectWithoutUserInput[]
    upsert?: CommunityRequestUpsertWithWhereUniqueWithoutUserInput | CommunityRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommunityRequestCreateManyUserInputEnvelope
    set?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    disconnect?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    delete?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    connect?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    update?: CommunityRequestUpdateWithWhereUniqueWithoutUserInput | CommunityRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommunityRequestUpdateManyWithWhereWithoutUserInput | CommunityRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommunityRequestScalarWhereInput | CommunityRequestScalarWhereInput[]
  }

  export type ContextUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContextCreateWithoutUserInput, ContextUncheckedCreateWithoutUserInput> | ContextCreateWithoutUserInput[] | ContextUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContextCreateOrConnectWithoutUserInput | ContextCreateOrConnectWithoutUserInput[]
    upsert?: ContextUpsertWithWhereUniqueWithoutUserInput | ContextUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContextCreateManyUserInputEnvelope
    set?: ContextWhereUniqueInput | ContextWhereUniqueInput[]
    disconnect?: ContextWhereUniqueInput | ContextWhereUniqueInput[]
    delete?: ContextWhereUniqueInput | ContextWhereUniqueInput[]
    connect?: ContextWhereUniqueInput | ContextWhereUniqueInput[]
    update?: ContextUpdateWithWhereUniqueWithoutUserInput | ContextUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContextUpdateManyWithWhereWithoutUserInput | ContextUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContextScalarWhereInput | ContextScalarWhereInput[]
  }

  export type LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    upsert?: LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput | LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    disconnect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    delete?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    update?: LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput | LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaderboardEntryUpdateManyWithWhereWithoutUserInput | LeaderboardEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
  }

  export type PendingPostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PendingPostCreateWithoutUserInput, PendingPostUncheckedCreateWithoutUserInput> | PendingPostCreateWithoutUserInput[] | PendingPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PendingPostCreateOrConnectWithoutUserInput | PendingPostCreateOrConnectWithoutUserInput[]
    upsert?: PendingPostUpsertWithWhereUniqueWithoutUserInput | PendingPostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PendingPostCreateManyUserInputEnvelope
    set?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    disconnect?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    delete?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    connect?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    update?: PendingPostUpdateWithWhereUniqueWithoutUserInput | PendingPostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PendingPostUpdateManyWithWhereWithoutUserInput | PendingPostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PendingPostScalarWhereInput | PendingPostScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutUserInput | PostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutUserInput | PostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpdateManyWithWhereWithoutUserInput | PostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PreferencesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PreferencesCreateWithoutUserInput, PreferencesUncheckedCreateWithoutUserInput> | PreferencesCreateWithoutUserInput[] | PreferencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PreferencesCreateOrConnectWithoutUserInput | PreferencesCreateOrConnectWithoutUserInput[]
    upsert?: PreferencesUpsertWithWhereUniqueWithoutUserInput | PreferencesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PreferencesCreateManyUserInputEnvelope
    set?: PreferencesWhereUniqueInput | PreferencesWhereUniqueInput[]
    disconnect?: PreferencesWhereUniqueInput | PreferencesWhereUniqueInput[]
    delete?: PreferencesWhereUniqueInput | PreferencesWhereUniqueInput[]
    connect?: PreferencesWhereUniqueInput | PreferencesWhereUniqueInput[]
    update?: PreferencesUpdateWithWhereUniqueWithoutUserInput | PreferencesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PreferencesUpdateManyWithWhereWithoutUserInput | PreferencesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PreferencesScalarWhereInput | PreferencesScalarWhereInput[]
  }

  export type RelationshipUncheckedUpdateManyWithoutUser_Relationship_followerToUserNestedInput = {
    create?: XOR<RelationshipCreateWithoutUser_Relationship_followerToUserInput, RelationshipUncheckedCreateWithoutUser_Relationship_followerToUserInput> | RelationshipCreateWithoutUser_Relationship_followerToUserInput[] | RelationshipUncheckedCreateWithoutUser_Relationship_followerToUserInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutUser_Relationship_followerToUserInput | RelationshipCreateOrConnectWithoutUser_Relationship_followerToUserInput[]
    upsert?: RelationshipUpsertWithWhereUniqueWithoutUser_Relationship_followerToUserInput | RelationshipUpsertWithWhereUniqueWithoutUser_Relationship_followerToUserInput[]
    createMany?: RelationshipCreateManyUser_Relationship_followerToUserInputEnvelope
    set?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    disconnect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    delete?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    update?: RelationshipUpdateWithWhereUniqueWithoutUser_Relationship_followerToUserInput | RelationshipUpdateWithWhereUniqueWithoutUser_Relationship_followerToUserInput[]
    updateMany?: RelationshipUpdateManyWithWhereWithoutUser_Relationship_followerToUserInput | RelationshipUpdateManyWithWhereWithoutUser_Relationship_followerToUserInput[]
    deleteMany?: RelationshipScalarWhereInput | RelationshipScalarWhereInput[]
  }

  export type RelationshipUncheckedUpdateManyWithoutUser_Relationship_followingToUserNestedInput = {
    create?: XOR<RelationshipCreateWithoutUser_Relationship_followingToUserInput, RelationshipUncheckedCreateWithoutUser_Relationship_followingToUserInput> | RelationshipCreateWithoutUser_Relationship_followingToUserInput[] | RelationshipUncheckedCreateWithoutUser_Relationship_followingToUserInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutUser_Relationship_followingToUserInput | RelationshipCreateOrConnectWithoutUser_Relationship_followingToUserInput[]
    upsert?: RelationshipUpsertWithWhereUniqueWithoutUser_Relationship_followingToUserInput | RelationshipUpsertWithWhereUniqueWithoutUser_Relationship_followingToUserInput[]
    createMany?: RelationshipCreateManyUser_Relationship_followingToUserInputEnvelope
    set?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    disconnect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    delete?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    update?: RelationshipUpdateWithWhereUniqueWithoutUser_Relationship_followingToUserInput | RelationshipUpdateWithWhereUniqueWithoutUser_Relationship_followingToUserInput[]
    updateMany?: RelationshipUpdateManyWithWhereWithoutUser_Relationship_followingToUserInput | RelationshipUpdateManyWithWhereWithoutUser_Relationship_followingToUserInput[]
    deleteMany?: RelationshipScalarWhereInput | RelationshipScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutUserInput | ReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutUserInput | ReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutUserInput | ReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type TokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutUserInput | TokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutUserInput | TokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutUserInput | TokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CommunityCreateWithoutBannedUsersInput = {
    name?: string | null
    description?: string | null
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutCommunityInput
    Leaderboard?: LeaderboardCreateNestedManyWithoutCommunityInput
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutCommunityInput
    PendingPost?: PendingPostCreateNestedManyWithoutCommunityInput
    Post?: PostCreateNestedManyWithoutCommunityInput
    Report?: ReportCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutBannedUsersInput = {
    id?: number
    name?: string | null
    description?: string | null
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutCommunityInput
    Leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutCommunityInput
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutCommunityInput
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutCommunityInput
    Post?: PostUncheckedCreateNestedManyWithoutCommunityInput
    Report?: ReportUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutBannedUsersInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutBannedUsersInput, CommunityUncheckedCreateWithoutBannedUsersInput>
  }

  export type UserCreateWithoutBannedUsersInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutUserInput
    Context?: ContextCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
    Preferences?: PreferencesCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Token?: TokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBannedUsersInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutUserInput
    Context?: ContextUncheckedCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
    Preferences?: PreferencesUncheckedCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBannedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBannedUsersInput, UserUncheckedCreateWithoutBannedUsersInput>
  }

  export type CommunityUpsertWithoutBannedUsersInput = {
    update: XOR<CommunityUpdateWithoutBannedUsersInput, CommunityUncheckedUpdateWithoutBannedUsersInput>
    create: XOR<CommunityCreateWithoutBannedUsersInput, CommunityUncheckedCreateWithoutBannedUsersInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutBannedUsersInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutBannedUsersInput, CommunityUncheckedUpdateWithoutBannedUsersInput>
  }

  export type CommunityUpdateWithoutBannedUsersInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    CommunityRequest?: CommunityRequestUpdateManyWithoutCommunityNestedInput
    Leaderboard?: LeaderboardUpdateManyWithoutCommunityNestedInput
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutCommunityNestedInput
    PendingPost?: PendingPostUpdateManyWithoutCommunityNestedInput
    Post?: PostUpdateManyWithoutCommunityNestedInput
    Report?: ReportUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutBannedUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutCommunityNestedInput
    Leaderboard?: LeaderboardUncheckedUpdateManyWithoutCommunityNestedInput
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutCommunityNestedInput
    PendingPost?: PendingPostUncheckedUpdateManyWithoutCommunityNestedInput
    Post?: PostUncheckedUpdateManyWithoutCommunityNestedInput
    Report?: ReportUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type UserUpsertWithoutBannedUsersInput = {
    update: XOR<UserUpdateWithoutBannedUsersInput, UserUncheckedUpdateWithoutBannedUsersInput>
    create: XOR<UserCreateWithoutBannedUsersInput, UserUncheckedCreateWithoutBannedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBannedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBannedUsersInput, UserUncheckedUpdateWithoutBannedUsersInput>
  }

  export type UserUpdateWithoutBannedUsersInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    CommunityRequest?: CommunityRequestUpdateManyWithoutUserNestedInput
    Context?: ContextUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Token?: TokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBannedUsersInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutUserNestedInput
    Context?: ContextUncheckedUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUncheckedUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostCreateWithoutCommentInput = {
    Content?: string | null
    fileUrl?: string | null
    caption?: string | null
    Community?: CommunityCreateNestedOneWithoutPostInput
    User?: UserCreateNestedOneWithoutPostInput
    Report?: ReportCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutCommentInput = {
    id?: number
    Content?: string | null
    fileUrl?: string | null
    community?: number | null
    user?: string | null
    caption?: string | null
    Report?: ReportUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommentInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentInput, PostUncheckedCreateWithoutCommentInput>
  }

  export type PostUpsertWithoutCommentInput = {
    update: XOR<PostUpdateWithoutCommentInput, PostUncheckedUpdateWithoutCommentInput>
    create: XOR<PostCreateWithoutCommentInput, PostUncheckedCreateWithoutCommentInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentInput, PostUncheckedUpdateWithoutCommentInput>
  }

  export type PostUpdateWithoutCommentInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Community?: CommunityUpdateOneWithoutPostNestedInput
    User?: UserUpdateOneWithoutPostNestedInput
    Report?: ReportUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Report?: ReportUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BannedUsersCreateWithoutCommunityInput = {
    User: UserCreateNestedOneWithoutBannedUsersInput
  }

  export type BannedUsersUncheckedCreateWithoutCommunityInput = {
    id?: number
    user: string
  }

  export type BannedUsersCreateOrConnectWithoutCommunityInput = {
    where: BannedUsersWhereUniqueInput
    create: XOR<BannedUsersCreateWithoutCommunityInput, BannedUsersUncheckedCreateWithoutCommunityInput>
  }

  export type BannedUsersCreateManyCommunityInputEnvelope = {
    data: BannedUsersCreateManyCommunityInput | BannedUsersCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type CommunityRequestCreateWithoutCommunityInput = {
    isVerified?: boolean | null
    isRequested?: boolean | null
    User?: UserCreateNestedOneWithoutCommunityRequestInput
  }

  export type CommunityRequestUncheckedCreateWithoutCommunityInput = {
    id?: number
    user?: string | null
    isVerified?: boolean | null
    isRequested?: boolean | null
  }

  export type CommunityRequestCreateOrConnectWithoutCommunityInput = {
    where: CommunityRequestWhereUniqueInput
    create: XOR<CommunityRequestCreateWithoutCommunityInput, CommunityRequestUncheckedCreateWithoutCommunityInput>
  }

  export type CommunityRequestCreateManyCommunityInputEnvelope = {
    data: CommunityRequestCreateManyCommunityInput | CommunityRequestCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type LeaderboardCreateWithoutCommunityInput = {
    tracking?: string | null
  }

  export type LeaderboardUncheckedCreateWithoutCommunityInput = {
    id?: number
    tracking?: string | null
  }

  export type LeaderboardCreateOrConnectWithoutCommunityInput = {
    where: LeaderboardWhereUniqueInput
    create: XOR<LeaderboardCreateWithoutCommunityInput, LeaderboardUncheckedCreateWithoutCommunityInput>
  }

  export type LeaderboardCreateManyCommunityInputEnvelope = {
    data: LeaderboardCreateManyCommunityInput | LeaderboardCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type LeaderboardEntryCreateWithoutCommunityInput = {
    entryUrl?: string | null
    verifiedBy?: number | null
    isVerified?: boolean | null
    rank?: number | null
    User?: UserCreateNestedOneWithoutLeaderboardEntryInput
  }

  export type LeaderboardEntryUncheckedCreateWithoutCommunityInput = {
    id?: number
    user?: string | null
    entryUrl?: string | null
    verifiedBy?: number | null
    isVerified?: boolean | null
    rank?: number | null
  }

  export type LeaderboardEntryCreateOrConnectWithoutCommunityInput = {
    where: LeaderboardEntryWhereUniqueInput
    create: XOR<LeaderboardEntryCreateWithoutCommunityInput, LeaderboardEntryUncheckedCreateWithoutCommunityInput>
  }

  export type LeaderboardEntryCreateManyCommunityInputEnvelope = {
    data: LeaderboardEntryCreateManyCommunityInput | LeaderboardEntryCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type PendingPostCreateWithoutCommunityInput = {
    Content?: string | null
    fileUrl?: string | null
    caption?: string | null
    status?: string | null
    confirmationToken?: string | null
    User?: UserCreateNestedOneWithoutPendingPostInput
  }

  export type PendingPostUncheckedCreateWithoutCommunityInput = {
    id?: number
    Content?: string | null
    fileUrl?: string | null
    user?: string | null
    caption?: string | null
    status?: string | null
    confirmationToken?: string | null
  }

  export type PendingPostCreateOrConnectWithoutCommunityInput = {
    where: PendingPostWhereUniqueInput
    create: XOR<PendingPostCreateWithoutCommunityInput, PendingPostUncheckedCreateWithoutCommunityInput>
  }

  export type PendingPostCreateManyCommunityInputEnvelope = {
    data: PendingPostCreateManyCommunityInput | PendingPostCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutCommunityInput = {
    Content?: string | null
    fileUrl?: string | null
    caption?: string | null
    Comment?: CommentCreateNestedManyWithoutPostInput
    User?: UserCreateNestedOneWithoutPostInput
    Report?: ReportCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutCommunityInput = {
    id?: number
    Content?: string | null
    fileUrl?: string | null
    user?: string | null
    caption?: string | null
    Comment?: CommentUncheckedCreateNestedManyWithoutPostInput
    Report?: ReportUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommunityInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput>
  }

  export type PostCreateManyCommunityInputEnvelope = {
    data: PostCreateManyCommunityInput | PostCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutCommunityInput = {
    reportReason?: string | null
    reportDate?: Date | string | null
    Post?: PostCreateNestedOneWithoutReportInput
    User?: UserCreateNestedOneWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutCommunityInput = {
    id?: number
    reportedBy?: string | null
    post?: number | null
    reportReason?: string | null
    reportDate?: Date | string | null
  }

  export type ReportCreateOrConnectWithoutCommunityInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutCommunityInput, ReportUncheckedCreateWithoutCommunityInput>
  }

  export type ReportCreateManyCommunityInputEnvelope = {
    data: ReportCreateManyCommunityInput | ReportCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type BannedUsersUpsertWithWhereUniqueWithoutCommunityInput = {
    where: BannedUsersWhereUniqueInput
    update: XOR<BannedUsersUpdateWithoutCommunityInput, BannedUsersUncheckedUpdateWithoutCommunityInput>
    create: XOR<BannedUsersCreateWithoutCommunityInput, BannedUsersUncheckedCreateWithoutCommunityInput>
  }

  export type BannedUsersUpdateWithWhereUniqueWithoutCommunityInput = {
    where: BannedUsersWhereUniqueInput
    data: XOR<BannedUsersUpdateWithoutCommunityInput, BannedUsersUncheckedUpdateWithoutCommunityInput>
  }

  export type BannedUsersUpdateManyWithWhereWithoutCommunityInput = {
    where: BannedUsersScalarWhereInput
    data: XOR<BannedUsersUpdateManyMutationInput, BannedUsersUncheckedUpdateManyWithoutCommunityInput>
  }

  export type BannedUsersScalarWhereInput = {
    AND?: BannedUsersScalarWhereInput | BannedUsersScalarWhereInput[]
    OR?: BannedUsersScalarWhereInput[]
    NOT?: BannedUsersScalarWhereInput | BannedUsersScalarWhereInput[]
    id?: IntFilter<"BannedUsers"> | number
    community?: IntFilter<"BannedUsers"> | number
    user?: StringFilter<"BannedUsers"> | string
  }

  export type CommunityRequestUpsertWithWhereUniqueWithoutCommunityInput = {
    where: CommunityRequestWhereUniqueInput
    update: XOR<CommunityRequestUpdateWithoutCommunityInput, CommunityRequestUncheckedUpdateWithoutCommunityInput>
    create: XOR<CommunityRequestCreateWithoutCommunityInput, CommunityRequestUncheckedCreateWithoutCommunityInput>
  }

  export type CommunityRequestUpdateWithWhereUniqueWithoutCommunityInput = {
    where: CommunityRequestWhereUniqueInput
    data: XOR<CommunityRequestUpdateWithoutCommunityInput, CommunityRequestUncheckedUpdateWithoutCommunityInput>
  }

  export type CommunityRequestUpdateManyWithWhereWithoutCommunityInput = {
    where: CommunityRequestScalarWhereInput
    data: XOR<CommunityRequestUpdateManyMutationInput, CommunityRequestUncheckedUpdateManyWithoutCommunityInput>
  }

  export type CommunityRequestScalarWhereInput = {
    AND?: CommunityRequestScalarWhereInput | CommunityRequestScalarWhereInput[]
    OR?: CommunityRequestScalarWhereInput[]
    NOT?: CommunityRequestScalarWhereInput | CommunityRequestScalarWhereInput[]
    id?: IntFilter<"CommunityRequest"> | number
    user?: StringNullableFilter<"CommunityRequest"> | string | null
    community?: IntNullableFilter<"CommunityRequest"> | number | null
    isVerified?: BoolNullableFilter<"CommunityRequest"> | boolean | null
    isRequested?: BoolNullableFilter<"CommunityRequest"> | boolean | null
  }

  export type LeaderboardUpsertWithWhereUniqueWithoutCommunityInput = {
    where: LeaderboardWhereUniqueInput
    update: XOR<LeaderboardUpdateWithoutCommunityInput, LeaderboardUncheckedUpdateWithoutCommunityInput>
    create: XOR<LeaderboardCreateWithoutCommunityInput, LeaderboardUncheckedCreateWithoutCommunityInput>
  }

  export type LeaderboardUpdateWithWhereUniqueWithoutCommunityInput = {
    where: LeaderboardWhereUniqueInput
    data: XOR<LeaderboardUpdateWithoutCommunityInput, LeaderboardUncheckedUpdateWithoutCommunityInput>
  }

  export type LeaderboardUpdateManyWithWhereWithoutCommunityInput = {
    where: LeaderboardScalarWhereInput
    data: XOR<LeaderboardUpdateManyMutationInput, LeaderboardUncheckedUpdateManyWithoutCommunityInput>
  }

  export type LeaderboardScalarWhereInput = {
    AND?: LeaderboardScalarWhereInput | LeaderboardScalarWhereInput[]
    OR?: LeaderboardScalarWhereInput[]
    NOT?: LeaderboardScalarWhereInput | LeaderboardScalarWhereInput[]
    id?: IntFilter<"Leaderboard"> | number
    community?: IntFilter<"Leaderboard"> | number
    tracking?: StringNullableFilter<"Leaderboard"> | string | null
  }

  export type LeaderboardEntryUpsertWithWhereUniqueWithoutCommunityInput = {
    where: LeaderboardEntryWhereUniqueInput
    update: XOR<LeaderboardEntryUpdateWithoutCommunityInput, LeaderboardEntryUncheckedUpdateWithoutCommunityInput>
    create: XOR<LeaderboardEntryCreateWithoutCommunityInput, LeaderboardEntryUncheckedCreateWithoutCommunityInput>
  }

  export type LeaderboardEntryUpdateWithWhereUniqueWithoutCommunityInput = {
    where: LeaderboardEntryWhereUniqueInput
    data: XOR<LeaderboardEntryUpdateWithoutCommunityInput, LeaderboardEntryUncheckedUpdateWithoutCommunityInput>
  }

  export type LeaderboardEntryUpdateManyWithWhereWithoutCommunityInput = {
    where: LeaderboardEntryScalarWhereInput
    data: XOR<LeaderboardEntryUpdateManyMutationInput, LeaderboardEntryUncheckedUpdateManyWithoutCommunityInput>
  }

  export type LeaderboardEntryScalarWhereInput = {
    AND?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
    OR?: LeaderboardEntryScalarWhereInput[]
    NOT?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
    id?: IntFilter<"LeaderboardEntry"> | number
    user?: StringNullableFilter<"LeaderboardEntry"> | string | null
    community?: IntNullableFilter<"LeaderboardEntry"> | number | null
    entryUrl?: StringNullableFilter<"LeaderboardEntry"> | string | null
    verifiedBy?: IntNullableFilter<"LeaderboardEntry"> | number | null
    isVerified?: BoolNullableFilter<"LeaderboardEntry"> | boolean | null
    rank?: IntNullableFilter<"LeaderboardEntry"> | number | null
  }

  export type PendingPostUpsertWithWhereUniqueWithoutCommunityInput = {
    where: PendingPostWhereUniqueInput
    update: XOR<PendingPostUpdateWithoutCommunityInput, PendingPostUncheckedUpdateWithoutCommunityInput>
    create: XOR<PendingPostCreateWithoutCommunityInput, PendingPostUncheckedCreateWithoutCommunityInput>
  }

  export type PendingPostUpdateWithWhereUniqueWithoutCommunityInput = {
    where: PendingPostWhereUniqueInput
    data: XOR<PendingPostUpdateWithoutCommunityInput, PendingPostUncheckedUpdateWithoutCommunityInput>
  }

  export type PendingPostUpdateManyWithWhereWithoutCommunityInput = {
    where: PendingPostScalarWhereInput
    data: XOR<PendingPostUpdateManyMutationInput, PendingPostUncheckedUpdateManyWithoutCommunityInput>
  }

  export type PendingPostScalarWhereInput = {
    AND?: PendingPostScalarWhereInput | PendingPostScalarWhereInput[]
    OR?: PendingPostScalarWhereInput[]
    NOT?: PendingPostScalarWhereInput | PendingPostScalarWhereInput[]
    id?: IntFilter<"PendingPost"> | number
    Content?: StringNullableFilter<"PendingPost"> | string | null
    fileUrl?: StringNullableFilter<"PendingPost"> | string | null
    community?: IntNullableFilter<"PendingPost"> | number | null
    user?: StringNullableFilter<"PendingPost"> | string | null
    caption?: StringNullableFilter<"PendingPost"> | string | null
    status?: StringNullableFilter<"PendingPost"> | string | null
    confirmationToken?: StringNullableFilter<"PendingPost"> | string | null
  }

  export type PostUpsertWithWhereUniqueWithoutCommunityInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutCommunityInput, PostUncheckedUpdateWithoutCommunityInput>
    create: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput>
  }

  export type PostUpdateWithWhereUniqueWithoutCommunityInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutCommunityInput, PostUncheckedUpdateWithoutCommunityInput>
  }

  export type PostUpdateManyWithWhereWithoutCommunityInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutCommunityInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: IntFilter<"Post"> | number
    Content?: StringNullableFilter<"Post"> | string | null
    fileUrl?: StringNullableFilter<"Post"> | string | null
    community?: IntNullableFilter<"Post"> | number | null
    user?: StringNullableFilter<"Post"> | string | null
    caption?: StringNullableFilter<"Post"> | string | null
  }

  export type ReportUpsertWithWhereUniqueWithoutCommunityInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutCommunityInput, ReportUncheckedUpdateWithoutCommunityInput>
    create: XOR<ReportCreateWithoutCommunityInput, ReportUncheckedCreateWithoutCommunityInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutCommunityInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutCommunityInput, ReportUncheckedUpdateWithoutCommunityInput>
  }

  export type ReportUpdateManyWithWhereWithoutCommunityInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutCommunityInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: IntFilter<"Report"> | number
    reportedBy?: StringNullableFilter<"Report"> | string | null
    post?: IntNullableFilter<"Report"> | number | null
    community?: IntNullableFilter<"Report"> | number | null
    reportReason?: StringNullableFilter<"Report"> | string | null
    reportDate?: DateTimeNullableFilter<"Report"> | Date | string | null
  }

  export type CommunityCreateWithoutCommunityRequestInput = {
    name?: string | null
    description?: string | null
    BannedUsers?: BannedUsersCreateNestedManyWithoutCommunityInput
    Leaderboard?: LeaderboardCreateNestedManyWithoutCommunityInput
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutCommunityInput
    PendingPost?: PendingPostCreateNestedManyWithoutCommunityInput
    Post?: PostCreateNestedManyWithoutCommunityInput
    Report?: ReportCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutCommunityRequestInput = {
    id?: number
    name?: string | null
    description?: string | null
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutCommunityInput
    Leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutCommunityInput
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutCommunityInput
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutCommunityInput
    Post?: PostUncheckedCreateNestedManyWithoutCommunityInput
    Report?: ReportUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutCommunityRequestInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutCommunityRequestInput, CommunityUncheckedCreateWithoutCommunityRequestInput>
  }

  export type UserCreateWithoutCommunityRequestInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersCreateNestedManyWithoutUserInput
    Context?: ContextCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
    Preferences?: PreferencesCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Token?: TokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityRequestInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutUserInput
    Context?: ContextUncheckedCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
    Preferences?: PreferencesUncheckedCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommunityRequestInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunityRequestInput, UserUncheckedCreateWithoutCommunityRequestInput>
  }

  export type CommunityUpsertWithoutCommunityRequestInput = {
    update: XOR<CommunityUpdateWithoutCommunityRequestInput, CommunityUncheckedUpdateWithoutCommunityRequestInput>
    create: XOR<CommunityCreateWithoutCommunityRequestInput, CommunityUncheckedCreateWithoutCommunityRequestInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutCommunityRequestInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutCommunityRequestInput, CommunityUncheckedUpdateWithoutCommunityRequestInput>
  }

  export type CommunityUpdateWithoutCommunityRequestInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    BannedUsers?: BannedUsersUpdateManyWithoutCommunityNestedInput
    Leaderboard?: LeaderboardUpdateManyWithoutCommunityNestedInput
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutCommunityNestedInput
    PendingPost?: PendingPostUpdateManyWithoutCommunityNestedInput
    Post?: PostUpdateManyWithoutCommunityNestedInput
    Report?: ReportUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutCommunityRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutCommunityNestedInput
    Leaderboard?: LeaderboardUncheckedUpdateManyWithoutCommunityNestedInput
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutCommunityNestedInput
    PendingPost?: PendingPostUncheckedUpdateManyWithoutCommunityNestedInput
    Post?: PostUncheckedUpdateManyWithoutCommunityNestedInput
    Report?: ReportUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type UserUpsertWithoutCommunityRequestInput = {
    update: XOR<UserUpdateWithoutCommunityRequestInput, UserUncheckedUpdateWithoutCommunityRequestInput>
    create: XOR<UserCreateWithoutCommunityRequestInput, UserUncheckedCreateWithoutCommunityRequestInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommunityRequestInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommunityRequestInput, UserUncheckedUpdateWithoutCommunityRequestInput>
  }

  export type UserUpdateWithoutCommunityRequestInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUpdateManyWithoutUserNestedInput
    Context?: ContextUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Token?: TokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommunityRequestInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutUserNestedInput
    Context?: ContextUncheckedUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUncheckedUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutContextInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
    Preferences?: PreferencesCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Token?: TokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContextInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
    Preferences?: PreferencesUncheckedCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContextInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContextInput, UserUncheckedCreateWithoutContextInput>
  }

  export type UserUpsertWithoutContextInput = {
    update: XOR<UserUpdateWithoutContextInput, UserUncheckedUpdateWithoutContextInput>
    create: XOR<UserCreateWithoutContextInput, UserUncheckedCreateWithoutContextInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContextInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContextInput, UserUncheckedUpdateWithoutContextInput>
  }

  export type UserUpdateWithoutContextInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Token?: TokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContextInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUncheckedUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommunityCreateWithoutLeaderboardInput = {
    name?: string | null
    description?: string | null
    BannedUsers?: BannedUsersCreateNestedManyWithoutCommunityInput
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutCommunityInput
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutCommunityInput
    PendingPost?: PendingPostCreateNestedManyWithoutCommunityInput
    Post?: PostCreateNestedManyWithoutCommunityInput
    Report?: ReportCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutLeaderboardInput = {
    id?: number
    name?: string | null
    description?: string | null
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutCommunityInput
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutCommunityInput
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutCommunityInput
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutCommunityInput
    Post?: PostUncheckedCreateNestedManyWithoutCommunityInput
    Report?: ReportUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutLeaderboardInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutLeaderboardInput, CommunityUncheckedCreateWithoutLeaderboardInput>
  }

  export type CommunityUpsertWithoutLeaderboardInput = {
    update: XOR<CommunityUpdateWithoutLeaderboardInput, CommunityUncheckedUpdateWithoutLeaderboardInput>
    create: XOR<CommunityCreateWithoutLeaderboardInput, CommunityUncheckedCreateWithoutLeaderboardInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutLeaderboardInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutLeaderboardInput, CommunityUncheckedUpdateWithoutLeaderboardInput>
  }

  export type CommunityUpdateWithoutLeaderboardInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    BannedUsers?: BannedUsersUpdateManyWithoutCommunityNestedInput
    CommunityRequest?: CommunityRequestUpdateManyWithoutCommunityNestedInput
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutCommunityNestedInput
    PendingPost?: PendingPostUpdateManyWithoutCommunityNestedInput
    Post?: PostUpdateManyWithoutCommunityNestedInput
    Report?: ReportUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutLeaderboardInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutCommunityNestedInput
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutCommunityNestedInput
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutCommunityNestedInput
    PendingPost?: PendingPostUncheckedUpdateManyWithoutCommunityNestedInput
    Post?: PostUncheckedUpdateManyWithoutCommunityNestedInput
    Report?: ReportUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityCreateWithoutLeaderboardEntryInput = {
    name?: string | null
    description?: string | null
    BannedUsers?: BannedUsersCreateNestedManyWithoutCommunityInput
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutCommunityInput
    Leaderboard?: LeaderboardCreateNestedManyWithoutCommunityInput
    PendingPost?: PendingPostCreateNestedManyWithoutCommunityInput
    Post?: PostCreateNestedManyWithoutCommunityInput
    Report?: ReportCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutLeaderboardEntryInput = {
    id?: number
    name?: string | null
    description?: string | null
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutCommunityInput
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutCommunityInput
    Leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutCommunityInput
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutCommunityInput
    Post?: PostUncheckedCreateNestedManyWithoutCommunityInput
    Report?: ReportUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutLeaderboardEntryInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutLeaderboardEntryInput, CommunityUncheckedCreateWithoutLeaderboardEntryInput>
  }

  export type UserCreateWithoutLeaderboardEntryInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutUserInput
    Context?: ContextCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
    Preferences?: PreferencesCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Token?: TokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLeaderboardEntryInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutUserInput
    Context?: ContextUncheckedCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
    Preferences?: PreferencesUncheckedCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLeaderboardEntryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaderboardEntryInput, UserUncheckedCreateWithoutLeaderboardEntryInput>
  }

  export type CommunityUpsertWithoutLeaderboardEntryInput = {
    update: XOR<CommunityUpdateWithoutLeaderboardEntryInput, CommunityUncheckedUpdateWithoutLeaderboardEntryInput>
    create: XOR<CommunityCreateWithoutLeaderboardEntryInput, CommunityUncheckedCreateWithoutLeaderboardEntryInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutLeaderboardEntryInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutLeaderboardEntryInput, CommunityUncheckedUpdateWithoutLeaderboardEntryInput>
  }

  export type CommunityUpdateWithoutLeaderboardEntryInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    BannedUsers?: BannedUsersUpdateManyWithoutCommunityNestedInput
    CommunityRequest?: CommunityRequestUpdateManyWithoutCommunityNestedInput
    Leaderboard?: LeaderboardUpdateManyWithoutCommunityNestedInput
    PendingPost?: PendingPostUpdateManyWithoutCommunityNestedInput
    Post?: PostUpdateManyWithoutCommunityNestedInput
    Report?: ReportUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutLeaderboardEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutCommunityNestedInput
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutCommunityNestedInput
    Leaderboard?: LeaderboardUncheckedUpdateManyWithoutCommunityNestedInput
    PendingPost?: PendingPostUncheckedUpdateManyWithoutCommunityNestedInput
    Post?: PostUncheckedUpdateManyWithoutCommunityNestedInput
    Report?: ReportUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type UserUpsertWithoutLeaderboardEntryInput = {
    update: XOR<UserUpdateWithoutLeaderboardEntryInput, UserUncheckedUpdateWithoutLeaderboardEntryInput>
    create: XOR<UserCreateWithoutLeaderboardEntryInput, UserUncheckedCreateWithoutLeaderboardEntryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaderboardEntryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaderboardEntryInput, UserUncheckedUpdateWithoutLeaderboardEntryInput>
  }

  export type UserUpdateWithoutLeaderboardEntryInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUpdateManyWithoutUserNestedInput
    Context?: ContextUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Token?: TokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaderboardEntryInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutUserNestedInput
    Context?: ContextUncheckedUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUncheckedUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommunityCreateWithoutPendingPostInput = {
    name?: string | null
    description?: string | null
    BannedUsers?: BannedUsersCreateNestedManyWithoutCommunityInput
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutCommunityInput
    Leaderboard?: LeaderboardCreateNestedManyWithoutCommunityInput
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutCommunityInput
    Post?: PostCreateNestedManyWithoutCommunityInput
    Report?: ReportCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutPendingPostInput = {
    id?: number
    name?: string | null
    description?: string | null
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutCommunityInput
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutCommunityInput
    Leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutCommunityInput
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutCommunityInput
    Post?: PostUncheckedCreateNestedManyWithoutCommunityInput
    Report?: ReportUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutPendingPostInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutPendingPostInput, CommunityUncheckedCreateWithoutPendingPostInput>
  }

  export type UserCreateWithoutPendingPostInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutUserInput
    Context?: ContextCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
    Preferences?: PreferencesCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Token?: TokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPendingPostInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutUserInput
    Context?: ContextUncheckedCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
    Preferences?: PreferencesUncheckedCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPendingPostInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPendingPostInput, UserUncheckedCreateWithoutPendingPostInput>
  }

  export type CommunityUpsertWithoutPendingPostInput = {
    update: XOR<CommunityUpdateWithoutPendingPostInput, CommunityUncheckedUpdateWithoutPendingPostInput>
    create: XOR<CommunityCreateWithoutPendingPostInput, CommunityUncheckedCreateWithoutPendingPostInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutPendingPostInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutPendingPostInput, CommunityUncheckedUpdateWithoutPendingPostInput>
  }

  export type CommunityUpdateWithoutPendingPostInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    BannedUsers?: BannedUsersUpdateManyWithoutCommunityNestedInput
    CommunityRequest?: CommunityRequestUpdateManyWithoutCommunityNestedInput
    Leaderboard?: LeaderboardUpdateManyWithoutCommunityNestedInput
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutCommunityNestedInput
    Post?: PostUpdateManyWithoutCommunityNestedInput
    Report?: ReportUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutPendingPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutCommunityNestedInput
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutCommunityNestedInput
    Leaderboard?: LeaderboardUncheckedUpdateManyWithoutCommunityNestedInput
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutCommunityNestedInput
    Post?: PostUncheckedUpdateManyWithoutCommunityNestedInput
    Report?: ReportUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type UserUpsertWithoutPendingPostInput = {
    update: XOR<UserUpdateWithoutPendingPostInput, UserUncheckedUpdateWithoutPendingPostInput>
    create: XOR<UserCreateWithoutPendingPostInput, UserUncheckedCreateWithoutPendingPostInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPendingPostInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPendingPostInput, UserUncheckedUpdateWithoutPendingPostInput>
  }

  export type UserUpdateWithoutPendingPostInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUpdateManyWithoutUserNestedInput
    Context?: ContextUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Token?: TokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPendingPostInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutUserNestedInput
    Context?: ContextUncheckedUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUncheckedUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentCreateWithoutPostInput = {
    body?: string | null
    user?: string | null
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: number
    body?: string | null
    user?: string | null
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type CommunityCreateWithoutPostInput = {
    name?: string | null
    description?: string | null
    BannedUsers?: BannedUsersCreateNestedManyWithoutCommunityInput
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutCommunityInput
    Leaderboard?: LeaderboardCreateNestedManyWithoutCommunityInput
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutCommunityInput
    PendingPost?: PendingPostCreateNestedManyWithoutCommunityInput
    Report?: ReportCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutPostInput = {
    id?: number
    name?: string | null
    description?: string | null
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutCommunityInput
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutCommunityInput
    Leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutCommunityInput
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutCommunityInput
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutCommunityInput
    Report?: ReportUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutPostInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutPostInput, CommunityUncheckedCreateWithoutPostInput>
  }

  export type UserCreateWithoutPostInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutUserInput
    Context?: ContextCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostCreateNestedManyWithoutUserInput
    Preferences?: PreferencesCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Token?: TokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutUserInput
    Context?: ContextUncheckedCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutUserInput
    Preferences?: PreferencesUncheckedCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostInput, UserUncheckedCreateWithoutPostInput>
  }

  export type ReportCreateWithoutPostInput = {
    reportReason?: string | null
    reportDate?: Date | string | null
    Community?: CommunityCreateNestedOneWithoutReportInput
    User?: UserCreateNestedOneWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutPostInput = {
    id?: number
    reportedBy?: string | null
    community?: number | null
    reportReason?: string | null
    reportDate?: Date | string | null
  }

  export type ReportCreateOrConnectWithoutPostInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutPostInput, ReportUncheckedCreateWithoutPostInput>
  }

  export type ReportCreateManyPostInputEnvelope = {
    data: ReportCreateManyPostInput | ReportCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    body?: StringNullableFilter<"Comment"> | string | null
    user?: StringNullableFilter<"Comment"> | string | null
    post?: IntNullableFilter<"Comment"> | number | null
  }

  export type CommunityUpsertWithoutPostInput = {
    update: XOR<CommunityUpdateWithoutPostInput, CommunityUncheckedUpdateWithoutPostInput>
    create: XOR<CommunityCreateWithoutPostInput, CommunityUncheckedCreateWithoutPostInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutPostInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutPostInput, CommunityUncheckedUpdateWithoutPostInput>
  }

  export type CommunityUpdateWithoutPostInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    BannedUsers?: BannedUsersUpdateManyWithoutCommunityNestedInput
    CommunityRequest?: CommunityRequestUpdateManyWithoutCommunityNestedInput
    Leaderboard?: LeaderboardUpdateManyWithoutCommunityNestedInput
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutCommunityNestedInput
    PendingPost?: PendingPostUpdateManyWithoutCommunityNestedInput
    Report?: ReportUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutCommunityNestedInput
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutCommunityNestedInput
    Leaderboard?: LeaderboardUncheckedUpdateManyWithoutCommunityNestedInput
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutCommunityNestedInput
    PendingPost?: PendingPostUncheckedUpdateManyWithoutCommunityNestedInput
    Report?: ReportUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type UserUpsertWithoutPostInput = {
    update: XOR<UserUpdateWithoutPostInput, UserUncheckedUpdateWithoutPostInput>
    create: XOR<UserCreateWithoutPostInput, UserUncheckedCreateWithoutPostInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostInput, UserUncheckedUpdateWithoutPostInput>
  }

  export type UserUpdateWithoutPostInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUpdateManyWithoutUserNestedInput
    Context?: ContextUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Token?: TokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutUserNestedInput
    Context?: ContextUncheckedUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUncheckedUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUncheckedUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReportUpsertWithWhereUniqueWithoutPostInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutPostInput, ReportUncheckedUpdateWithoutPostInput>
    create: XOR<ReportCreateWithoutPostInput, ReportUncheckedCreateWithoutPostInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutPostInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutPostInput, ReportUncheckedUpdateWithoutPostInput>
  }

  export type ReportUpdateManyWithWhereWithoutPostInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutPostInput>
  }

  export type UserCreateWithoutPreferencesInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutUserInput
    Context?: ContextCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Token?: TokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPreferencesInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutUserInput
    Context?: ContextUncheckedCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
  }

  export type UserUpsertWithoutPreferencesInput = {
    update: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserUpdateWithoutPreferencesInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUpdateManyWithoutUserNestedInput
    Context?: ContextUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Token?: TokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPreferencesInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutUserNestedInput
    Context?: ContextUncheckedUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRelationship_Relationship_followerToUserInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutUserInput
    Context?: ContextCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
    Preferences?: PreferencesCreateNestedManyWithoutUserInput
    Relationship_Relationship_followingToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Token?: TokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRelationship_Relationship_followerToUserInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutUserInput
    Context?: ContextUncheckedCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
    Preferences?: PreferencesUncheckedCreateNestedManyWithoutUserInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRelationship_Relationship_followerToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRelationship_Relationship_followerToUserInput, UserUncheckedCreateWithoutRelationship_Relationship_followerToUserInput>
  }

  export type UserCreateWithoutRelationship_Relationship_followingToUserInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutUserInput
    Context?: ContextCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
    Preferences?: PreferencesCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Token?: TokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRelationship_Relationship_followingToUserInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutUserInput
    Context?: ContextUncheckedCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
    Preferences?: PreferencesUncheckedCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRelationship_Relationship_followingToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRelationship_Relationship_followingToUserInput, UserUncheckedCreateWithoutRelationship_Relationship_followingToUserInput>
  }

  export type UserUpsertWithoutRelationship_Relationship_followerToUserInput = {
    update: XOR<UserUpdateWithoutRelationship_Relationship_followerToUserInput, UserUncheckedUpdateWithoutRelationship_Relationship_followerToUserInput>
    create: XOR<UserCreateWithoutRelationship_Relationship_followerToUserInput, UserUncheckedCreateWithoutRelationship_Relationship_followerToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRelationship_Relationship_followerToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRelationship_Relationship_followerToUserInput, UserUncheckedUpdateWithoutRelationship_Relationship_followerToUserInput>
  }

  export type UserUpdateWithoutRelationship_Relationship_followerToUserInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUpdateManyWithoutUserNestedInput
    Context?: ContextUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Token?: TokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRelationship_Relationship_followerToUserInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutUserNestedInput
    Context?: ContextUncheckedUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUncheckedUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutRelationship_Relationship_followingToUserInput = {
    update: XOR<UserUpdateWithoutRelationship_Relationship_followingToUserInput, UserUncheckedUpdateWithoutRelationship_Relationship_followingToUserInput>
    create: XOR<UserCreateWithoutRelationship_Relationship_followingToUserInput, UserUncheckedCreateWithoutRelationship_Relationship_followingToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRelationship_Relationship_followingToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRelationship_Relationship_followingToUserInput, UserUncheckedUpdateWithoutRelationship_Relationship_followingToUserInput>
  }

  export type UserUpdateWithoutRelationship_Relationship_followingToUserInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUpdateManyWithoutUserNestedInput
    Context?: ContextUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Token?: TokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRelationship_Relationship_followingToUserInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutUserNestedInput
    Context?: ContextUncheckedUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUncheckedUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommunityCreateWithoutReportInput = {
    name?: string | null
    description?: string | null
    BannedUsers?: BannedUsersCreateNestedManyWithoutCommunityInput
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutCommunityInput
    Leaderboard?: LeaderboardCreateNestedManyWithoutCommunityInput
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutCommunityInput
    PendingPost?: PendingPostCreateNestedManyWithoutCommunityInput
    Post?: PostCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutReportInput = {
    id?: number
    name?: string | null
    description?: string | null
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutCommunityInput
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutCommunityInput
    Leaderboard?: LeaderboardUncheckedCreateNestedManyWithoutCommunityInput
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutCommunityInput
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutCommunityInput
    Post?: PostUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutReportInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutReportInput, CommunityUncheckedCreateWithoutReportInput>
  }

  export type PostCreateWithoutReportInput = {
    Content?: string | null
    fileUrl?: string | null
    caption?: string | null
    Comment?: CommentCreateNestedManyWithoutPostInput
    Community?: CommunityCreateNestedOneWithoutPostInput
    User?: UserCreateNestedOneWithoutPostInput
  }

  export type PostUncheckedCreateWithoutReportInput = {
    id?: number
    Content?: string | null
    fileUrl?: string | null
    community?: number | null
    user?: string | null
    caption?: string | null
    Comment?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutReportInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutReportInput, PostUncheckedCreateWithoutReportInput>
  }

  export type UserCreateWithoutReportInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutUserInput
    Context?: ContextCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
    Preferences?: PreferencesCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Token?: TokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutUserInput
    Context?: ContextUncheckedCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
    Preferences?: PreferencesUncheckedCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportInput, UserUncheckedCreateWithoutReportInput>
  }

  export type CommunityUpsertWithoutReportInput = {
    update: XOR<CommunityUpdateWithoutReportInput, CommunityUncheckedUpdateWithoutReportInput>
    create: XOR<CommunityCreateWithoutReportInput, CommunityUncheckedCreateWithoutReportInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutReportInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutReportInput, CommunityUncheckedUpdateWithoutReportInput>
  }

  export type CommunityUpdateWithoutReportInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    BannedUsers?: BannedUsersUpdateManyWithoutCommunityNestedInput
    CommunityRequest?: CommunityRequestUpdateManyWithoutCommunityNestedInput
    Leaderboard?: LeaderboardUpdateManyWithoutCommunityNestedInput
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutCommunityNestedInput
    PendingPost?: PendingPostUpdateManyWithoutCommunityNestedInput
    Post?: PostUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutCommunityNestedInput
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutCommunityNestedInput
    Leaderboard?: LeaderboardUncheckedUpdateManyWithoutCommunityNestedInput
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutCommunityNestedInput
    PendingPost?: PendingPostUncheckedUpdateManyWithoutCommunityNestedInput
    Post?: PostUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type PostUpsertWithoutReportInput = {
    update: XOR<PostUpdateWithoutReportInput, PostUncheckedUpdateWithoutReportInput>
    create: XOR<PostCreateWithoutReportInput, PostUncheckedCreateWithoutReportInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutReportInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutReportInput, PostUncheckedUpdateWithoutReportInput>
  }

  export type PostUpdateWithoutReportInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: CommentUpdateManyWithoutPostNestedInput
    Community?: CommunityUpdateOneWithoutPostNestedInput
    User?: UserUpdateOneWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutReportInput = {
    update: XOR<UserUpdateWithoutReportInput, UserUncheckedUpdateWithoutReportInput>
    create: XOR<UserCreateWithoutReportInput, UserUncheckedCreateWithoutReportInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportInput, UserUncheckedUpdateWithoutReportInput>
  }

  export type UserUpdateWithoutReportInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUpdateManyWithoutUserNestedInput
    Context?: ContextUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Token?: TokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutUserNestedInput
    Context?: ContextUncheckedUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUncheckedUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTokenInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutUserInput
    Context?: ContextCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
    Preferences?: PreferencesCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTokenInput = {
    username: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    password?: string | null
    avatarUrl?: string | null
    bio?: string | null
    role?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutUserInput
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutUserInput
    Context?: ContextUncheckedCreateNestedManyWithoutUserInput
    LeaderboardEntry?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
    Preferences?: PreferencesUncheckedCreateNestedManyWithoutUserInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followerToUserInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedCreateNestedManyWithoutUser_Relationship_followingToUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTokenInput, UserUncheckedCreateWithoutTokenInput>
  }

  export type UserUpsertWithoutTokenInput = {
    update: XOR<UserUpdateWithoutTokenInput, UserUncheckedUpdateWithoutTokenInput>
    create: XOR<UserCreateWithoutTokenInput, UserUncheckedCreateWithoutTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTokenInput, UserUncheckedUpdateWithoutTokenInput>
  }

  export type UserUpdateWithoutTokenInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUpdateManyWithoutUserNestedInput
    Context?: ContextUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTokenInput = {
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutUserNestedInput
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutUserNestedInput
    Context?: ContextUncheckedUpdateManyWithoutUserNestedInput
    LeaderboardEntry?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    PendingPost?: PendingPostUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
    Preferences?: PreferencesUncheckedUpdateManyWithoutUserNestedInput
    Relationship_Relationship_followerToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followerToUserNestedInput
    Relationship_Relationship_followingToUser?: RelationshipUncheckedUpdateManyWithoutUser_Relationship_followingToUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BannedUsersCreateWithoutUserInput = {
    Community: CommunityCreateNestedOneWithoutBannedUsersInput
  }

  export type BannedUsersUncheckedCreateWithoutUserInput = {
    id?: number
    community: number
  }

  export type BannedUsersCreateOrConnectWithoutUserInput = {
    where: BannedUsersWhereUniqueInput
    create: XOR<BannedUsersCreateWithoutUserInput, BannedUsersUncheckedCreateWithoutUserInput>
  }

  export type BannedUsersCreateManyUserInputEnvelope = {
    data: BannedUsersCreateManyUserInput | BannedUsersCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommunityRequestCreateWithoutUserInput = {
    isVerified?: boolean | null
    isRequested?: boolean | null
    Community?: CommunityCreateNestedOneWithoutCommunityRequestInput
  }

  export type CommunityRequestUncheckedCreateWithoutUserInput = {
    id?: number
    community?: number | null
    isVerified?: boolean | null
    isRequested?: boolean | null
  }

  export type CommunityRequestCreateOrConnectWithoutUserInput = {
    where: CommunityRequestWhereUniqueInput
    create: XOR<CommunityRequestCreateWithoutUserInput, CommunityRequestUncheckedCreateWithoutUserInput>
  }

  export type CommunityRequestCreateManyUserInputEnvelope = {
    data: CommunityRequestCreateManyUserInput | CommunityRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContextCreateWithoutUserInput = {
    email?: string | null
    ip?: string | null
    country?: string | null
    city?: string | null
    browser?: string | null
    platform?: string | null
    os?: string | null
    device?: string | null
    deviceType?: string | null
    isTrusted?: boolean | null
  }

  export type ContextUncheckedCreateWithoutUserInput = {
    id?: number
    email?: string | null
    ip?: string | null
    country?: string | null
    city?: string | null
    browser?: string | null
    platform?: string | null
    os?: string | null
    device?: string | null
    deviceType?: string | null
    isTrusted?: boolean | null
  }

  export type ContextCreateOrConnectWithoutUserInput = {
    where: ContextWhereUniqueInput
    create: XOR<ContextCreateWithoutUserInput, ContextUncheckedCreateWithoutUserInput>
  }

  export type ContextCreateManyUserInputEnvelope = {
    data: ContextCreateManyUserInput | ContextCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeaderboardEntryCreateWithoutUserInput = {
    entryUrl?: string | null
    verifiedBy?: number | null
    isVerified?: boolean | null
    rank?: number | null
    Community?: CommunityCreateNestedOneWithoutLeaderboardEntryInput
  }

  export type LeaderboardEntryUncheckedCreateWithoutUserInput = {
    id?: number
    community?: number | null
    entryUrl?: string | null
    verifiedBy?: number | null
    isVerified?: boolean | null
    rank?: number | null
  }

  export type LeaderboardEntryCreateOrConnectWithoutUserInput = {
    where: LeaderboardEntryWhereUniqueInput
    create: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput>
  }

  export type LeaderboardEntryCreateManyUserInputEnvelope = {
    data: LeaderboardEntryCreateManyUserInput | LeaderboardEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PendingPostCreateWithoutUserInput = {
    Content?: string | null
    fileUrl?: string | null
    caption?: string | null
    status?: string | null
    confirmationToken?: string | null
    Community?: CommunityCreateNestedOneWithoutPendingPostInput
  }

  export type PendingPostUncheckedCreateWithoutUserInput = {
    id?: number
    Content?: string | null
    fileUrl?: string | null
    community?: number | null
    caption?: string | null
    status?: string | null
    confirmationToken?: string | null
  }

  export type PendingPostCreateOrConnectWithoutUserInput = {
    where: PendingPostWhereUniqueInput
    create: XOR<PendingPostCreateWithoutUserInput, PendingPostUncheckedCreateWithoutUserInput>
  }

  export type PendingPostCreateManyUserInputEnvelope = {
    data: PendingPostCreateManyUserInput | PendingPostCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutUserInput = {
    Content?: string | null
    fileUrl?: string | null
    caption?: string | null
    Comment?: CommentCreateNestedManyWithoutPostInput
    Community?: CommunityCreateNestedOneWithoutPostInput
    Report?: ReportCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutUserInput = {
    id?: number
    Content?: string | null
    fileUrl?: string | null
    community?: number | null
    caption?: string | null
    Comment?: CommentUncheckedCreateNestedManyWithoutPostInput
    Report?: ReportUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutUserInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostCreateManyUserInputEnvelope = {
    data: PostCreateManyUserInput | PostCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PreferencesCreateWithoutUserInput = {

  }

  export type PreferencesUncheckedCreateWithoutUserInput = {
    id?: number
  }

  export type PreferencesCreateOrConnectWithoutUserInput = {
    where: PreferencesWhereUniqueInput
    create: XOR<PreferencesCreateWithoutUserInput, PreferencesUncheckedCreateWithoutUserInput>
  }

  export type PreferencesCreateManyUserInputEnvelope = {
    data: PreferencesCreateManyUserInput | PreferencesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RelationshipCreateWithoutUser_Relationship_followerToUserInput = {
    User_Relationship_followingToUser?: UserCreateNestedOneWithoutRelationship_Relationship_followingToUserInput
  }

  export type RelationshipUncheckedCreateWithoutUser_Relationship_followerToUserInput = {
    id?: number
    following?: string | null
  }

  export type RelationshipCreateOrConnectWithoutUser_Relationship_followerToUserInput = {
    where: RelationshipWhereUniqueInput
    create: XOR<RelationshipCreateWithoutUser_Relationship_followerToUserInput, RelationshipUncheckedCreateWithoutUser_Relationship_followerToUserInput>
  }

  export type RelationshipCreateManyUser_Relationship_followerToUserInputEnvelope = {
    data: RelationshipCreateManyUser_Relationship_followerToUserInput | RelationshipCreateManyUser_Relationship_followerToUserInput[]
    skipDuplicates?: boolean
  }

  export type RelationshipCreateWithoutUser_Relationship_followingToUserInput = {
    User_Relationship_followerToUser?: UserCreateNestedOneWithoutRelationship_Relationship_followerToUserInput
  }

  export type RelationshipUncheckedCreateWithoutUser_Relationship_followingToUserInput = {
    id?: number
    follower?: string | null
  }

  export type RelationshipCreateOrConnectWithoutUser_Relationship_followingToUserInput = {
    where: RelationshipWhereUniqueInput
    create: XOR<RelationshipCreateWithoutUser_Relationship_followingToUserInput, RelationshipUncheckedCreateWithoutUser_Relationship_followingToUserInput>
  }

  export type RelationshipCreateManyUser_Relationship_followingToUserInputEnvelope = {
    data: RelationshipCreateManyUser_Relationship_followingToUserInput | RelationshipCreateManyUser_Relationship_followingToUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutUserInput = {
    reportReason?: string | null
    reportDate?: Date | string | null
    Community?: CommunityCreateNestedOneWithoutReportInput
    Post?: PostCreateNestedOneWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutUserInput = {
    id?: number
    post?: number | null
    community?: number | null
    reportReason?: string | null
    reportDate?: Date | string | null
  }

  export type ReportCreateOrConnectWithoutUserInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput>
  }

  export type ReportCreateManyUserInputEnvelope = {
    data: ReportCreateManyUserInput | ReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TokenCreateWithoutUserInput = {
    refreshToken?: string | null
    accessToken?: string | null
    createdAt?: Date | string | null
  }

  export type TokenUncheckedCreateWithoutUserInput = {
    id?: number
    refreshToken?: string | null
    accessToken?: string | null
    createdAt?: Date | string | null
  }

  export type TokenCreateOrConnectWithoutUserInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenCreateManyUserInputEnvelope = {
    data: TokenCreateManyUserInput | TokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BannedUsersUpsertWithWhereUniqueWithoutUserInput = {
    where: BannedUsersWhereUniqueInput
    update: XOR<BannedUsersUpdateWithoutUserInput, BannedUsersUncheckedUpdateWithoutUserInput>
    create: XOR<BannedUsersCreateWithoutUserInput, BannedUsersUncheckedCreateWithoutUserInput>
  }

  export type BannedUsersUpdateWithWhereUniqueWithoutUserInput = {
    where: BannedUsersWhereUniqueInput
    data: XOR<BannedUsersUpdateWithoutUserInput, BannedUsersUncheckedUpdateWithoutUserInput>
  }

  export type BannedUsersUpdateManyWithWhereWithoutUserInput = {
    where: BannedUsersScalarWhereInput
    data: XOR<BannedUsersUpdateManyMutationInput, BannedUsersUncheckedUpdateManyWithoutUserInput>
  }

  export type CommunityRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityRequestWhereUniqueInput
    update: XOR<CommunityRequestUpdateWithoutUserInput, CommunityRequestUncheckedUpdateWithoutUserInput>
    create: XOR<CommunityRequestCreateWithoutUserInput, CommunityRequestUncheckedCreateWithoutUserInput>
  }

  export type CommunityRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityRequestWhereUniqueInput
    data: XOR<CommunityRequestUpdateWithoutUserInput, CommunityRequestUncheckedUpdateWithoutUserInput>
  }

  export type CommunityRequestUpdateManyWithWhereWithoutUserInput = {
    where: CommunityRequestScalarWhereInput
    data: XOR<CommunityRequestUpdateManyMutationInput, CommunityRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type ContextUpsertWithWhereUniqueWithoutUserInput = {
    where: ContextWhereUniqueInput
    update: XOR<ContextUpdateWithoutUserInput, ContextUncheckedUpdateWithoutUserInput>
    create: XOR<ContextCreateWithoutUserInput, ContextUncheckedCreateWithoutUserInput>
  }

  export type ContextUpdateWithWhereUniqueWithoutUserInput = {
    where: ContextWhereUniqueInput
    data: XOR<ContextUpdateWithoutUserInput, ContextUncheckedUpdateWithoutUserInput>
  }

  export type ContextUpdateManyWithWhereWithoutUserInput = {
    where: ContextScalarWhereInput
    data: XOR<ContextUpdateManyMutationInput, ContextUncheckedUpdateManyWithoutUserInput>
  }

  export type ContextScalarWhereInput = {
    AND?: ContextScalarWhereInput | ContextScalarWhereInput[]
    OR?: ContextScalarWhereInput[]
    NOT?: ContextScalarWhereInput | ContextScalarWhereInput[]
    id?: IntFilter<"Context"> | number
    user?: StringNullableFilter<"Context"> | string | null
    email?: StringNullableFilter<"Context"> | string | null
    ip?: StringNullableFilter<"Context"> | string | null
    country?: StringNullableFilter<"Context"> | string | null
    city?: StringNullableFilter<"Context"> | string | null
    browser?: StringNullableFilter<"Context"> | string | null
    platform?: StringNullableFilter<"Context"> | string | null
    os?: StringNullableFilter<"Context"> | string | null
    device?: StringNullableFilter<"Context"> | string | null
    deviceType?: StringNullableFilter<"Context"> | string | null
    isTrusted?: BoolNullableFilter<"Context"> | boolean | null
  }

  export type LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: LeaderboardEntryWhereUniqueInput
    update: XOR<LeaderboardEntryUpdateWithoutUserInput, LeaderboardEntryUncheckedUpdateWithoutUserInput>
    create: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput>
  }

  export type LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: LeaderboardEntryWhereUniqueInput
    data: XOR<LeaderboardEntryUpdateWithoutUserInput, LeaderboardEntryUncheckedUpdateWithoutUserInput>
  }

  export type LeaderboardEntryUpdateManyWithWhereWithoutUserInput = {
    where: LeaderboardEntryScalarWhereInput
    data: XOR<LeaderboardEntryUpdateManyMutationInput, LeaderboardEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type PendingPostUpsertWithWhereUniqueWithoutUserInput = {
    where: PendingPostWhereUniqueInput
    update: XOR<PendingPostUpdateWithoutUserInput, PendingPostUncheckedUpdateWithoutUserInput>
    create: XOR<PendingPostCreateWithoutUserInput, PendingPostUncheckedCreateWithoutUserInput>
  }

  export type PendingPostUpdateWithWhereUniqueWithoutUserInput = {
    where: PendingPostWhereUniqueInput
    data: XOR<PendingPostUpdateWithoutUserInput, PendingPostUncheckedUpdateWithoutUserInput>
  }

  export type PendingPostUpdateManyWithWhereWithoutUserInput = {
    where: PendingPostScalarWhereInput
    data: XOR<PendingPostUpdateManyMutationInput, PendingPostUncheckedUpdateManyWithoutUserInput>
  }

  export type PostUpsertWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostUpdateWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
  }

  export type PostUpdateManyWithWhereWithoutUserInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutUserInput>
  }

  export type PreferencesUpsertWithWhereUniqueWithoutUserInput = {
    where: PreferencesWhereUniqueInput
    update: XOR<PreferencesUpdateWithoutUserInput, PreferencesUncheckedUpdateWithoutUserInput>
    create: XOR<PreferencesCreateWithoutUserInput, PreferencesUncheckedCreateWithoutUserInput>
  }

  export type PreferencesUpdateWithWhereUniqueWithoutUserInput = {
    where: PreferencesWhereUniqueInput
    data: XOR<PreferencesUpdateWithoutUserInput, PreferencesUncheckedUpdateWithoutUserInput>
  }

  export type PreferencesUpdateManyWithWhereWithoutUserInput = {
    where: PreferencesScalarWhereInput
    data: XOR<PreferencesUpdateManyMutationInput, PreferencesUncheckedUpdateManyWithoutUserInput>
  }

  export type PreferencesScalarWhereInput = {
    AND?: PreferencesScalarWhereInput | PreferencesScalarWhereInput[]
    OR?: PreferencesScalarWhereInput[]
    NOT?: PreferencesScalarWhereInput | PreferencesScalarWhereInput[]
    id?: IntFilter<"Preferences"> | number
    user?: StringNullableFilter<"Preferences"> | string | null
  }

  export type RelationshipUpsertWithWhereUniqueWithoutUser_Relationship_followerToUserInput = {
    where: RelationshipWhereUniqueInput
    update: XOR<RelationshipUpdateWithoutUser_Relationship_followerToUserInput, RelationshipUncheckedUpdateWithoutUser_Relationship_followerToUserInput>
    create: XOR<RelationshipCreateWithoutUser_Relationship_followerToUserInput, RelationshipUncheckedCreateWithoutUser_Relationship_followerToUserInput>
  }

  export type RelationshipUpdateWithWhereUniqueWithoutUser_Relationship_followerToUserInput = {
    where: RelationshipWhereUniqueInput
    data: XOR<RelationshipUpdateWithoutUser_Relationship_followerToUserInput, RelationshipUncheckedUpdateWithoutUser_Relationship_followerToUserInput>
  }

  export type RelationshipUpdateManyWithWhereWithoutUser_Relationship_followerToUserInput = {
    where: RelationshipScalarWhereInput
    data: XOR<RelationshipUpdateManyMutationInput, RelationshipUncheckedUpdateManyWithoutUser_Relationship_followerToUserInput>
  }

  export type RelationshipScalarWhereInput = {
    AND?: RelationshipScalarWhereInput | RelationshipScalarWhereInput[]
    OR?: RelationshipScalarWhereInput[]
    NOT?: RelationshipScalarWhereInput | RelationshipScalarWhereInput[]
    id?: IntFilter<"Relationship"> | number
    follower?: StringNullableFilter<"Relationship"> | string | null
    following?: StringNullableFilter<"Relationship"> | string | null
  }

  export type RelationshipUpsertWithWhereUniqueWithoutUser_Relationship_followingToUserInput = {
    where: RelationshipWhereUniqueInput
    update: XOR<RelationshipUpdateWithoutUser_Relationship_followingToUserInput, RelationshipUncheckedUpdateWithoutUser_Relationship_followingToUserInput>
    create: XOR<RelationshipCreateWithoutUser_Relationship_followingToUserInput, RelationshipUncheckedCreateWithoutUser_Relationship_followingToUserInput>
  }

  export type RelationshipUpdateWithWhereUniqueWithoutUser_Relationship_followingToUserInput = {
    where: RelationshipWhereUniqueInput
    data: XOR<RelationshipUpdateWithoutUser_Relationship_followingToUserInput, RelationshipUncheckedUpdateWithoutUser_Relationship_followingToUserInput>
  }

  export type RelationshipUpdateManyWithWhereWithoutUser_Relationship_followingToUserInput = {
    where: RelationshipScalarWhereInput
    data: XOR<RelationshipUpdateManyMutationInput, RelationshipUncheckedUpdateManyWithoutUser_Relationship_followingToUserInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutUserInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutUserInput, ReportUncheckedUpdateWithoutUserInput>
    create: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutUserInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutUserInput, ReportUncheckedUpdateWithoutUserInput>
  }

  export type ReportUpdateManyWithWhereWithoutUserInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutUserInput>
  }

  export type TokenUpsertWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    update: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenUpdateWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    data: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
  }

  export type TokenUpdateManyWithWhereWithoutUserInput = {
    where: TokenScalarWhereInput
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyWithoutUserInput>
  }

  export type TokenScalarWhereInput = {
    AND?: TokenScalarWhereInput | TokenScalarWhereInput[]
    OR?: TokenScalarWhereInput[]
    NOT?: TokenScalarWhereInput | TokenScalarWhereInput[]
    id?: IntFilter<"Token"> | number
    user?: StringNullableFilter<"Token"> | string | null
    refreshToken?: StringNullableFilter<"Token"> | string | null
    accessToken?: StringNullableFilter<"Token"> | string | null
    createdAt?: DateTimeNullableFilter<"Token"> | Date | string | null
  }

  export type BannedUsersCreateManyCommunityInput = {
    id?: number
    user: string
  }

  export type CommunityRequestCreateManyCommunityInput = {
    id?: number
    user?: string | null
    isVerified?: boolean | null
    isRequested?: boolean | null
  }

  export type LeaderboardCreateManyCommunityInput = {
    id?: number
    tracking?: string | null
  }

  export type LeaderboardEntryCreateManyCommunityInput = {
    id?: number
    user?: string | null
    entryUrl?: string | null
    verifiedBy?: number | null
    isVerified?: boolean | null
    rank?: number | null
  }

  export type PendingPostCreateManyCommunityInput = {
    id?: number
    Content?: string | null
    fileUrl?: string | null
    user?: string | null
    caption?: string | null
    status?: string | null
    confirmationToken?: string | null
  }

  export type PostCreateManyCommunityInput = {
    id?: number
    Content?: string | null
    fileUrl?: string | null
    user?: string | null
    caption?: string | null
  }

  export type ReportCreateManyCommunityInput = {
    id?: number
    reportedBy?: string | null
    post?: number | null
    reportReason?: string | null
    reportDate?: Date | string | null
  }

  export type BannedUsersUpdateWithoutCommunityInput = {
    User?: UserUpdateOneRequiredWithoutBannedUsersNestedInput
  }

  export type BannedUsersUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
  }

  export type BannedUsersUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
  }

  export type CommunityRequestUpdateWithoutCommunityInput = {
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRequested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    User?: UserUpdateOneWithoutCommunityRequestNestedInput
  }

  export type CommunityRequestUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRequested?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CommunityRequestUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRequested?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type LeaderboardUpdateWithoutCommunityInput = {
    tracking?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeaderboardUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    tracking?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeaderboardUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    tracking?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeaderboardEntryUpdateWithoutCommunityInput = {
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    User?: UserUpdateOneWithoutLeaderboardEntryNestedInput
  }

  export type LeaderboardEntryUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LeaderboardEntryUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PendingPostUpdateWithoutCommunityInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationToken?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneWithoutPendingPostNestedInput
  }

  export type PendingPostUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PendingPostUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostUpdateWithoutCommunityInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: CommentUpdateManyWithoutPostNestedInput
    User?: UserUpdateOneWithoutPostNestedInput
    Report?: ReportUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: CommentUncheckedUpdateManyWithoutPostNestedInput
    Report?: ReportUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportUpdateWithoutCommunityInput = {
    reportReason?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Post?: PostUpdateOneWithoutReportNestedInput
    User?: UserUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedBy?: NullableStringFieldUpdateOperationsInput | string | null
    post?: NullableIntFieldUpdateOperationsInput | number | null
    reportReason?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedBy?: NullableStringFieldUpdateOperationsInput | string | null
    post?: NullableIntFieldUpdateOperationsInput | number | null
    reportReason?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentCreateManyPostInput = {
    id?: number
    body?: string | null
    user?: string | null
  }

  export type ReportCreateManyPostInput = {
    id?: number
    reportedBy?: string | null
    community?: number | null
    reportReason?: string | null
    reportDate?: Date | string | null
  }

  export type CommentUpdateWithoutPostInput = {
    body?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportUpdateWithoutPostInput = {
    reportReason?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Community?: CommunityUpdateOneWithoutReportNestedInput
    User?: UserUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedBy?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    reportReason?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedBy?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    reportReason?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BannedUsersCreateManyUserInput = {
    id?: number
    community: number
  }

  export type CommunityRequestCreateManyUserInput = {
    id?: number
    community?: number | null
    isVerified?: boolean | null
    isRequested?: boolean | null
  }

  export type ContextCreateManyUserInput = {
    id?: number
    email?: string | null
    ip?: string | null
    country?: string | null
    city?: string | null
    browser?: string | null
    platform?: string | null
    os?: string | null
    device?: string | null
    deviceType?: string | null
    isTrusted?: boolean | null
  }

  export type LeaderboardEntryCreateManyUserInput = {
    id?: number
    community?: number | null
    entryUrl?: string | null
    verifiedBy?: number | null
    isVerified?: boolean | null
    rank?: number | null
  }

  export type PendingPostCreateManyUserInput = {
    id?: number
    Content?: string | null
    fileUrl?: string | null
    community?: number | null
    caption?: string | null
    status?: string | null
    confirmationToken?: string | null
  }

  export type PostCreateManyUserInput = {
    id?: number
    Content?: string | null
    fileUrl?: string | null
    community?: number | null
    caption?: string | null
  }

  export type PreferencesCreateManyUserInput = {
    id?: number
  }

  export type RelationshipCreateManyUser_Relationship_followerToUserInput = {
    id?: number
    following?: string | null
  }

  export type RelationshipCreateManyUser_Relationship_followingToUserInput = {
    id?: number
    follower?: string | null
  }

  export type ReportCreateManyUserInput = {
    id?: number
    post?: number | null
    community?: number | null
    reportReason?: string | null
    reportDate?: Date | string | null
  }

  export type TokenCreateManyUserInput = {
    id?: number
    refreshToken?: string | null
    accessToken?: string | null
    createdAt?: Date | string | null
  }

  export type BannedUsersUpdateWithoutUserInput = {
    Community?: CommunityUpdateOneRequiredWithoutBannedUsersNestedInput
  }

  export type BannedUsersUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
  }

  export type BannedUsersUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityRequestUpdateWithoutUserInput = {
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRequested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Community?: CommunityUpdateOneWithoutCommunityRequestNestedInput
  }

  export type CommunityRequestUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: NullableIntFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRequested?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CommunityRequestUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: NullableIntFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRequested?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ContextUpdateWithoutUserInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ContextUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ContextUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type LeaderboardEntryUpdateWithoutUserInput = {
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    Community?: CommunityUpdateOneWithoutLeaderboardEntryNestedInput
  }

  export type LeaderboardEntryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: NullableIntFieldUpdateOperationsInput | number | null
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LeaderboardEntryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: NullableIntFieldUpdateOperationsInput | number | null
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PendingPostUpdateWithoutUserInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationToken?: NullableStringFieldUpdateOperationsInput | string | null
    Community?: CommunityUpdateOneWithoutPendingPostNestedInput
  }

  export type PendingPostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PendingPostUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostUpdateWithoutUserInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: CommentUpdateManyWithoutPostNestedInput
    Community?: CommunityUpdateOneWithoutPostNestedInput
    Report?: ReportUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: CommentUncheckedUpdateManyWithoutPostNestedInput
    Report?: ReportUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PreferencesUpdateWithoutUserInput = {

  }

  export type PreferencesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type PreferencesUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type RelationshipUpdateWithoutUser_Relationship_followerToUserInput = {
    User_Relationship_followingToUser?: UserUpdateOneWithoutRelationship_Relationship_followingToUserNestedInput
  }

  export type RelationshipUncheckedUpdateWithoutUser_Relationship_followerToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    following?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RelationshipUncheckedUpdateManyWithoutUser_Relationship_followerToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    following?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RelationshipUpdateWithoutUser_Relationship_followingToUserInput = {
    User_Relationship_followerToUser?: UserUpdateOneWithoutRelationship_Relationship_followerToUserNestedInput
  }

  export type RelationshipUncheckedUpdateWithoutUser_Relationship_followingToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    follower?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RelationshipUncheckedUpdateManyWithoutUser_Relationship_followingToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    follower?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportUpdateWithoutUserInput = {
    reportReason?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Community?: CommunityUpdateOneWithoutReportNestedInput
    Post?: PostUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    post?: NullableIntFieldUpdateOperationsInput | number | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    reportReason?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    post?: NullableIntFieldUpdateOperationsInput | number | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    reportReason?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TokenUpdateWithoutUserInput = {
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CommunityCountOutputTypeDefaultArgs instead
     */
    export type CommunityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostCountOutputTypeDefaultArgs instead
     */
    export type PostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminDefaultArgs instead
     */
    export type AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminTokenDefaultArgs instead
     */
    export type AdminTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BannedUsersDefaultArgs instead
     */
    export type BannedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BannedUsersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityDefaultArgs instead
     */
    export type CommunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityRequestDefaultArgs instead
     */
    export type CommunityRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContextDefaultArgs instead
     */
    export type ContextArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContextDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaderboardDefaultArgs instead
     */
    export type LeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaderboardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaderboardEntryDefaultArgs instead
     */
    export type LeaderboardEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaderboardEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LikeDefaultArgs instead
     */
    export type LikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LikeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogDefaultArgs instead
     */
    export type LogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PendingPostDefaultArgs instead
     */
    export type PendingPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PendingPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostDefaultArgs instead
     */
    export type PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PreferencesDefaultArgs instead
     */
    export type PreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PreferencesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RelationshipDefaultArgs instead
     */
    export type RelationshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RelationshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TokenDefaultArgs instead
     */
    export type TokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}