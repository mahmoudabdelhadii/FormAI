
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model AdminToken
 * 
 */
export type AdminToken = $Result.DefaultSelection<Prisma.$AdminTokenPayload>
/**
 * Model BannedUsers
 * 
 */
export type BannedUsers = $Result.DefaultSelection<Prisma.$BannedUsersPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Community
 * 
 */
export type Community = $Result.DefaultSelection<Prisma.$CommunityPayload>
/**
 * Model CommunityRequest
 * 
 */
export type CommunityRequest = $Result.DefaultSelection<Prisma.$CommunityRequestPayload>
/**
 * Model Context
 * 
 */
export type Context = $Result.DefaultSelection<Prisma.$ContextPayload>
/**
 * Model Like
 * 
 */
export type Like = $Result.DefaultSelection<Prisma.$LikePayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>
/**
 * Model PendingPost
 * 
 */
export type PendingPost = $Result.DefaultSelection<Prisma.$PendingPostPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Preferences
 * 
 */
export type Preferences = $Result.DefaultSelection<Prisma.$PreferencesPayload>
/**
 * Model Relationship
 * 
 */
export type Relationship = $Result.DefaultSelection<Prisma.$RelationshipPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model Token
 * 
 */
export type Token = $Result.DefaultSelection<Prisma.$TokenPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserRoles
 * 
 */
export type UserRoles = $Result.DefaultSelection<Prisma.$UserRolesPayload>
/**
 * Model Email
 * 
 */
export type Email = $Result.DefaultSelection<Prisma.$EmailPayload>
/**
 * Model EmailFor
 * 
 */
export type EmailFor = $Result.DefaultSelection<Prisma.$EmailForPayload>
/**
 * Model Leaderboard
 * 
 */
export type Leaderboard = $Result.DefaultSelection<Prisma.$LeaderboardPayload>
/**
 * Model LeaderboardSubmission
 * 
 */
export type LeaderboardSubmission = $Result.DefaultSelection<Prisma.$LeaderboardSubmissionPayload>
/**
 * Model LeaderboardSubmissionType
 * 
 */
export type LeaderboardSubmissionType = $Result.DefaultSelection<Prisma.$LeaderboardSubmissionTypePayload>
/**
 * Model PendingPostStatus
 * 
 */
export type PendingPostStatus = $Result.DefaultSelection<Prisma.$PendingPostStatusPayload>
/**
 * Model LogLevel
 * 
 */
export type LogLevel = $Result.DefaultSelection<Prisma.$LogLevelPayload>
/**
 * Model LogType
 * 
 */
export type LogType = $Result.DefaultSelection<Prisma.$LogTypePayload>
/**
 * Model SuspiciousLogin
 * 
 */
export type SuspiciousLogin = $Result.DefaultSelection<Prisma.$SuspiciousLoginPayload>
/**
 * Model CommunityUser
 * 
 */
export type CommunityUser = $Result.DefaultSelection<Prisma.$CommunityUserPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs>;

  /**
   * `prisma.adminToken`: Exposes CRUD operations for the **AdminToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminTokens
    * const adminTokens = await prisma.adminToken.findMany()
    * ```
    */
  get adminToken(): Prisma.AdminTokenDelegate<ExtArgs>;

  /**
   * `prisma.bannedUsers`: Exposes CRUD operations for the **BannedUsers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BannedUsers
    * const bannedUsers = await prisma.bannedUsers.findMany()
    * ```
    */
  get bannedUsers(): Prisma.BannedUsersDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.community`: Exposes CRUD operations for the **Community** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Communities
    * const communities = await prisma.community.findMany()
    * ```
    */
  get community(): Prisma.CommunityDelegate<ExtArgs>;

  /**
   * `prisma.communityRequest`: Exposes CRUD operations for the **CommunityRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityRequests
    * const communityRequests = await prisma.communityRequest.findMany()
    * ```
    */
  get communityRequest(): Prisma.CommunityRequestDelegate<ExtArgs>;

  /**
   * `prisma.context`: Exposes CRUD operations for the **Context** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contexts
    * const contexts = await prisma.context.findMany()
    * ```
    */
  get context(): Prisma.ContextDelegate<ExtArgs>;

  /**
   * `prisma.like`: Exposes CRUD operations for the **Like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.like.findMany()
    * ```
    */
  get like(): Prisma.LikeDelegate<ExtArgs>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs>;

  /**
   * `prisma.pendingPost`: Exposes CRUD operations for the **PendingPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingPosts
    * const pendingPosts = await prisma.pendingPost.findMany()
    * ```
    */
  get pendingPost(): Prisma.PendingPostDelegate<ExtArgs>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs>;

  /**
   * `prisma.preferences`: Exposes CRUD operations for the **Preferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Preferences
    * const preferences = await prisma.preferences.findMany()
    * ```
    */
  get preferences(): Prisma.PreferencesDelegate<ExtArgs>;

  /**
   * `prisma.relationship`: Exposes CRUD operations for the **Relationship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Relationships
    * const relationships = await prisma.relationship.findMany()
    * ```
    */
  get relationship(): Prisma.RelationshipDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.token`: Exposes CRUD operations for the **Token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.token.findMany()
    * ```
    */
  get token(): Prisma.TokenDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.userRoles`: Exposes CRUD operations for the **UserRoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRoles.findMany()
    * ```
    */
  get userRoles(): Prisma.UserRolesDelegate<ExtArgs>;

  /**
   * `prisma.email`: Exposes CRUD operations for the **Email** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emails
    * const emails = await prisma.email.findMany()
    * ```
    */
  get email(): Prisma.EmailDelegate<ExtArgs>;

  /**
   * `prisma.emailFor`: Exposes CRUD operations for the **EmailFor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailFors
    * const emailFors = await prisma.emailFor.findMany()
    * ```
    */
  get emailFor(): Prisma.EmailForDelegate<ExtArgs>;

  /**
   * `prisma.leaderboard`: Exposes CRUD operations for the **Leaderboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaderboards
    * const leaderboards = await prisma.leaderboard.findMany()
    * ```
    */
  get leaderboard(): Prisma.LeaderboardDelegate<ExtArgs>;

  /**
   * `prisma.leaderboardSubmission`: Exposes CRUD operations for the **LeaderboardSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaderboardSubmissions
    * const leaderboardSubmissions = await prisma.leaderboardSubmission.findMany()
    * ```
    */
  get leaderboardSubmission(): Prisma.LeaderboardSubmissionDelegate<ExtArgs>;

  /**
   * `prisma.leaderboardSubmissionType`: Exposes CRUD operations for the **LeaderboardSubmissionType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaderboardSubmissionTypes
    * const leaderboardSubmissionTypes = await prisma.leaderboardSubmissionType.findMany()
    * ```
    */
  get leaderboardSubmissionType(): Prisma.LeaderboardSubmissionTypeDelegate<ExtArgs>;

  /**
   * `prisma.pendingPostStatus`: Exposes CRUD operations for the **PendingPostStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingPostStatuses
    * const pendingPostStatuses = await prisma.pendingPostStatus.findMany()
    * ```
    */
  get pendingPostStatus(): Prisma.PendingPostStatusDelegate<ExtArgs>;

  /**
   * `prisma.logLevel`: Exposes CRUD operations for the **LogLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogLevels
    * const logLevels = await prisma.logLevel.findMany()
    * ```
    */
  get logLevel(): Prisma.LogLevelDelegate<ExtArgs>;

  /**
   * `prisma.logType`: Exposes CRUD operations for the **LogType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogTypes
    * const logTypes = await prisma.logType.findMany()
    * ```
    */
  get logType(): Prisma.LogTypeDelegate<ExtArgs>;

  /**
   * `prisma.suspiciousLogin`: Exposes CRUD operations for the **SuspiciousLogin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuspiciousLogins
    * const suspiciousLogins = await prisma.suspiciousLogin.findMany()
    * ```
    */
  get suspiciousLogin(): Prisma.SuspiciousLoginDelegate<ExtArgs>;

  /**
   * `prisma.communityUser`: Exposes CRUD operations for the **CommunityUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityUsers
    * const communityUsers = await prisma.communityUser.findMany()
    * ```
    */
  get communityUser(): Prisma.CommunityUserDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.12.1
   * Query Engine version: 473ed3124229e22d881cb7addf559799debae1ab
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Admin: 'Admin',
    AdminToken: 'AdminToken',
    BannedUsers: 'BannedUsers',
    Comment: 'Comment',
    Community: 'Community',
    CommunityRequest: 'CommunityRequest',
    Context: 'Context',
    Like: 'Like',
    Log: 'Log',
    PendingPost: 'PendingPost',
    Post: 'Post',
    Preferences: 'Preferences',
    Relationship: 'Relationship',
    Report: 'Report',
    Token: 'Token',
    User: 'User',
    UserRoles: 'UserRoles',
    Email: 'Email',
    EmailFor: 'EmailFor',
    Leaderboard: 'Leaderboard',
    LeaderboardSubmission: 'LeaderboardSubmission',
    LeaderboardSubmissionType: 'LeaderboardSubmissionType',
    PendingPostStatus: 'PendingPostStatus',
    LogLevel: 'LogLevel',
    LogType: 'LogType',
    SuspiciousLogin: 'SuspiciousLogin',
    CommunityUser: 'CommunityUser'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'admin' | 'adminToken' | 'bannedUsers' | 'comment' | 'community' | 'communityRequest' | 'context' | 'like' | 'log' | 'pendingPost' | 'post' | 'preferences' | 'relationship' | 'report' | 'token' | 'user' | 'userRoles' | 'email' | 'emailFor' | 'leaderboard' | 'leaderboardSubmission' | 'leaderboardSubmissionType' | 'pendingPostStatus' | 'logLevel' | 'logType' | 'suspiciousLogin' | 'communityUser'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>,
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      AdminToken: {
        payload: Prisma.$AdminTokenPayload<ExtArgs>
        fields: Prisma.AdminTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminTokenPayload>
          }
          findFirst: {
            args: Prisma.AdminTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminTokenPayload>
          }
          findMany: {
            args: Prisma.AdminTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminTokenPayload>[]
          }
          create: {
            args: Prisma.AdminTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminTokenPayload>
          }
          createMany: {
            args: Prisma.AdminTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdminTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminTokenPayload>
          }
          update: {
            args: Prisma.AdminTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminTokenPayload>
          }
          deleteMany: {
            args: Prisma.AdminTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdminTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdminTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminTokenPayload>
          }
          aggregate: {
            args: Prisma.AdminTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdminToken>
          }
          groupBy: {
            args: Prisma.AdminTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdminTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<AdminTokenCountAggregateOutputType> | number
          }
        }
      }
      BannedUsers: {
        payload: Prisma.$BannedUsersPayload<ExtArgs>
        fields: Prisma.BannedUsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannedUsersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannedUsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannedUsersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannedUsersPayload>
          }
          findFirst: {
            args: Prisma.BannedUsersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannedUsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannedUsersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannedUsersPayload>
          }
          findMany: {
            args: Prisma.BannedUsersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannedUsersPayload>[]
          }
          create: {
            args: Prisma.BannedUsersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannedUsersPayload>
          }
          createMany: {
            args: Prisma.BannedUsersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BannedUsersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannedUsersPayload>
          }
          update: {
            args: Prisma.BannedUsersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannedUsersPayload>
          }
          deleteMany: {
            args: Prisma.BannedUsersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BannedUsersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BannedUsersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannedUsersPayload>
          }
          aggregate: {
            args: Prisma.BannedUsersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBannedUsers>
          }
          groupBy: {
            args: Prisma.BannedUsersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BannedUsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannedUsersCountArgs<ExtArgs>,
            result: $Utils.Optional<BannedUsersCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>,
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Community: {
        payload: Prisma.$CommunityPayload<ExtArgs>
        fields: Prisma.CommunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          findFirst: {
            args: Prisma.CommunityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          findMany: {
            args: Prisma.CommunityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>[]
          }
          create: {
            args: Prisma.CommunityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          createMany: {
            args: Prisma.CommunityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommunityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          update: {
            args: Prisma.CommunityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          deleteMany: {
            args: Prisma.CommunityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommunityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          aggregate: {
            args: Prisma.CommunityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCommunity>
          }
          groupBy: {
            args: Prisma.CommunityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityCountArgs<ExtArgs>,
            result: $Utils.Optional<CommunityCountAggregateOutputType> | number
          }
        }
      }
      CommunityRequest: {
        payload: Prisma.$CommunityRequestPayload<ExtArgs>
        fields: Prisma.CommunityRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityRequestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityRequestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityRequestPayload>
          }
          findFirst: {
            args: Prisma.CommunityRequestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityRequestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityRequestPayload>
          }
          findMany: {
            args: Prisma.CommunityRequestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityRequestPayload>[]
          }
          create: {
            args: Prisma.CommunityRequestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityRequestPayload>
          }
          createMany: {
            args: Prisma.CommunityRequestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommunityRequestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityRequestPayload>
          }
          update: {
            args: Prisma.CommunityRequestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityRequestPayload>
          }
          deleteMany: {
            args: Prisma.CommunityRequestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityRequestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommunityRequestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityRequestPayload>
          }
          aggregate: {
            args: Prisma.CommunityRequestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCommunityRequest>
          }
          groupBy: {
            args: Prisma.CommunityRequestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommunityRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityRequestCountArgs<ExtArgs>,
            result: $Utils.Optional<CommunityRequestCountAggregateOutputType> | number
          }
        }
      }
      Context: {
        payload: Prisma.$ContextPayload<ExtArgs>
        fields: Prisma.ContextFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContextFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContextPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContextFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContextPayload>
          }
          findFirst: {
            args: Prisma.ContextFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContextPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContextFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContextPayload>
          }
          findMany: {
            args: Prisma.ContextFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContextPayload>[]
          }
          create: {
            args: Prisma.ContextCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContextPayload>
          }
          createMany: {
            args: Prisma.ContextCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContextDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContextPayload>
          }
          update: {
            args: Prisma.ContextUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContextPayload>
          }
          deleteMany: {
            args: Prisma.ContextDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContextUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContextUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContextPayload>
          }
          aggregate: {
            args: Prisma.ContextAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContext>
          }
          groupBy: {
            args: Prisma.ContextGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContextGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContextCountArgs<ExtArgs>,
            result: $Utils.Optional<ContextCountAggregateOutputType> | number
          }
        }
      }
      Like: {
        payload: Prisma.$LikePayload<ExtArgs>
        fields: Prisma.LikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findFirst: {
            args: Prisma.LikeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findMany: {
            args: Prisma.LikeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          create: {
            args: Prisma.LikeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          createMany: {
            args: Prisma.LikeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LikeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          update: {
            args: Prisma.LikeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          deleteMany: {
            args: Prisma.LikeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LikeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LikeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          aggregate: {
            args: Prisma.LikeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLike>
          }
          groupBy: {
            args: Prisma.LikeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikeCountArgs<ExtArgs>,
            result: $Utils.Optional<LikeCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>,
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      PendingPost: {
        payload: Prisma.$PendingPostPayload<ExtArgs>
        fields: Prisma.PendingPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendingPostFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendingPostFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostPayload>
          }
          findFirst: {
            args: Prisma.PendingPostFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendingPostFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostPayload>
          }
          findMany: {
            args: Prisma.PendingPostFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostPayload>[]
          }
          create: {
            args: Prisma.PendingPostCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostPayload>
          }
          createMany: {
            args: Prisma.PendingPostCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PendingPostDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostPayload>
          }
          update: {
            args: Prisma.PendingPostUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostPayload>
          }
          deleteMany: {
            args: Prisma.PendingPostDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PendingPostUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PendingPostUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostPayload>
          }
          aggregate: {
            args: Prisma.PendingPostAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePendingPost>
          }
          groupBy: {
            args: Prisma.PendingPostGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PendingPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendingPostCountArgs<ExtArgs>,
            result: $Utils.Optional<PendingPostCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>,
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Preferences: {
        payload: Prisma.$PreferencesPayload<ExtArgs>
        fields: Prisma.PreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PreferencesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PreferencesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>
          }
          findFirst: {
            args: Prisma.PreferencesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PreferencesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>
          }
          findMany: {
            args: Prisma.PreferencesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>[]
          }
          create: {
            args: Prisma.PreferencesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>
          }
          createMany: {
            args: Prisma.PreferencesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PreferencesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>
          }
          update: {
            args: Prisma.PreferencesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>
          }
          deleteMany: {
            args: Prisma.PreferencesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PreferencesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PreferencesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>
          }
          aggregate: {
            args: Prisma.PreferencesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePreferences>
          }
          groupBy: {
            args: Prisma.PreferencesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.PreferencesCountArgs<ExtArgs>,
            result: $Utils.Optional<PreferencesCountAggregateOutputType> | number
          }
        }
      }
      Relationship: {
        payload: Prisma.$RelationshipPayload<ExtArgs>
        fields: Prisma.RelationshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelationshipFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelationshipFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          findFirst: {
            args: Prisma.RelationshipFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelationshipFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          findMany: {
            args: Prisma.RelationshipFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>[]
          }
          create: {
            args: Prisma.RelationshipCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          createMany: {
            args: Prisma.RelationshipCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RelationshipDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          update: {
            args: Prisma.RelationshipUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          deleteMany: {
            args: Prisma.RelationshipDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RelationshipUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RelationshipUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          aggregate: {
            args: Prisma.RelationshipAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRelationship>
          }
          groupBy: {
            args: Prisma.RelationshipGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RelationshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelationshipCountArgs<ExtArgs>,
            result: $Utils.Optional<RelationshipCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>,
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      Token: {
        payload: Prisma.$TokenPayload<ExtArgs>
        fields: Prisma.TokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findFirst: {
            args: Prisma.TokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findMany: {
            args: Prisma.TokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          create: {
            args: Prisma.TokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          createMany: {
            args: Prisma.TokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          update: {
            args: Prisma.TokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          deleteMany: {
            args: Prisma.TokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          aggregate: {
            args: Prisma.TokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateToken>
          }
          groupBy: {
            args: Prisma.TokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenCountArgs<ExtArgs>,
            result: $Utils.Optional<TokenCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserRoles: {
        payload: Prisma.$UserRolesPayload<ExtArgs>
        fields: Prisma.UserRolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRolesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRolesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload>
          }
          findFirst: {
            args: Prisma.UserRolesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRolesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload>
          }
          findMany: {
            args: Prisma.UserRolesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload>[]
          }
          create: {
            args: Prisma.UserRolesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload>
          }
          createMany: {
            args: Prisma.UserRolesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserRolesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload>
          }
          update: {
            args: Prisma.UserRolesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload>
          }
          deleteMany: {
            args: Prisma.UserRolesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserRolesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserRolesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload>
          }
          aggregate: {
            args: Prisma.UserRolesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserRoles>
          }
          groupBy: {
            args: Prisma.UserRolesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserRolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRolesCountArgs<ExtArgs>,
            result: $Utils.Optional<UserRolesCountAggregateOutputType> | number
          }
        }
      }
      Email: {
        payload: Prisma.$EmailPayload<ExtArgs>
        fields: Prisma.EmailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          findFirst: {
            args: Prisma.EmailFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          findMany: {
            args: Prisma.EmailFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>[]
          }
          create: {
            args: Prisma.EmailCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          createMany: {
            args: Prisma.EmailCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          update: {
            args: Prisma.EmailUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          deleteMany: {
            args: Prisma.EmailDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          aggregate: {
            args: Prisma.EmailAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmail>
          }
          groupBy: {
            args: Prisma.EmailGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailCountAggregateOutputType> | number
          }
        }
      }
      EmailFor: {
        payload: Prisma.$EmailForPayload<ExtArgs>
        fields: Prisma.EmailForFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailForFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailForPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailForFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailForPayload>
          }
          findFirst: {
            args: Prisma.EmailForFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailForPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailForFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailForPayload>
          }
          findMany: {
            args: Prisma.EmailForFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailForPayload>[]
          }
          create: {
            args: Prisma.EmailForCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailForPayload>
          }
          createMany: {
            args: Prisma.EmailForCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailForDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailForPayload>
          }
          update: {
            args: Prisma.EmailForUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailForPayload>
          }
          deleteMany: {
            args: Prisma.EmailForDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailForUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailForUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailForPayload>
          }
          aggregate: {
            args: Prisma.EmailForAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailFor>
          }
          groupBy: {
            args: Prisma.EmailForGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailForGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailForCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailForCountAggregateOutputType> | number
          }
        }
      }
      Leaderboard: {
        payload: Prisma.$LeaderboardPayload<ExtArgs>
        fields: Prisma.LeaderboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaderboardFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaderboardFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          findFirst: {
            args: Prisma.LeaderboardFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaderboardFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          findMany: {
            args: Prisma.LeaderboardFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>[]
          }
          create: {
            args: Prisma.LeaderboardCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          createMany: {
            args: Prisma.LeaderboardCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LeaderboardDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          update: {
            args: Prisma.LeaderboardUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          deleteMany: {
            args: Prisma.LeaderboardDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LeaderboardUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LeaderboardUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          aggregate: {
            args: Prisma.LeaderboardAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLeaderboard>
          }
          groupBy: {
            args: Prisma.LeaderboardGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LeaderboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaderboardCountArgs<ExtArgs>,
            result: $Utils.Optional<LeaderboardCountAggregateOutputType> | number
          }
        }
      }
      LeaderboardSubmission: {
        payload: Prisma.$LeaderboardSubmissionPayload<ExtArgs>
        fields: Prisma.LeaderboardSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaderboardSubmissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaderboardSubmissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSubmissionPayload>
          }
          findFirst: {
            args: Prisma.LeaderboardSubmissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaderboardSubmissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSubmissionPayload>
          }
          findMany: {
            args: Prisma.LeaderboardSubmissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSubmissionPayload>[]
          }
          create: {
            args: Prisma.LeaderboardSubmissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSubmissionPayload>
          }
          createMany: {
            args: Prisma.LeaderboardSubmissionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LeaderboardSubmissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSubmissionPayload>
          }
          update: {
            args: Prisma.LeaderboardSubmissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.LeaderboardSubmissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LeaderboardSubmissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LeaderboardSubmissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSubmissionPayload>
          }
          aggregate: {
            args: Prisma.LeaderboardSubmissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLeaderboardSubmission>
          }
          groupBy: {
            args: Prisma.LeaderboardSubmissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LeaderboardSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaderboardSubmissionCountArgs<ExtArgs>,
            result: $Utils.Optional<LeaderboardSubmissionCountAggregateOutputType> | number
          }
        }
      }
      LeaderboardSubmissionType: {
        payload: Prisma.$LeaderboardSubmissionTypePayload<ExtArgs>
        fields: Prisma.LeaderboardSubmissionTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaderboardSubmissionTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSubmissionTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaderboardSubmissionTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSubmissionTypePayload>
          }
          findFirst: {
            args: Prisma.LeaderboardSubmissionTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSubmissionTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaderboardSubmissionTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSubmissionTypePayload>
          }
          findMany: {
            args: Prisma.LeaderboardSubmissionTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSubmissionTypePayload>[]
          }
          create: {
            args: Prisma.LeaderboardSubmissionTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSubmissionTypePayload>
          }
          createMany: {
            args: Prisma.LeaderboardSubmissionTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LeaderboardSubmissionTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSubmissionTypePayload>
          }
          update: {
            args: Prisma.LeaderboardSubmissionTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSubmissionTypePayload>
          }
          deleteMany: {
            args: Prisma.LeaderboardSubmissionTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LeaderboardSubmissionTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LeaderboardSubmissionTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSubmissionTypePayload>
          }
          aggregate: {
            args: Prisma.LeaderboardSubmissionTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLeaderboardSubmissionType>
          }
          groupBy: {
            args: Prisma.LeaderboardSubmissionTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LeaderboardSubmissionTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaderboardSubmissionTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<LeaderboardSubmissionTypeCountAggregateOutputType> | number
          }
        }
      }
      PendingPostStatus: {
        payload: Prisma.$PendingPostStatusPayload<ExtArgs>
        fields: Prisma.PendingPostStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendingPostStatusFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendingPostStatusFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostStatusPayload>
          }
          findFirst: {
            args: Prisma.PendingPostStatusFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendingPostStatusFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostStatusPayload>
          }
          findMany: {
            args: Prisma.PendingPostStatusFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostStatusPayload>[]
          }
          create: {
            args: Prisma.PendingPostStatusCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostStatusPayload>
          }
          createMany: {
            args: Prisma.PendingPostStatusCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PendingPostStatusDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostStatusPayload>
          }
          update: {
            args: Prisma.PendingPostStatusUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostStatusPayload>
          }
          deleteMany: {
            args: Prisma.PendingPostStatusDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PendingPostStatusUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PendingPostStatusUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PendingPostStatusPayload>
          }
          aggregate: {
            args: Prisma.PendingPostStatusAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePendingPostStatus>
          }
          groupBy: {
            args: Prisma.PendingPostStatusGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PendingPostStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendingPostStatusCountArgs<ExtArgs>,
            result: $Utils.Optional<PendingPostStatusCountAggregateOutputType> | number
          }
        }
      }
      LogLevel: {
        payload: Prisma.$LogLevelPayload<ExtArgs>
        fields: Prisma.LogLevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogLevelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogLevelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLevelPayload>
          }
          findFirst: {
            args: Prisma.LogLevelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogLevelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLevelPayload>
          }
          findMany: {
            args: Prisma.LogLevelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLevelPayload>[]
          }
          create: {
            args: Prisma.LogLevelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLevelPayload>
          }
          createMany: {
            args: Prisma.LogLevelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogLevelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLevelPayload>
          }
          update: {
            args: Prisma.LogLevelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLevelPayload>
          }
          deleteMany: {
            args: Prisma.LogLevelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogLevelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogLevelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLevelPayload>
          }
          aggregate: {
            args: Prisma.LogLevelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogLevel>
          }
          groupBy: {
            args: Prisma.LogLevelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogLevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogLevelCountArgs<ExtArgs>,
            result: $Utils.Optional<LogLevelCountAggregateOutputType> | number
          }
        }
      }
      LogType: {
        payload: Prisma.$LogTypePayload<ExtArgs>
        fields: Prisma.LogTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogTypePayload>
          }
          findFirst: {
            args: Prisma.LogTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogTypePayload>
          }
          findMany: {
            args: Prisma.LogTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogTypePayload>[]
          }
          create: {
            args: Prisma.LogTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogTypePayload>
          }
          createMany: {
            args: Prisma.LogTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogTypePayload>
          }
          update: {
            args: Prisma.LogTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogTypePayload>
          }
          deleteMany: {
            args: Prisma.LogTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogTypePayload>
          }
          aggregate: {
            args: Prisma.LogTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogType>
          }
          groupBy: {
            args: Prisma.LogTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<LogTypeCountAggregateOutputType> | number
          }
        }
      }
      SuspiciousLogin: {
        payload: Prisma.$SuspiciousLoginPayload<ExtArgs>
        fields: Prisma.SuspiciousLoginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuspiciousLoginFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SuspiciousLoginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuspiciousLoginFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SuspiciousLoginPayload>
          }
          findFirst: {
            args: Prisma.SuspiciousLoginFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SuspiciousLoginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuspiciousLoginFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SuspiciousLoginPayload>
          }
          findMany: {
            args: Prisma.SuspiciousLoginFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SuspiciousLoginPayload>[]
          }
          create: {
            args: Prisma.SuspiciousLoginCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SuspiciousLoginPayload>
          }
          createMany: {
            args: Prisma.SuspiciousLoginCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SuspiciousLoginDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SuspiciousLoginPayload>
          }
          update: {
            args: Prisma.SuspiciousLoginUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SuspiciousLoginPayload>
          }
          deleteMany: {
            args: Prisma.SuspiciousLoginDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SuspiciousLoginUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SuspiciousLoginUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SuspiciousLoginPayload>
          }
          aggregate: {
            args: Prisma.SuspiciousLoginAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSuspiciousLogin>
          }
          groupBy: {
            args: Prisma.SuspiciousLoginGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SuspiciousLoginGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuspiciousLoginCountArgs<ExtArgs>,
            result: $Utils.Optional<SuspiciousLoginCountAggregateOutputType> | number
          }
        }
      }
      CommunityUser: {
        payload: Prisma.$CommunityUserPayload<ExtArgs>
        fields: Prisma.CommunityUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityUserPayload>
          }
          findFirst: {
            args: Prisma.CommunityUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityUserPayload>
          }
          findMany: {
            args: Prisma.CommunityUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityUserPayload>[]
          }
          create: {
            args: Prisma.CommunityUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityUserPayload>
          }
          createMany: {
            args: Prisma.CommunityUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommunityUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityUserPayload>
          }
          update: {
            args: Prisma.CommunityUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityUserPayload>
          }
          deleteMany: {
            args: Prisma.CommunityUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommunityUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityUserPayload>
          }
          aggregate: {
            args: Prisma.CommunityUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCommunityUser>
          }
          groupBy: {
            args: Prisma.CommunityUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommunityUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityUserCountArgs<ExtArgs>,
            result: $Utils.Optional<CommunityUserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CommunityCountOutputType
   */

  export type CommunityCountOutputType = {
    CommunityUser: number
    CommunityRequest: number
    BannedUsers: number
  }

  export type CommunityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CommunityUser?: boolean | CommunityCountOutputTypeCountCommunityUserArgs
    CommunityRequest?: boolean | CommunityCountOutputTypeCountCommunityRequestArgs
    BannedUsers?: boolean | CommunityCountOutputTypeCountBannedUsersArgs
  }

  // Custom InputTypes

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCountOutputType
     */
    select?: CommunityCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountCommunityUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityUserWhereInput
  }


  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountCommunityRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityRequestWhereInput
  }


  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountBannedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannedUsersWhereInput
  }



  /**
   * Count Type PendingPostCountOutputType
   */

  export type PendingPostCountOutputType = {
    PendingPostStatus: number
  }

  export type PendingPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PendingPostStatus?: boolean | PendingPostCountOutputTypeCountPendingPostStatusArgs
  }

  // Custom InputTypes

  /**
   * PendingPostCountOutputType without action
   */
  export type PendingPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPostCountOutputType
     */
    select?: PendingPostCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PendingPostCountOutputType without action
   */
  export type PendingPostCountOutputTypeCountPendingPostStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingPostStatusWhereInput
  }



  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    Comment: number
    Like: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | PostCountOutputTypeCountCommentArgs
    Like?: boolean | PostCountOutputTypeCountLikeArgs
  }

  // Custom InputTypes

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountLikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    CommunityUser: number
    Token: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CommunityUser?: boolean | UserCountOutputTypeCountCommunityUserArgs
    Token?: boolean | UserCountOutputTypeCountTokenArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommunityUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityUserWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
  }



  /**
   * Count Type UserRolesCountOutputType
   */

  export type UserRolesCountOutputType = {
    CommunityUser: number
  }

  export type UserRolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CommunityUser?: boolean | UserRolesCountOutputTypeCountCommunityUserArgs
  }

  // Custom InputTypes

  /**
   * UserRolesCountOutputType without action
   */
  export type UserRolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRolesCountOutputType
     */
    select?: UserRolesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserRolesCountOutputType without action
   */
  export type UserRolesCountOutputTypeCountCommunityUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityUserWhereInput
  }



  /**
   * Count Type EmailForCountOutputType
   */

  export type EmailForCountOutputType = {
    Email: number
  }

  export type EmailForCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Email?: boolean | EmailForCountOutputTypeCountEmailArgs
  }

  // Custom InputTypes

  /**
   * EmailForCountOutputType without action
   */
  export type EmailForCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailForCountOutputType
     */
    select?: EmailForCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EmailForCountOutputType without action
   */
  export type EmailForCountOutputTypeCountEmailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailWhereInput
  }



  /**
   * Count Type LeaderboardCountOutputType
   */

  export type LeaderboardCountOutputType = {
    LeaderboardSubmission: number
  }

  export type LeaderboardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LeaderboardSubmission?: boolean | LeaderboardCountOutputTypeCountLeaderboardSubmissionArgs
  }

  // Custom InputTypes

  /**
   * LeaderboardCountOutputType without action
   */
  export type LeaderboardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardCountOutputType
     */
    select?: LeaderboardCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LeaderboardCountOutputType without action
   */
  export type LeaderboardCountOutputTypeCountLeaderboardSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardSubmissionWhereInput
  }



  /**
   * Count Type LeaderboardSubmissionCountOutputType
   */

  export type LeaderboardSubmissionCountOutputType = {
    LeaderboardSubmissionType: number
  }

  export type LeaderboardSubmissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LeaderboardSubmissionType?: boolean | LeaderboardSubmissionCountOutputTypeCountLeaderboardSubmissionTypeArgs
  }

  // Custom InputTypes

  /**
   * LeaderboardSubmissionCountOutputType without action
   */
  export type LeaderboardSubmissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmissionCountOutputType
     */
    select?: LeaderboardSubmissionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LeaderboardSubmissionCountOutputType without action
   */
  export type LeaderboardSubmissionCountOutputTypeCountLeaderboardSubmissionTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardSubmissionTypeWhereInput
  }



  /**
   * Count Type PendingPostStatusCountOutputType
   */

  export type PendingPostStatusCountOutputType = {
    PendingPost: number
  }

  export type PendingPostStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PendingPost?: boolean | PendingPostStatusCountOutputTypeCountPendingPostArgs
  }

  // Custom InputTypes

  /**
   * PendingPostStatusCountOutputType without action
   */
  export type PendingPostStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPostStatusCountOutputType
     */
    select?: PendingPostStatusCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PendingPostStatusCountOutputType without action
   */
  export type PendingPostStatusCountOutputTypeCountPendingPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingPostWhereInput
  }



  /**
   * Count Type LogLevelCountOutputType
   */

  export type LogLevelCountOutputType = {
    Log: number
  }

  export type LogLevelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Log?: boolean | LogLevelCountOutputTypeCountLogArgs
  }

  // Custom InputTypes

  /**
   * LogLevelCountOutputType without action
   */
  export type LogLevelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLevelCountOutputType
     */
    select?: LogLevelCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LogLevelCountOutputType without action
   */
  export type LogLevelCountOutputTypeCountLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }



  /**
   * Count Type LogTypeCountOutputType
   */

  export type LogTypeCountOutputType = {
    Log: number
  }

  export type LogTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Log?: boolean | LogTypeCountOutputTypeCountLogArgs
  }

  // Custom InputTypes

  /**
   * LogTypeCountOutputType without action
   */
  export type LogTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogTypeCountOutputType
     */
    select?: LogTypeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LogTypeCountOutputType without action
   */
  export type LogTypeCountOutputTypeCountLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    username: number
    password: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    username: string | null
    password: string | null
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    AdminToken?: boolean | Admin$AdminTokenArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
  }

  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AdminToken?: boolean | Admin$AdminTokenArgs<ExtArgs>
  }


  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      AdminToken: Prisma.$AdminTokenPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string | null
      password: string | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }


  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
    **/
    create<T extends AdminCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminCreateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Admins.
     *     @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     *     @example
     *     // Create many Admins
     *     const admin = await prisma.admin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
    **/
    delete<T extends AdminDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
    **/
    upsert<T extends AdminUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    AdminToken<T extends Admin$AdminTokenArgs<ExtArgs> = {}>(args?: Subset<T, Admin$AdminTokenArgs<ExtArgs>>): Prisma__AdminTokenClient<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly username: FieldRef<"Admin", 'String'>
    readonly password: FieldRef<"Admin", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data?: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }


  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }


  /**
   * Admin.AdminToken
   */
  export type Admin$AdminTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminTokenInclude<ExtArgs> | null
    where?: AdminTokenWhereInput
  }


  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
  }



  /**
   * Model AdminToken
   */

  export type AggregateAdminToken = {
    _count: AdminTokenCountAggregateOutputType | null
    _avg: AdminTokenAvgAggregateOutputType | null
    _sum: AdminTokenSumAggregateOutputType | null
    _min: AdminTokenMinAggregateOutputType | null
    _max: AdminTokenMaxAggregateOutputType | null
  }

  export type AdminTokenAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminTokenSumAggregateOutputType = {
    id: number | null
  }

  export type AdminTokenMinAggregateOutputType = {
    id: number | null
    user: string | null
    accessToken: string | null
  }

  export type AdminTokenMaxAggregateOutputType = {
    id: number | null
    user: string | null
    accessToken: string | null
  }

  export type AdminTokenCountAggregateOutputType = {
    id: number
    user: number
    accessToken: number
    _all: number
  }


  export type AdminTokenAvgAggregateInputType = {
    id?: true
  }

  export type AdminTokenSumAggregateInputType = {
    id?: true
  }

  export type AdminTokenMinAggregateInputType = {
    id?: true
    user?: true
    accessToken?: true
  }

  export type AdminTokenMaxAggregateInputType = {
    id?: true
    user?: true
    accessToken?: true
  }

  export type AdminTokenCountAggregateInputType = {
    id?: true
    user?: true
    accessToken?: true
    _all?: true
  }

  export type AdminTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminToken to aggregate.
     */
    where?: AdminTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTokens to fetch.
     */
    orderBy?: AdminTokenOrderByWithRelationInput | AdminTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminTokens
    **/
    _count?: true | AdminTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminTokenMaxAggregateInputType
  }

  export type GetAdminTokenAggregateType<T extends AdminTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminToken[P]>
      : GetScalarType<T[P], AggregateAdminToken[P]>
  }




  export type AdminTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminTokenWhereInput
    orderBy?: AdminTokenOrderByWithAggregationInput | AdminTokenOrderByWithAggregationInput[]
    by: AdminTokenScalarFieldEnum[] | AdminTokenScalarFieldEnum
    having?: AdminTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminTokenCountAggregateInputType | true
    _avg?: AdminTokenAvgAggregateInputType
    _sum?: AdminTokenSumAggregateInputType
    _min?: AdminTokenMinAggregateInputType
    _max?: AdminTokenMaxAggregateInputType
  }

  export type AdminTokenGroupByOutputType = {
    id: number
    user: string
    accessToken: string | null
    _count: AdminTokenCountAggregateOutputType | null
    _avg: AdminTokenAvgAggregateOutputType | null
    _sum: AdminTokenSumAggregateOutputType | null
    _min: AdminTokenMinAggregateOutputType | null
    _max: AdminTokenMaxAggregateOutputType | null
  }

  type GetAdminTokenGroupByPayload<T extends AdminTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminTokenGroupByOutputType[P]>
            : GetScalarType<T[P], AdminTokenGroupByOutputType[P]>
        }
      >
    >


  export type AdminTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user?: boolean
    accessToken?: boolean
    Admin?: boolean | AdminToken$AdminArgs<ExtArgs>
  }, ExtArgs["result"]["adminToken"]>

  export type AdminTokenSelectScalar = {
    id?: boolean
    user?: boolean
    accessToken?: boolean
  }

  export type AdminTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Admin?: boolean | AdminToken$AdminArgs<ExtArgs>
  }


  export type $AdminTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminToken"
    objects: {
      Admin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user: string
      accessToken: string | null
    }, ExtArgs["result"]["adminToken"]>
    composites: {}
  }


  type AdminTokenGetPayload<S extends boolean | null | undefined | AdminTokenDefaultArgs> = $Result.GetResult<Prisma.$AdminTokenPayload, S>

  type AdminTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: AdminTokenCountAggregateInputType | true
    }

  export interface AdminTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminToken'], meta: { name: 'AdminToken' } }
    /**
     * Find zero or one AdminToken that matches the filter.
     * @param {AdminTokenFindUniqueArgs} args - Arguments to find a AdminToken
     * @example
     * // Get one AdminToken
     * const adminToken = await prisma.adminToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminTokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdminTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__AdminTokenClient<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AdminToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdminTokenFindUniqueOrThrowArgs} args - Arguments to find a AdminToken
     * @example
     * // Get one AdminToken
     * const adminToken = await prisma.adminToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdminTokenClient<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AdminToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTokenFindFirstArgs} args - Arguments to find a AdminToken
     * @example
     * // Get one AdminToken
     * const adminToken = await prisma.adminToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminTokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminTokenFindFirstArgs<ExtArgs>>
    ): Prisma__AdminTokenClient<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AdminToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTokenFindFirstOrThrowArgs} args - Arguments to find a AdminToken
     * @example
     * // Get one AdminToken
     * const adminToken = await prisma.adminToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdminTokenClient<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AdminTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminTokens
     * const adminTokens = await prisma.adminToken.findMany()
     * 
     * // Get first 10 AdminTokens
     * const adminTokens = await prisma.adminToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminTokenWithIdOnly = await prisma.adminToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AdminToken.
     * @param {AdminTokenCreateArgs} args - Arguments to create a AdminToken.
     * @example
     * // Create one AdminToken
     * const AdminToken = await prisma.adminToken.create({
     *   data: {
     *     // ... data to create a AdminToken
     *   }
     * })
     * 
    **/
    create<T extends AdminTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminTokenCreateArgs<ExtArgs>>
    ): Prisma__AdminTokenClient<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AdminTokens.
     *     @param {AdminTokenCreateManyArgs} args - Arguments to create many AdminTokens.
     *     @example
     *     // Create many AdminTokens
     *     const adminToken = await prisma.adminToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdminToken.
     * @param {AdminTokenDeleteArgs} args - Arguments to delete one AdminToken.
     * @example
     * // Delete one AdminToken
     * const AdminToken = await prisma.adminToken.delete({
     *   where: {
     *     // ... filter to delete one AdminToken
     *   }
     * })
     * 
    **/
    delete<T extends AdminTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdminTokenDeleteArgs<ExtArgs>>
    ): Prisma__AdminTokenClient<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AdminToken.
     * @param {AdminTokenUpdateArgs} args - Arguments to update one AdminToken.
     * @example
     * // Update one AdminToken
     * const adminToken = await prisma.adminToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminTokenUpdateArgs<ExtArgs>>
    ): Prisma__AdminTokenClient<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AdminTokens.
     * @param {AdminTokenDeleteManyArgs} args - Arguments to filter AdminTokens to delete.
     * @example
     * // Delete a few AdminTokens
     * const { count } = await prisma.adminToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminTokens
     * const adminToken = await prisma.adminToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdminTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminToken.
     * @param {AdminTokenUpsertArgs} args - Arguments to update or create a AdminToken.
     * @example
     * // Update or create a AdminToken
     * const adminToken = await prisma.adminToken.upsert({
     *   create: {
     *     // ... data to create a AdminToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminToken we want to update
     *   }
     * })
    **/
    upsert<T extends AdminTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdminTokenUpsertArgs<ExtArgs>>
    ): Prisma__AdminTokenClient<$Result.GetResult<Prisma.$AdminTokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AdminTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTokenCountArgs} args - Arguments to filter AdminTokens to count.
     * @example
     * // Count the number of AdminTokens
     * const count = await prisma.adminToken.count({
     *   where: {
     *     // ... the filter for the AdminTokens we want to count
     *   }
     * })
    **/
    count<T extends AdminTokenCountArgs>(
      args?: Subset<T, AdminTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminTokenAggregateArgs>(args: Subset<T, AdminTokenAggregateArgs>): Prisma.PrismaPromise<GetAdminTokenAggregateType<T>>

    /**
     * Group by AdminToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminTokenGroupByArgs['orderBy'] }
        : { orderBy?: AdminTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminToken model
   */
  readonly fields: AdminTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Admin<T extends AdminToken$AdminArgs<ExtArgs> = {}>(args?: Subset<T, AdminToken$AdminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AdminToken model
   */ 
  interface AdminTokenFieldRefs {
    readonly id: FieldRef<"AdminToken", 'Int'>
    readonly user: FieldRef<"AdminToken", 'String'>
    readonly accessToken: FieldRef<"AdminToken", 'String'>
  }
    

  // Custom InputTypes

  /**
   * AdminToken findUnique
   */
  export type AdminTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminTokenInclude<ExtArgs> | null
    /**
     * Filter, which AdminToken to fetch.
     */
    where: AdminTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * AdminToken findUniqueOrThrow
   */
  export type AdminTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminTokenInclude<ExtArgs> | null
    /**
     * Filter, which AdminToken to fetch.
     */
    where: AdminTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * AdminToken findFirst
   */
  export type AdminTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminTokenInclude<ExtArgs> | null
    /**
     * Filter, which AdminToken to fetch.
     */
    where?: AdminTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTokens to fetch.
     */
    orderBy?: AdminTokenOrderByWithRelationInput | AdminTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminTokens.
     */
    cursor?: AdminTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminTokens.
     */
    distinct?: AdminTokenScalarFieldEnum | AdminTokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * AdminToken findFirstOrThrow
   */
  export type AdminTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminTokenInclude<ExtArgs> | null
    /**
     * Filter, which AdminToken to fetch.
     */
    where?: AdminTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTokens to fetch.
     */
    orderBy?: AdminTokenOrderByWithRelationInput | AdminTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminTokens.
     */
    cursor?: AdminTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminTokens.
     */
    distinct?: AdminTokenScalarFieldEnum | AdminTokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * AdminToken findMany
   */
  export type AdminTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminTokenInclude<ExtArgs> | null
    /**
     * Filter, which AdminTokens to fetch.
     */
    where?: AdminTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTokens to fetch.
     */
    orderBy?: AdminTokenOrderByWithRelationInput | AdminTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminTokens.
     */
    cursor?: AdminTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTokens.
     */
    skip?: number
    distinct?: AdminTokenScalarFieldEnum | AdminTokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * AdminToken create
   */
  export type AdminTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminToken.
     */
    data: XOR<AdminTokenCreateInput, AdminTokenUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * AdminToken createMany
   */
  export type AdminTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminTokens.
     */
    data: AdminTokenCreateManyInput | AdminTokenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AdminToken update
   */
  export type AdminTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminToken.
     */
    data: XOR<AdminTokenUpdateInput, AdminTokenUncheckedUpdateInput>
    /**
     * Choose, which AdminToken to update.
     */
    where: AdminTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * AdminToken updateMany
   */
  export type AdminTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminTokens.
     */
    data: XOR<AdminTokenUpdateManyMutationInput, AdminTokenUncheckedUpdateManyInput>
    /**
     * Filter which AdminTokens to update
     */
    where?: AdminTokenWhereInput
  }


  /**
   * AdminToken upsert
   */
  export type AdminTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminToken to update in case it exists.
     */
    where: AdminTokenWhereUniqueInput
    /**
     * In case the AdminToken found by the `where` argument doesn't exist, create a new AdminToken with this data.
     */
    create: XOR<AdminTokenCreateInput, AdminTokenUncheckedCreateInput>
    /**
     * In case the AdminToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminTokenUpdateInput, AdminTokenUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * AdminToken delete
   */
  export type AdminTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminTokenInclude<ExtArgs> | null
    /**
     * Filter which AdminToken to delete.
     */
    where: AdminTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * AdminToken deleteMany
   */
  export type AdminTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminTokens to delete
     */
    where?: AdminTokenWhereInput
  }


  /**
   * AdminToken.Admin
   */
  export type AdminToken$AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }


  /**
   * AdminToken without action
   */
  export type AdminTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminToken
     */
    select?: AdminTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminTokenInclude<ExtArgs> | null
  }



  /**
   * Model BannedUsers
   */

  export type AggregateBannedUsers = {
    _count: BannedUsersCountAggregateOutputType | null
    _avg: BannedUsersAvgAggregateOutputType | null
    _sum: BannedUsersSumAggregateOutputType | null
    _min: BannedUsersMinAggregateOutputType | null
    _max: BannedUsersMaxAggregateOutputType | null
  }

  export type BannedUsersAvgAggregateOutputType = {
    id: number | null
    community: number | null
    reasonId: number | null
  }

  export type BannedUsersSumAggregateOutputType = {
    id: number | null
    community: number | null
    reasonId: number | null
  }

  export type BannedUsersMinAggregateOutputType = {
    id: number | null
    community: number | null
    user: string | null
    reasonId: number | null
  }

  export type BannedUsersMaxAggregateOutputType = {
    id: number | null
    community: number | null
    user: string | null
    reasonId: number | null
  }

  export type BannedUsersCountAggregateOutputType = {
    id: number
    community: number
    user: number
    reasonId: number
    _all: number
  }


  export type BannedUsersAvgAggregateInputType = {
    id?: true
    community?: true
    reasonId?: true
  }

  export type BannedUsersSumAggregateInputType = {
    id?: true
    community?: true
    reasonId?: true
  }

  export type BannedUsersMinAggregateInputType = {
    id?: true
    community?: true
    user?: true
    reasonId?: true
  }

  export type BannedUsersMaxAggregateInputType = {
    id?: true
    community?: true
    user?: true
    reasonId?: true
  }

  export type BannedUsersCountAggregateInputType = {
    id?: true
    community?: true
    user?: true
    reasonId?: true
    _all?: true
  }

  export type BannedUsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannedUsers to aggregate.
     */
    where?: BannedUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannedUsers to fetch.
     */
    orderBy?: BannedUsersOrderByWithRelationInput | BannedUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannedUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BannedUsers
    **/
    _count?: true | BannedUsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BannedUsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BannedUsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannedUsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannedUsersMaxAggregateInputType
  }

  export type GetBannedUsersAggregateType<T extends BannedUsersAggregateArgs> = {
        [P in keyof T & keyof AggregateBannedUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBannedUsers[P]>
      : GetScalarType<T[P], AggregateBannedUsers[P]>
  }




  export type BannedUsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannedUsersWhereInput
    orderBy?: BannedUsersOrderByWithAggregationInput | BannedUsersOrderByWithAggregationInput[]
    by: BannedUsersScalarFieldEnum[] | BannedUsersScalarFieldEnum
    having?: BannedUsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannedUsersCountAggregateInputType | true
    _avg?: BannedUsersAvgAggregateInputType
    _sum?: BannedUsersSumAggregateInputType
    _min?: BannedUsersMinAggregateInputType
    _max?: BannedUsersMaxAggregateInputType
  }

  export type BannedUsersGroupByOutputType = {
    id: number
    community: number
    user: string
    reasonId: number | null
    _count: BannedUsersCountAggregateOutputType | null
    _avg: BannedUsersAvgAggregateOutputType | null
    _sum: BannedUsersSumAggregateOutputType | null
    _min: BannedUsersMinAggregateOutputType | null
    _max: BannedUsersMaxAggregateOutputType | null
  }

  type GetBannedUsersGroupByPayload<T extends BannedUsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannedUsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannedUsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannedUsersGroupByOutputType[P]>
            : GetScalarType<T[P], BannedUsersGroupByOutputType[P]>
        }
      >
    >


  export type BannedUsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    community?: boolean
    user?: boolean
    reasonId?: boolean
    Community?: boolean | BannedUsers$CommunityArgs<ExtArgs>
  }, ExtArgs["result"]["bannedUsers"]>

  export type BannedUsersSelectScalar = {
    id?: boolean
    community?: boolean
    user?: boolean
    reasonId?: boolean
  }

  export type BannedUsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Community?: boolean | BannedUsers$CommunityArgs<ExtArgs>
  }


  export type $BannedUsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BannedUsers"
    objects: {
      Community: Prisma.$CommunityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      community: number
      user: string
      reasonId: number | null
    }, ExtArgs["result"]["bannedUsers"]>
    composites: {}
  }


  type BannedUsersGetPayload<S extends boolean | null | undefined | BannedUsersDefaultArgs> = $Result.GetResult<Prisma.$BannedUsersPayload, S>

  type BannedUsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BannedUsersFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: BannedUsersCountAggregateInputType | true
    }

  export interface BannedUsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BannedUsers'], meta: { name: 'BannedUsers' } }
    /**
     * Find zero or one BannedUsers that matches the filter.
     * @param {BannedUsersFindUniqueArgs} args - Arguments to find a BannedUsers
     * @example
     * // Get one BannedUsers
     * const bannedUsers = await prisma.bannedUsers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BannedUsersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BannedUsersFindUniqueArgs<ExtArgs>>
    ): Prisma__BannedUsersClient<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BannedUsers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BannedUsersFindUniqueOrThrowArgs} args - Arguments to find a BannedUsers
     * @example
     * // Get one BannedUsers
     * const bannedUsers = await prisma.bannedUsers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BannedUsersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BannedUsersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BannedUsersClient<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BannedUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedUsersFindFirstArgs} args - Arguments to find a BannedUsers
     * @example
     * // Get one BannedUsers
     * const bannedUsers = await prisma.bannedUsers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BannedUsersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BannedUsersFindFirstArgs<ExtArgs>>
    ): Prisma__BannedUsersClient<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BannedUsers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedUsersFindFirstOrThrowArgs} args - Arguments to find a BannedUsers
     * @example
     * // Get one BannedUsers
     * const bannedUsers = await prisma.bannedUsers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BannedUsersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BannedUsersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BannedUsersClient<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BannedUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedUsersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BannedUsers
     * const bannedUsers = await prisma.bannedUsers.findMany()
     * 
     * // Get first 10 BannedUsers
     * const bannedUsers = await prisma.bannedUsers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannedUsersWithIdOnly = await prisma.bannedUsers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BannedUsersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BannedUsersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BannedUsers.
     * @param {BannedUsersCreateArgs} args - Arguments to create a BannedUsers.
     * @example
     * // Create one BannedUsers
     * const BannedUsers = await prisma.bannedUsers.create({
     *   data: {
     *     // ... data to create a BannedUsers
     *   }
     * })
     * 
    **/
    create<T extends BannedUsersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BannedUsersCreateArgs<ExtArgs>>
    ): Prisma__BannedUsersClient<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BannedUsers.
     *     @param {BannedUsersCreateManyArgs} args - Arguments to create many BannedUsers.
     *     @example
     *     // Create many BannedUsers
     *     const bannedUsers = await prisma.bannedUsers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BannedUsersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BannedUsersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BannedUsers.
     * @param {BannedUsersDeleteArgs} args - Arguments to delete one BannedUsers.
     * @example
     * // Delete one BannedUsers
     * const BannedUsers = await prisma.bannedUsers.delete({
     *   where: {
     *     // ... filter to delete one BannedUsers
     *   }
     * })
     * 
    **/
    delete<T extends BannedUsersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BannedUsersDeleteArgs<ExtArgs>>
    ): Prisma__BannedUsersClient<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BannedUsers.
     * @param {BannedUsersUpdateArgs} args - Arguments to update one BannedUsers.
     * @example
     * // Update one BannedUsers
     * const bannedUsers = await prisma.bannedUsers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BannedUsersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BannedUsersUpdateArgs<ExtArgs>>
    ): Prisma__BannedUsersClient<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BannedUsers.
     * @param {BannedUsersDeleteManyArgs} args - Arguments to filter BannedUsers to delete.
     * @example
     * // Delete a few BannedUsers
     * const { count } = await prisma.bannedUsers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BannedUsersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BannedUsersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BannedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedUsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BannedUsers
     * const bannedUsers = await prisma.bannedUsers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BannedUsersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BannedUsersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BannedUsers.
     * @param {BannedUsersUpsertArgs} args - Arguments to update or create a BannedUsers.
     * @example
     * // Update or create a BannedUsers
     * const bannedUsers = await prisma.bannedUsers.upsert({
     *   create: {
     *     // ... data to create a BannedUsers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BannedUsers we want to update
     *   }
     * })
    **/
    upsert<T extends BannedUsersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BannedUsersUpsertArgs<ExtArgs>>
    ): Prisma__BannedUsersClient<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BannedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedUsersCountArgs} args - Arguments to filter BannedUsers to count.
     * @example
     * // Count the number of BannedUsers
     * const count = await prisma.bannedUsers.count({
     *   where: {
     *     // ... the filter for the BannedUsers we want to count
     *   }
     * })
    **/
    count<T extends BannedUsersCountArgs>(
      args?: Subset<T, BannedUsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannedUsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BannedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedUsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannedUsersAggregateArgs>(args: Subset<T, BannedUsersAggregateArgs>): Prisma.PrismaPromise<GetBannedUsersAggregateType<T>>

    /**
     * Group by BannedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedUsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannedUsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannedUsersGroupByArgs['orderBy'] }
        : { orderBy?: BannedUsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannedUsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannedUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BannedUsers model
   */
  readonly fields: BannedUsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BannedUsers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannedUsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Community<T extends BannedUsers$CommunityArgs<ExtArgs> = {}>(args?: Subset<T, BannedUsers$CommunityArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BannedUsers model
   */ 
  interface BannedUsersFieldRefs {
    readonly id: FieldRef<"BannedUsers", 'Int'>
    readonly community: FieldRef<"BannedUsers", 'Int'>
    readonly user: FieldRef<"BannedUsers", 'String'>
    readonly reasonId: FieldRef<"BannedUsers", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * BannedUsers findUnique
   */
  export type BannedUsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    /**
     * Filter, which BannedUsers to fetch.
     */
    where: BannedUsersWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * BannedUsers findUniqueOrThrow
   */
  export type BannedUsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    /**
     * Filter, which BannedUsers to fetch.
     */
    where: BannedUsersWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * BannedUsers findFirst
   */
  export type BannedUsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    /**
     * Filter, which BannedUsers to fetch.
     */
    where?: BannedUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannedUsers to fetch.
     */
    orderBy?: BannedUsersOrderByWithRelationInput | BannedUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannedUsers.
     */
    cursor?: BannedUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannedUsers.
     */
    distinct?: BannedUsersScalarFieldEnum | BannedUsersScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * BannedUsers findFirstOrThrow
   */
  export type BannedUsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    /**
     * Filter, which BannedUsers to fetch.
     */
    where?: BannedUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannedUsers to fetch.
     */
    orderBy?: BannedUsersOrderByWithRelationInput | BannedUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannedUsers.
     */
    cursor?: BannedUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannedUsers.
     */
    distinct?: BannedUsersScalarFieldEnum | BannedUsersScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * BannedUsers findMany
   */
  export type BannedUsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    /**
     * Filter, which BannedUsers to fetch.
     */
    where?: BannedUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannedUsers to fetch.
     */
    orderBy?: BannedUsersOrderByWithRelationInput | BannedUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BannedUsers.
     */
    cursor?: BannedUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannedUsers.
     */
    skip?: number
    distinct?: BannedUsersScalarFieldEnum | BannedUsersScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * BannedUsers create
   */
  export type BannedUsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    /**
     * The data needed to create a BannedUsers.
     */
    data: XOR<BannedUsersCreateInput, BannedUsersUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * BannedUsers createMany
   */
  export type BannedUsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BannedUsers.
     */
    data: BannedUsersCreateManyInput | BannedUsersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BannedUsers update
   */
  export type BannedUsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    /**
     * The data needed to update a BannedUsers.
     */
    data: XOR<BannedUsersUpdateInput, BannedUsersUncheckedUpdateInput>
    /**
     * Choose, which BannedUsers to update.
     */
    where: BannedUsersWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * BannedUsers updateMany
   */
  export type BannedUsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BannedUsers.
     */
    data: XOR<BannedUsersUpdateManyMutationInput, BannedUsersUncheckedUpdateManyInput>
    /**
     * Filter which BannedUsers to update
     */
    where?: BannedUsersWhereInput
  }


  /**
   * BannedUsers upsert
   */
  export type BannedUsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    /**
     * The filter to search for the BannedUsers to update in case it exists.
     */
    where: BannedUsersWhereUniqueInput
    /**
     * In case the BannedUsers found by the `where` argument doesn't exist, create a new BannedUsers with this data.
     */
    create: XOR<BannedUsersCreateInput, BannedUsersUncheckedCreateInput>
    /**
     * In case the BannedUsers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannedUsersUpdateInput, BannedUsersUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * BannedUsers delete
   */
  export type BannedUsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    /**
     * Filter which BannedUsers to delete.
     */
    where: BannedUsersWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * BannedUsers deleteMany
   */
  export type BannedUsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannedUsers to delete
     */
    where?: BannedUsersWhereInput
  }


  /**
   * BannedUsers.Community
   */
  export type BannedUsers$CommunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    where?: CommunityWhereInput
  }


  /**
   * BannedUsers without action
   */
  export type BannedUsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
  }



  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    post: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    post: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    body: string | null
    user: string | null
    post: number | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    body: string | null
    user: string | null
    post: number | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    body: number
    user: number
    post: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    post?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    post?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    body?: true
    user?: true
    post?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    body?: true
    user?: true
    post?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    body?: true
    user?: true
    post?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    body: string | null
    user: string
    post: number
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    body?: boolean
    user?: boolean
    post?: boolean
    Post?: boolean | Comment$PostArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    body?: boolean
    user?: boolean
    post?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Post?: boolean | Comment$PostArgs<ExtArgs>
  }


  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      Post: Prisma.$PostPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      body: string | null
      user: string
      post: number
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }


  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentCreateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Post<T extends Comment$PostArgs<ExtArgs> = {}>(args?: Subset<T, Comment$PostArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly body: FieldRef<"Comment", 'String'>
    readonly user: FieldRef<"Comment", 'String'>
    readonly post: FieldRef<"Comment", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }


  /**
   * Comment.Post
   */
  export type Comment$PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
  }


  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
  }



  /**
   * Model Community
   */

  export type AggregateCommunity = {
    _count: CommunityCountAggregateOutputType | null
    _avg: CommunityAvgAggregateOutputType | null
    _sum: CommunitySumAggregateOutputType | null
    _min: CommunityMinAggregateOutputType | null
    _max: CommunityMaxAggregateOutputType | null
  }

  export type CommunityAvgAggregateOutputType = {
    id: number | null
  }

  export type CommunitySumAggregateOutputType = {
    id: number | null
  }

  export type CommunityMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type CommunityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type CommunityCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type CommunityAvgAggregateInputType = {
    id?: true
  }

  export type CommunitySumAggregateInputType = {
    id?: true
  }

  export type CommunityMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type CommunityMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type CommunityCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type CommunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Community to aggregate.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Communities
    **/
    _count?: true | CommunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityMaxAggregateInputType
  }

  export type GetCommunityAggregateType<T extends CommunityAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunity[P]>
      : GetScalarType<T[P], AggregateCommunity[P]>
  }




  export type CommunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityWhereInput
    orderBy?: CommunityOrderByWithAggregationInput | CommunityOrderByWithAggregationInput[]
    by: CommunityScalarFieldEnum[] | CommunityScalarFieldEnum
    having?: CommunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityCountAggregateInputType | true
    _avg?: CommunityAvgAggregateInputType
    _sum?: CommunitySumAggregateInputType
    _min?: CommunityMinAggregateInputType
    _max?: CommunityMaxAggregateInputType
  }

  export type CommunityGroupByOutputType = {
    id: number
    name: string | null
    description: string | null
    _count: CommunityCountAggregateOutputType | null
    _avg: CommunityAvgAggregateOutputType | null
    _sum: CommunitySumAggregateOutputType | null
    _min: CommunityMinAggregateOutputType | null
    _max: CommunityMaxAggregateOutputType | null
  }

  type GetCommunityGroupByPayload<T extends CommunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityGroupByOutputType[P]>
        }
      >
    >


  export type CommunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    CommunityUser?: boolean | Community$CommunityUserArgs<ExtArgs>
    CommunityRequest?: boolean | Community$CommunityRequestArgs<ExtArgs>
    BannedUsers?: boolean | Community$BannedUsersArgs<ExtArgs>
    _count?: boolean | CommunityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["community"]>

  export type CommunitySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type CommunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CommunityUser?: boolean | Community$CommunityUserArgs<ExtArgs>
    CommunityRequest?: boolean | Community$CommunityRequestArgs<ExtArgs>
    BannedUsers?: boolean | Community$BannedUsersArgs<ExtArgs>
    _count?: boolean | CommunityCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CommunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Community"
    objects: {
      CommunityUser: Prisma.$CommunityUserPayload<ExtArgs>[]
      CommunityRequest: Prisma.$CommunityRequestPayload<ExtArgs>[]
      BannedUsers: Prisma.$BannedUsersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      description: string | null
    }, ExtArgs["result"]["community"]>
    composites: {}
  }


  type CommunityGetPayload<S extends boolean | null | undefined | CommunityDefaultArgs> = $Result.GetResult<Prisma.$CommunityPayload, S>

  type CommunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommunityFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: CommunityCountAggregateInputType | true
    }

  export interface CommunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Community'], meta: { name: 'Community' } }
    /**
     * Find zero or one Community that matches the filter.
     * @param {CommunityFindUniqueArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityFindUniqueArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Community that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommunityFindUniqueOrThrowArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommunityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Community that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindFirstArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityFindFirstArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Community that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindFirstOrThrowArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommunityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Communities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Communities
     * const communities = await prisma.community.findMany()
     * 
     * // Get first 10 Communities
     * const communities = await prisma.community.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityWithIdOnly = await prisma.community.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Community.
     * @param {CommunityCreateArgs} args - Arguments to create a Community.
     * @example
     * // Create one Community
     * const Community = await prisma.community.create({
     *   data: {
     *     // ... data to create a Community
     *   }
     * })
     * 
    **/
    create<T extends CommunityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityCreateArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Communities.
     *     @param {CommunityCreateManyArgs} args - Arguments to create many Communities.
     *     @example
     *     // Create many Communities
     *     const community = await prisma.community.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Community.
     * @param {CommunityDeleteArgs} args - Arguments to delete one Community.
     * @example
     * // Delete one Community
     * const Community = await prisma.community.delete({
     *   where: {
     *     // ... filter to delete one Community
     *   }
     * })
     * 
    **/
    delete<T extends CommunityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityDeleteArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Community.
     * @param {CommunityUpdateArgs} args - Arguments to update one Community.
     * @example
     * // Update one Community
     * const community = await prisma.community.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityUpdateArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Communities.
     * @param {CommunityDeleteManyArgs} args - Arguments to filter Communities to delete.
     * @example
     * // Delete a few Communities
     * const { count } = await prisma.community.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Communities
     * const community = await prisma.community.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Community.
     * @param {CommunityUpsertArgs} args - Arguments to update or create a Community.
     * @example
     * // Update or create a Community
     * const community = await prisma.community.upsert({
     *   create: {
     *     // ... data to create a Community
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Community we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityUpsertArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Communities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCountArgs} args - Arguments to filter Communities to count.
     * @example
     * // Count the number of Communities
     * const count = await prisma.community.count({
     *   where: {
     *     // ... the filter for the Communities we want to count
     *   }
     * })
    **/
    count<T extends CommunityCountArgs>(
      args?: Subset<T, CommunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Community.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityAggregateArgs>(args: Subset<T, CommunityAggregateArgs>): Prisma.PrismaPromise<GetCommunityAggregateType<T>>

    /**
     * Group by Community.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityGroupByArgs['orderBy'] }
        : { orderBy?: CommunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Community model
   */
  readonly fields: CommunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Community.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    CommunityUser<T extends Community$CommunityUserArgs<ExtArgs> = {}>(args?: Subset<T, Community$CommunityUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    CommunityRequest<T extends Community$CommunityRequestArgs<ExtArgs> = {}>(args?: Subset<T, Community$CommunityRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'findMany'> | Null>;

    BannedUsers<T extends Community$BannedUsersArgs<ExtArgs> = {}>(args?: Subset<T, Community$BannedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannedUsersPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Community model
   */ 
  interface CommunityFieldRefs {
    readonly id: FieldRef<"Community", 'Int'>
    readonly name: FieldRef<"Community", 'String'>
    readonly description: FieldRef<"Community", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Community findUnique
   */
  export type CommunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where: CommunityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Community findUniqueOrThrow
   */
  export type CommunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where: CommunityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Community findFirst
   */
  export type CommunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communities.
     */
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Community findFirstOrThrow
   */
  export type CommunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communities.
     */
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Community findMany
   */
  export type CommunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Communities to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Community create
   */
  export type CommunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The data needed to create a Community.
     */
    data?: XOR<CommunityCreateInput, CommunityUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Community createMany
   */
  export type CommunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Communities.
     */
    data: CommunityCreateManyInput | CommunityCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Community update
   */
  export type CommunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The data needed to update a Community.
     */
    data: XOR<CommunityUpdateInput, CommunityUncheckedUpdateInput>
    /**
     * Choose, which Community to update.
     */
    where: CommunityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Community updateMany
   */
  export type CommunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Communities.
     */
    data: XOR<CommunityUpdateManyMutationInput, CommunityUncheckedUpdateManyInput>
    /**
     * Filter which Communities to update
     */
    where?: CommunityWhereInput
  }


  /**
   * Community upsert
   */
  export type CommunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The filter to search for the Community to update in case it exists.
     */
    where: CommunityWhereUniqueInput
    /**
     * In case the Community found by the `where` argument doesn't exist, create a new Community with this data.
     */
    create: XOR<CommunityCreateInput, CommunityUncheckedCreateInput>
    /**
     * In case the Community was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityUpdateInput, CommunityUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Community delete
   */
  export type CommunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter which Community to delete.
     */
    where: CommunityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Community deleteMany
   */
  export type CommunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Communities to delete
     */
    where?: CommunityWhereInput
  }


  /**
   * Community.CommunityUser
   */
  export type Community$CommunityUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityUser
     */
    select?: CommunityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityUserInclude<ExtArgs> | null
    where?: CommunityUserWhereInput
    orderBy?: CommunityUserOrderByWithRelationInput | CommunityUserOrderByWithRelationInput[]
    cursor?: CommunityUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityUserScalarFieldEnum | CommunityUserScalarFieldEnum[]
  }


  /**
   * Community.CommunityRequest
   */
  export type Community$CommunityRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    where?: CommunityRequestWhereInput
    orderBy?: CommunityRequestOrderByWithRelationInput | CommunityRequestOrderByWithRelationInput[]
    cursor?: CommunityRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityRequestScalarFieldEnum | CommunityRequestScalarFieldEnum[]
  }


  /**
   * Community.BannedUsers
   */
  export type Community$BannedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannedUsers
     */
    select?: BannedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannedUsersInclude<ExtArgs> | null
    where?: BannedUsersWhereInput
    orderBy?: BannedUsersOrderByWithRelationInput | BannedUsersOrderByWithRelationInput[]
    cursor?: BannedUsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannedUsersScalarFieldEnum | BannedUsersScalarFieldEnum[]
  }


  /**
   * Community without action
   */
  export type CommunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
  }



  /**
   * Model CommunityRequest
   */

  export type AggregateCommunityRequest = {
    _count: CommunityRequestCountAggregateOutputType | null
    _avg: CommunityRequestAvgAggregateOutputType | null
    _sum: CommunityRequestSumAggregateOutputType | null
    _min: CommunityRequestMinAggregateOutputType | null
    _max: CommunityRequestMaxAggregateOutputType | null
  }

  export type CommunityRequestAvgAggregateOutputType = {
    id: number | null
    community: number | null
  }

  export type CommunityRequestSumAggregateOutputType = {
    id: number | null
    community: number | null
  }

  export type CommunityRequestMinAggregateOutputType = {
    id: number | null
    user: string | null
    community: number | null
    requestedAt: Date | null
    message: string | null
  }

  export type CommunityRequestMaxAggregateOutputType = {
    id: number | null
    user: string | null
    community: number | null
    requestedAt: Date | null
    message: string | null
  }

  export type CommunityRequestCountAggregateOutputType = {
    id: number
    user: number
    community: number
    requestedAt: number
    message: number
    _all: number
  }


  export type CommunityRequestAvgAggregateInputType = {
    id?: true
    community?: true
  }

  export type CommunityRequestSumAggregateInputType = {
    id?: true
    community?: true
  }

  export type CommunityRequestMinAggregateInputType = {
    id?: true
    user?: true
    community?: true
    requestedAt?: true
    message?: true
  }

  export type CommunityRequestMaxAggregateInputType = {
    id?: true
    user?: true
    community?: true
    requestedAt?: true
    message?: true
  }

  export type CommunityRequestCountAggregateInputType = {
    id?: true
    user?: true
    community?: true
    requestedAt?: true
    message?: true
    _all?: true
  }

  export type CommunityRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityRequest to aggregate.
     */
    where?: CommunityRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityRequests to fetch.
     */
    orderBy?: CommunityRequestOrderByWithRelationInput | CommunityRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityRequests
    **/
    _count?: true | CommunityRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityRequestMaxAggregateInputType
  }

  export type GetCommunityRequestAggregateType<T extends CommunityRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityRequest[P]>
      : GetScalarType<T[P], AggregateCommunityRequest[P]>
  }




  export type CommunityRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityRequestWhereInput
    orderBy?: CommunityRequestOrderByWithAggregationInput | CommunityRequestOrderByWithAggregationInput[]
    by: CommunityRequestScalarFieldEnum[] | CommunityRequestScalarFieldEnum
    having?: CommunityRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityRequestCountAggregateInputType | true
    _avg?: CommunityRequestAvgAggregateInputType
    _sum?: CommunityRequestSumAggregateInputType
    _min?: CommunityRequestMinAggregateInputType
    _max?: CommunityRequestMaxAggregateInputType
  }

  export type CommunityRequestGroupByOutputType = {
    id: number
    user: string | null
    community: number | null
    requestedAt: Date | null
    message: string | null
    _count: CommunityRequestCountAggregateOutputType | null
    _avg: CommunityRequestAvgAggregateOutputType | null
    _sum: CommunityRequestSumAggregateOutputType | null
    _min: CommunityRequestMinAggregateOutputType | null
    _max: CommunityRequestMaxAggregateOutputType | null
  }

  type GetCommunityRequestGroupByPayload<T extends CommunityRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityRequestGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityRequestGroupByOutputType[P]>
        }
      >
    >


  export type CommunityRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user?: boolean
    community?: boolean
    requestedAt?: boolean
    message?: boolean
    Community?: boolean | CommunityRequest$CommunityArgs<ExtArgs>
  }, ExtArgs["result"]["communityRequest"]>

  export type CommunityRequestSelectScalar = {
    id?: boolean
    user?: boolean
    community?: boolean
    requestedAt?: boolean
    message?: boolean
  }

  export type CommunityRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Community?: boolean | CommunityRequest$CommunityArgs<ExtArgs>
  }


  export type $CommunityRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityRequest"
    objects: {
      Community: Prisma.$CommunityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user: string | null
      community: number | null
      requestedAt: Date | null
      message: string | null
    }, ExtArgs["result"]["communityRequest"]>
    composites: {}
  }


  type CommunityRequestGetPayload<S extends boolean | null | undefined | CommunityRequestDefaultArgs> = $Result.GetResult<Prisma.$CommunityRequestPayload, S>

  type CommunityRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommunityRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: CommunityRequestCountAggregateInputType | true
    }

  export interface CommunityRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityRequest'], meta: { name: 'CommunityRequest' } }
    /**
     * Find zero or one CommunityRequest that matches the filter.
     * @param {CommunityRequestFindUniqueArgs} args - Arguments to find a CommunityRequest
     * @example
     * // Get one CommunityRequest
     * const communityRequest = await prisma.communityRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityRequestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityRequestFindUniqueArgs<ExtArgs>>
    ): Prisma__CommunityRequestClient<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CommunityRequest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommunityRequestFindUniqueOrThrowArgs} args - Arguments to find a CommunityRequest
     * @example
     * // Get one CommunityRequest
     * const communityRequest = await prisma.communityRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommunityRequestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityRequestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityRequestClient<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CommunityRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityRequestFindFirstArgs} args - Arguments to find a CommunityRequest
     * @example
     * // Get one CommunityRequest
     * const communityRequest = await prisma.communityRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityRequestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityRequestFindFirstArgs<ExtArgs>>
    ): Prisma__CommunityRequestClient<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CommunityRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityRequestFindFirstOrThrowArgs} args - Arguments to find a CommunityRequest
     * @example
     * // Get one CommunityRequest
     * const communityRequest = await prisma.communityRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommunityRequestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityRequestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityRequestClient<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CommunityRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityRequests
     * const communityRequests = await prisma.communityRequest.findMany()
     * 
     * // Get first 10 CommunityRequests
     * const communityRequests = await prisma.communityRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityRequestWithIdOnly = await prisma.communityRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunityRequestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityRequestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CommunityRequest.
     * @param {CommunityRequestCreateArgs} args - Arguments to create a CommunityRequest.
     * @example
     * // Create one CommunityRequest
     * const CommunityRequest = await prisma.communityRequest.create({
     *   data: {
     *     // ... data to create a CommunityRequest
     *   }
     * })
     * 
    **/
    create<T extends CommunityRequestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityRequestCreateArgs<ExtArgs>>
    ): Prisma__CommunityRequestClient<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CommunityRequests.
     *     @param {CommunityRequestCreateManyArgs} args - Arguments to create many CommunityRequests.
     *     @example
     *     // Create many CommunityRequests
     *     const communityRequest = await prisma.communityRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunityRequestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityRequestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommunityRequest.
     * @param {CommunityRequestDeleteArgs} args - Arguments to delete one CommunityRequest.
     * @example
     * // Delete one CommunityRequest
     * const CommunityRequest = await prisma.communityRequest.delete({
     *   where: {
     *     // ... filter to delete one CommunityRequest
     *   }
     * })
     * 
    **/
    delete<T extends CommunityRequestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityRequestDeleteArgs<ExtArgs>>
    ): Prisma__CommunityRequestClient<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CommunityRequest.
     * @param {CommunityRequestUpdateArgs} args - Arguments to update one CommunityRequest.
     * @example
     * // Update one CommunityRequest
     * const communityRequest = await prisma.communityRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityRequestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityRequestUpdateArgs<ExtArgs>>
    ): Prisma__CommunityRequestClient<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CommunityRequests.
     * @param {CommunityRequestDeleteManyArgs} args - Arguments to filter CommunityRequests to delete.
     * @example
     * // Delete a few CommunityRequests
     * const { count } = await prisma.communityRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityRequestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityRequestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityRequests
     * const communityRequest = await prisma.communityRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityRequestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityRequestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityRequest.
     * @param {CommunityRequestUpsertArgs} args - Arguments to update or create a CommunityRequest.
     * @example
     * // Update or create a CommunityRequest
     * const communityRequest = await prisma.communityRequest.upsert({
     *   create: {
     *     // ... data to create a CommunityRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityRequest we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityRequestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityRequestUpsertArgs<ExtArgs>>
    ): Prisma__CommunityRequestClient<$Result.GetResult<Prisma.$CommunityRequestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CommunityRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityRequestCountArgs} args - Arguments to filter CommunityRequests to count.
     * @example
     * // Count the number of CommunityRequests
     * const count = await prisma.communityRequest.count({
     *   where: {
     *     // ... the filter for the CommunityRequests we want to count
     *   }
     * })
    **/
    count<T extends CommunityRequestCountArgs>(
      args?: Subset<T, CommunityRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityRequestAggregateArgs>(args: Subset<T, CommunityRequestAggregateArgs>): Prisma.PrismaPromise<GetCommunityRequestAggregateType<T>>

    /**
     * Group by CommunityRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityRequestGroupByArgs['orderBy'] }
        : { orderBy?: CommunityRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityRequest model
   */
  readonly fields: CommunityRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Community<T extends CommunityRequest$CommunityArgs<ExtArgs> = {}>(args?: Subset<T, CommunityRequest$CommunityArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CommunityRequest model
   */ 
  interface CommunityRequestFieldRefs {
    readonly id: FieldRef<"CommunityRequest", 'Int'>
    readonly user: FieldRef<"CommunityRequest", 'String'>
    readonly community: FieldRef<"CommunityRequest", 'Int'>
    readonly requestedAt: FieldRef<"CommunityRequest", 'DateTime'>
    readonly message: FieldRef<"CommunityRequest", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CommunityRequest findUnique
   */
  export type CommunityRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    /**
     * Filter, which CommunityRequest to fetch.
     */
    where: CommunityRequestWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * CommunityRequest findUniqueOrThrow
   */
  export type CommunityRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    /**
     * Filter, which CommunityRequest to fetch.
     */
    where: CommunityRequestWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * CommunityRequest findFirst
   */
  export type CommunityRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    /**
     * Filter, which CommunityRequest to fetch.
     */
    where?: CommunityRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityRequests to fetch.
     */
    orderBy?: CommunityRequestOrderByWithRelationInput | CommunityRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityRequests.
     */
    cursor?: CommunityRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityRequests.
     */
    distinct?: CommunityRequestScalarFieldEnum | CommunityRequestScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * CommunityRequest findFirstOrThrow
   */
  export type CommunityRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    /**
     * Filter, which CommunityRequest to fetch.
     */
    where?: CommunityRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityRequests to fetch.
     */
    orderBy?: CommunityRequestOrderByWithRelationInput | CommunityRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityRequests.
     */
    cursor?: CommunityRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityRequests.
     */
    distinct?: CommunityRequestScalarFieldEnum | CommunityRequestScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * CommunityRequest findMany
   */
  export type CommunityRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    /**
     * Filter, which CommunityRequests to fetch.
     */
    where?: CommunityRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityRequests to fetch.
     */
    orderBy?: CommunityRequestOrderByWithRelationInput | CommunityRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityRequests.
     */
    cursor?: CommunityRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityRequests.
     */
    skip?: number
    distinct?: CommunityRequestScalarFieldEnum | CommunityRequestScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * CommunityRequest create
   */
  export type CommunityRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityRequest.
     */
    data?: XOR<CommunityRequestCreateInput, CommunityRequestUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * CommunityRequest createMany
   */
  export type CommunityRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityRequests.
     */
    data: CommunityRequestCreateManyInput | CommunityRequestCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CommunityRequest update
   */
  export type CommunityRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityRequest.
     */
    data: XOR<CommunityRequestUpdateInput, CommunityRequestUncheckedUpdateInput>
    /**
     * Choose, which CommunityRequest to update.
     */
    where: CommunityRequestWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * CommunityRequest updateMany
   */
  export type CommunityRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityRequests.
     */
    data: XOR<CommunityRequestUpdateManyMutationInput, CommunityRequestUncheckedUpdateManyInput>
    /**
     * Filter which CommunityRequests to update
     */
    where?: CommunityRequestWhereInput
  }


  /**
   * CommunityRequest upsert
   */
  export type CommunityRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityRequest to update in case it exists.
     */
    where: CommunityRequestWhereUniqueInput
    /**
     * In case the CommunityRequest found by the `where` argument doesn't exist, create a new CommunityRequest with this data.
     */
    create: XOR<CommunityRequestCreateInput, CommunityRequestUncheckedCreateInput>
    /**
     * In case the CommunityRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityRequestUpdateInput, CommunityRequestUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * CommunityRequest delete
   */
  export type CommunityRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
    /**
     * Filter which CommunityRequest to delete.
     */
    where: CommunityRequestWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * CommunityRequest deleteMany
   */
  export type CommunityRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityRequests to delete
     */
    where?: CommunityRequestWhereInput
  }


  /**
   * CommunityRequest.Community
   */
  export type CommunityRequest$CommunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityInclude<ExtArgs> | null
    where?: CommunityWhereInput
  }


  /**
   * CommunityRequest without action
   */
  export type CommunityRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityRequest
     */
    select?: CommunityRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityRequestInclude<ExtArgs> | null
  }



  /**
   * Model Context
   */

  export type AggregateContext = {
    _count: ContextCountAggregateOutputType | null
    _avg: ContextAvgAggregateOutputType | null
    _sum: ContextSumAggregateOutputType | null
    _min: ContextMinAggregateOutputType | null
    _max: ContextMaxAggregateOutputType | null
  }

  export type ContextAvgAggregateOutputType = {
    id: number | null
  }

  export type ContextSumAggregateOutputType = {
    id: number | null
  }

  export type ContextMinAggregateOutputType = {
    id: number | null
    user: string | null
    ip: string | null
    country: string | null
    city: string | null
    os: string | null
    device: string | null
    deviceType: string | null
    isTrusted: boolean | null
  }

  export type ContextMaxAggregateOutputType = {
    id: number | null
    user: string | null
    ip: string | null
    country: string | null
    city: string | null
    os: string | null
    device: string | null
    deviceType: string | null
    isTrusted: boolean | null
  }

  export type ContextCountAggregateOutputType = {
    id: number
    user: number
    ip: number
    country: number
    city: number
    os: number
    device: number
    deviceType: number
    isTrusted: number
    _all: number
  }


  export type ContextAvgAggregateInputType = {
    id?: true
  }

  export type ContextSumAggregateInputType = {
    id?: true
  }

  export type ContextMinAggregateInputType = {
    id?: true
    user?: true
    ip?: true
    country?: true
    city?: true
    os?: true
    device?: true
    deviceType?: true
    isTrusted?: true
  }

  export type ContextMaxAggregateInputType = {
    id?: true
    user?: true
    ip?: true
    country?: true
    city?: true
    os?: true
    device?: true
    deviceType?: true
    isTrusted?: true
  }

  export type ContextCountAggregateInputType = {
    id?: true
    user?: true
    ip?: true
    country?: true
    city?: true
    os?: true
    device?: true
    deviceType?: true
    isTrusted?: true
    _all?: true
  }

  export type ContextAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Context to aggregate.
     */
    where?: ContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contexts to fetch.
     */
    orderBy?: ContextOrderByWithRelationInput | ContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contexts
    **/
    _count?: true | ContextCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContextAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContextSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContextMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContextMaxAggregateInputType
  }

  export type GetContextAggregateType<T extends ContextAggregateArgs> = {
        [P in keyof T & keyof AggregateContext]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContext[P]>
      : GetScalarType<T[P], AggregateContext[P]>
  }




  export type ContextGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContextWhereInput
    orderBy?: ContextOrderByWithAggregationInput | ContextOrderByWithAggregationInput[]
    by: ContextScalarFieldEnum[] | ContextScalarFieldEnum
    having?: ContextScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContextCountAggregateInputType | true
    _avg?: ContextAvgAggregateInputType
    _sum?: ContextSumAggregateInputType
    _min?: ContextMinAggregateInputType
    _max?: ContextMaxAggregateInputType
  }

  export type ContextGroupByOutputType = {
    id: number
    user: string | null
    ip: string | null
    country: string | null
    city: string | null
    os: string | null
    device: string | null
    deviceType: string | null
    isTrusted: boolean | null
    _count: ContextCountAggregateOutputType | null
    _avg: ContextAvgAggregateOutputType | null
    _sum: ContextSumAggregateOutputType | null
    _min: ContextMinAggregateOutputType | null
    _max: ContextMaxAggregateOutputType | null
  }

  type GetContextGroupByPayload<T extends ContextGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContextGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContextGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContextGroupByOutputType[P]>
            : GetScalarType<T[P], ContextGroupByOutputType[P]>
        }
      >
    >


  export type ContextSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user?: boolean
    ip?: boolean
    country?: boolean
    city?: boolean
    os?: boolean
    device?: boolean
    deviceType?: boolean
    isTrusted?: boolean
  }, ExtArgs["result"]["context"]>

  export type ContextSelectScalar = {
    id?: boolean
    user?: boolean
    ip?: boolean
    country?: boolean
    city?: boolean
    os?: boolean
    device?: boolean
    deviceType?: boolean
    isTrusted?: boolean
  }


  export type $ContextPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Context"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user: string | null
      ip: string | null
      country: string | null
      city: string | null
      os: string | null
      device: string | null
      deviceType: string | null
      isTrusted: boolean | null
    }, ExtArgs["result"]["context"]>
    composites: {}
  }


  type ContextGetPayload<S extends boolean | null | undefined | ContextDefaultArgs> = $Result.GetResult<Prisma.$ContextPayload, S>

  type ContextCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContextFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ContextCountAggregateInputType | true
    }

  export interface ContextDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Context'], meta: { name: 'Context' } }
    /**
     * Find zero or one Context that matches the filter.
     * @param {ContextFindUniqueArgs} args - Arguments to find a Context
     * @example
     * // Get one Context
     * const context = await prisma.context.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContextFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContextFindUniqueArgs<ExtArgs>>
    ): Prisma__ContextClient<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Context that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContextFindUniqueOrThrowArgs} args - Arguments to find a Context
     * @example
     * // Get one Context
     * const context = await prisma.context.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContextFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContextClient<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Context that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextFindFirstArgs} args - Arguments to find a Context
     * @example
     * // Get one Context
     * const context = await prisma.context.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContextFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextFindFirstArgs<ExtArgs>>
    ): Prisma__ContextClient<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Context that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextFindFirstOrThrowArgs} args - Arguments to find a Context
     * @example
     * // Get one Context
     * const context = await prisma.context.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContextFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContextClient<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contexts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contexts
     * const contexts = await prisma.context.findMany()
     * 
     * // Get first 10 Contexts
     * const contexts = await prisma.context.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contextWithIdOnly = await prisma.context.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContextFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Context.
     * @param {ContextCreateArgs} args - Arguments to create a Context.
     * @example
     * // Create one Context
     * const Context = await prisma.context.create({
     *   data: {
     *     // ... data to create a Context
     *   }
     * })
     * 
    **/
    create<T extends ContextCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextCreateArgs<ExtArgs>>
    ): Prisma__ContextClient<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contexts.
     *     @param {ContextCreateManyArgs} args - Arguments to create many Contexts.
     *     @example
     *     // Create many Contexts
     *     const context = await prisma.context.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContextCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Context.
     * @param {ContextDeleteArgs} args - Arguments to delete one Context.
     * @example
     * // Delete one Context
     * const Context = await prisma.context.delete({
     *   where: {
     *     // ... filter to delete one Context
     *   }
     * })
     * 
    **/
    delete<T extends ContextDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContextDeleteArgs<ExtArgs>>
    ): Prisma__ContextClient<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Context.
     * @param {ContextUpdateArgs} args - Arguments to update one Context.
     * @example
     * // Update one Context
     * const context = await prisma.context.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContextUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextUpdateArgs<ExtArgs>>
    ): Prisma__ContextClient<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contexts.
     * @param {ContextDeleteManyArgs} args - Arguments to filter Contexts to delete.
     * @example
     * // Delete a few Contexts
     * const { count } = await prisma.context.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContextDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contexts
     * const context = await prisma.context.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContextUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContextUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Context.
     * @param {ContextUpsertArgs} args - Arguments to update or create a Context.
     * @example
     * // Update or create a Context
     * const context = await prisma.context.upsert({
     *   create: {
     *     // ... data to create a Context
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Context we want to update
     *   }
     * })
    **/
    upsert<T extends ContextUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContextUpsertArgs<ExtArgs>>
    ): Prisma__ContextClient<$Result.GetResult<Prisma.$ContextPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextCountArgs} args - Arguments to filter Contexts to count.
     * @example
     * // Count the number of Contexts
     * const count = await prisma.context.count({
     *   where: {
     *     // ... the filter for the Contexts we want to count
     *   }
     * })
    **/
    count<T extends ContextCountArgs>(
      args?: Subset<T, ContextCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContextCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Context.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContextAggregateArgs>(args: Subset<T, ContextAggregateArgs>): Prisma.PrismaPromise<GetContextAggregateType<T>>

    /**
     * Group by Context.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContextGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContextGroupByArgs['orderBy'] }
        : { orderBy?: ContextGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContextGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContextGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Context model
   */
  readonly fields: ContextFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Context.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContextClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Context model
   */ 
  interface ContextFieldRefs {
    readonly id: FieldRef<"Context", 'Int'>
    readonly user: FieldRef<"Context", 'String'>
    readonly ip: FieldRef<"Context", 'String'>
    readonly country: FieldRef<"Context", 'String'>
    readonly city: FieldRef<"Context", 'String'>
    readonly os: FieldRef<"Context", 'String'>
    readonly device: FieldRef<"Context", 'String'>
    readonly deviceType: FieldRef<"Context", 'String'>
    readonly isTrusted: FieldRef<"Context", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Context findUnique
   */
  export type ContextFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * Filter, which Context to fetch.
     */
    where: ContextWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Context findUniqueOrThrow
   */
  export type ContextFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * Filter, which Context to fetch.
     */
    where: ContextWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Context findFirst
   */
  export type ContextFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * Filter, which Context to fetch.
     */
    where?: ContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contexts to fetch.
     */
    orderBy?: ContextOrderByWithRelationInput | ContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contexts.
     */
    cursor?: ContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contexts.
     */
    distinct?: ContextScalarFieldEnum | ContextScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Context findFirstOrThrow
   */
  export type ContextFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * Filter, which Context to fetch.
     */
    where?: ContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contexts to fetch.
     */
    orderBy?: ContextOrderByWithRelationInput | ContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contexts.
     */
    cursor?: ContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contexts.
     */
    distinct?: ContextScalarFieldEnum | ContextScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Context findMany
   */
  export type ContextFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * Filter, which Contexts to fetch.
     */
    where?: ContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contexts to fetch.
     */
    orderBy?: ContextOrderByWithRelationInput | ContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contexts.
     */
    cursor?: ContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contexts.
     */
    skip?: number
    distinct?: ContextScalarFieldEnum | ContextScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Context create
   */
  export type ContextCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * The data needed to create a Context.
     */
    data?: XOR<ContextCreateInput, ContextUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Context createMany
   */
  export type ContextCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contexts.
     */
    data: ContextCreateManyInput | ContextCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Context update
   */
  export type ContextUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * The data needed to update a Context.
     */
    data: XOR<ContextUpdateInput, ContextUncheckedUpdateInput>
    /**
     * Choose, which Context to update.
     */
    where: ContextWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Context updateMany
   */
  export type ContextUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contexts.
     */
    data: XOR<ContextUpdateManyMutationInput, ContextUncheckedUpdateManyInput>
    /**
     * Filter which Contexts to update
     */
    where?: ContextWhereInput
  }


  /**
   * Context upsert
   */
  export type ContextUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * The filter to search for the Context to update in case it exists.
     */
    where: ContextWhereUniqueInput
    /**
     * In case the Context found by the `where` argument doesn't exist, create a new Context with this data.
     */
    create: XOR<ContextCreateInput, ContextUncheckedCreateInput>
    /**
     * In case the Context was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContextUpdateInput, ContextUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Context delete
   */
  export type ContextDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
    /**
     * Filter which Context to delete.
     */
    where: ContextWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Context deleteMany
   */
  export type ContextDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contexts to delete
     */
    where?: ContextWhereInput
  }


  /**
   * Context without action
   */
  export type ContextDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Context
     */
    select?: ContextSelect<ExtArgs> | null
  }



  /**
   * Model Like
   */

  export type AggregateLike = {
    _count: LikeCountAggregateOutputType | null
    _avg: LikeAvgAggregateOutputType | null
    _sum: LikeSumAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  export type LikeAvgAggregateOutputType = {
    id: number | null
    post: number | null
  }

  export type LikeSumAggregateOutputType = {
    id: number | null
    post: number | null
  }

  export type LikeMinAggregateOutputType = {
    id: number | null
    user: string | null
    post: number | null
  }

  export type LikeMaxAggregateOutputType = {
    id: number | null
    user: string | null
    post: number | null
  }

  export type LikeCountAggregateOutputType = {
    id: number
    user: number
    post: number
    _all: number
  }


  export type LikeAvgAggregateInputType = {
    id?: true
    post?: true
  }

  export type LikeSumAggregateInputType = {
    id?: true
    post?: true
  }

  export type LikeMinAggregateInputType = {
    id?: true
    user?: true
    post?: true
  }

  export type LikeMaxAggregateInputType = {
    id?: true
    user?: true
    post?: true
  }

  export type LikeCountAggregateInputType = {
    id?: true
    user?: true
    post?: true
    _all?: true
  }

  export type LikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Like to aggregate.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Likes
    **/
    _count?: true | LikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeMaxAggregateInputType
  }

  export type GetLikeAggregateType<T extends LikeAggregateArgs> = {
        [P in keyof T & keyof AggregateLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLike[P]>
      : GetScalarType<T[P], AggregateLike[P]>
  }




  export type LikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithAggregationInput | LikeOrderByWithAggregationInput[]
    by: LikeScalarFieldEnum[] | LikeScalarFieldEnum
    having?: LikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeCountAggregateInputType | true
    _avg?: LikeAvgAggregateInputType
    _sum?: LikeSumAggregateInputType
    _min?: LikeMinAggregateInputType
    _max?: LikeMaxAggregateInputType
  }

  export type LikeGroupByOutputType = {
    id: number
    user: string
    post: number
    _count: LikeCountAggregateOutputType | null
    _avg: LikeAvgAggregateOutputType | null
    _sum: LikeSumAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  type GetLikeGroupByPayload<T extends LikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeGroupByOutputType[P]>
            : GetScalarType<T[P], LikeGroupByOutputType[P]>
        }
      >
    >


  export type LikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user?: boolean
    post?: boolean
    Post?: boolean | Like$PostArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectScalar = {
    id?: boolean
    user?: boolean
    post?: boolean
  }

  export type LikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Post?: boolean | Like$PostArgs<ExtArgs>
  }


  export type $LikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Like"
    objects: {
      Post: Prisma.$PostPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user: string
      post: number
    }, ExtArgs["result"]["like"]>
    composites: {}
  }


  type LikeGetPayload<S extends boolean | null | undefined | LikeDefaultArgs> = $Result.GetResult<Prisma.$LikePayload, S>

  type LikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LikeFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: LikeCountAggregateInputType | true
    }

  export interface LikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Like'], meta: { name: 'Like' } }
    /**
     * Find zero or one Like that matches the filter.
     * @param {LikeFindUniqueArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LikeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LikeFindUniqueArgs<ExtArgs>>
    ): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Like that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LikeFindUniqueOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LikeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LikeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LikeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LikeFindFirstArgs<ExtArgs>>
    ): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Like that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LikeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LikeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.like.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.like.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeWithIdOnly = await prisma.like.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LikeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LikeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Like.
     * @param {LikeCreateArgs} args - Arguments to create a Like.
     * @example
     * // Create one Like
     * const Like = await prisma.like.create({
     *   data: {
     *     // ... data to create a Like
     *   }
     * })
     * 
    **/
    create<T extends LikeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LikeCreateArgs<ExtArgs>>
    ): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Likes.
     *     @param {LikeCreateManyArgs} args - Arguments to create many Likes.
     *     @example
     *     // Create many Likes
     *     const like = await prisma.like.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LikeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LikeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Like.
     * @param {LikeDeleteArgs} args - Arguments to delete one Like.
     * @example
     * // Delete one Like
     * const Like = await prisma.like.delete({
     *   where: {
     *     // ... filter to delete one Like
     *   }
     * })
     * 
    **/
    delete<T extends LikeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LikeDeleteArgs<ExtArgs>>
    ): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Like.
     * @param {LikeUpdateArgs} args - Arguments to update one Like.
     * @example
     * // Update one Like
     * const like = await prisma.like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LikeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LikeUpdateArgs<ExtArgs>>
    ): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Likes.
     * @param {LikeDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LikeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LikeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LikeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LikeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Like.
     * @param {LikeUpsertArgs} args - Arguments to update or create a Like.
     * @example
     * // Update or create a Like
     * const like = await prisma.like.upsert({
     *   create: {
     *     // ... data to create a Like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Like we want to update
     *   }
     * })
    **/
    upsert<T extends LikeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LikeUpsertArgs<ExtArgs>>
    ): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.like.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends LikeCountArgs>(
      args?: Subset<T, LikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeAggregateArgs>(args: Subset<T, LikeAggregateArgs>): Prisma.PrismaPromise<GetLikeAggregateType<T>>

    /**
     * Group by Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeGroupByArgs['orderBy'] }
        : { orderBy?: LikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Like model
   */
  readonly fields: LikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Post<T extends Like$PostArgs<ExtArgs> = {}>(args?: Subset<T, Like$PostArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Like model
   */ 
  interface LikeFieldRefs {
    readonly id: FieldRef<"Like", 'Int'>
    readonly user: FieldRef<"Like", 'String'>
    readonly post: FieldRef<"Like", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Like findUnique
   */
  export type LikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Like findUniqueOrThrow
   */
  export type LikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Like findFirst
   */
  export type LikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Like findFirstOrThrow
   */
  export type LikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Like findMany
   */
  export type LikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Like create
   */
  export type LikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to create a Like.
     */
    data: XOR<LikeCreateInput, LikeUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Like createMany
   */
  export type LikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Like update
   */
  export type LikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to update a Like.
     */
    data: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
    /**
     * Choose, which Like to update.
     */
    where: LikeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Like updateMany
   */
  export type LikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
  }


  /**
   * Like upsert
   */
  export type LikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The filter to search for the Like to update in case it exists.
     */
    where: LikeWhereUniqueInput
    /**
     * In case the Like found by the `where` argument doesn't exist, create a new Like with this data.
     */
    create: XOR<LikeCreateInput, LikeUncheckedCreateInput>
    /**
     * In case the Like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Like delete
   */
  export type LikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter which Like to delete.
     */
    where: LikeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Like deleteMany
   */
  export type LikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Likes to delete
     */
    where?: LikeWhereInput
  }


  /**
   * Like.Post
   */
  export type Like$PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
  }


  /**
   * Like without action
   */
  export type LikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
  }



  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogAvgAggregateOutputType = {
    id: number | null
    context: number | null
    type: number | null
    level: number | null
  }

  export type LogSumAggregateOutputType = {
    id: number | null
    context: number | null
    type: number | null
    level: number | null
  }

  export type LogMinAggregateOutputType = {
    id: number | null
    user: string | null
    context: number | null
    message: string | null
    type: number | null
    level: number | null
    timestamp: Date | null
  }

  export type LogMaxAggregateOutputType = {
    id: number | null
    user: string | null
    context: number | null
    message: string | null
    type: number | null
    level: number | null
    timestamp: Date | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    user: number
    context: number
    message: number
    type: number
    level: number
    timestamp: number
    _all: number
  }


  export type LogAvgAggregateInputType = {
    id?: true
    context?: true
    type?: true
    level?: true
  }

  export type LogSumAggregateInputType = {
    id?: true
    context?: true
    type?: true
    level?: true
  }

  export type LogMinAggregateInputType = {
    id?: true
    user?: true
    context?: true
    message?: true
    type?: true
    level?: true
    timestamp?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    user?: true
    context?: true
    message?: true
    type?: true
    level?: true
    timestamp?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    user?: true
    context?: true
    message?: true
    type?: true
    level?: true
    timestamp?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _avg?: LogAvgAggregateInputType
    _sum?: LogSumAggregateInputType
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: number
    user: string | null
    context: number | null
    message: string | null
    type: number | null
    level: number | null
    timestamp: Date | null
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user?: boolean
    context?: boolean
    message?: boolean
    type?: boolean
    level?: boolean
    timestamp?: boolean
    LogLevel?: boolean | Log$LogLevelArgs<ExtArgs>
    LogType?: boolean | Log$LogTypeArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectScalar = {
    id?: boolean
    user?: boolean
    context?: boolean
    message?: boolean
    type?: boolean
    level?: boolean
    timestamp?: boolean
  }

  export type LogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LogLevel?: boolean | Log$LogLevelArgs<ExtArgs>
    LogType?: boolean | Log$LogTypeArgs<ExtArgs>
  }


  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {
      LogLevel: Prisma.$LogLevelPayload<ExtArgs> | null
      LogType: Prisma.$LogTypePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user: string | null
      context: number | null
      message: string | null
      type: number | null
      level: number | null
      timestamp: Date | null
    }, ExtArgs["result"]["log"]>
    composites: {}
  }


  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>
    ): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Log that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>
    ): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
    **/
    create<T extends LogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogCreateArgs<ExtArgs>>
    ): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Logs.
     *     @param {LogCreateManyArgs} args - Arguments to create many Logs.
     *     @example
     *     // Create many Logs
     *     const log = await prisma.log.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
    **/
    delete<T extends LogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogDeleteArgs<ExtArgs>>
    ): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogUpdateArgs<ExtArgs>>
    ): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
    **/
    upsert<T extends LogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogUpsertArgs<ExtArgs>>
    ): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    LogLevel<T extends Log$LogLevelArgs<ExtArgs> = {}>(args?: Subset<T, Log$LogLevelArgs<ExtArgs>>): Prisma__LogLevelClient<$Result.GetResult<Prisma.$LogLevelPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    LogType<T extends Log$LogTypeArgs<ExtArgs> = {}>(args?: Subset<T, Log$LogTypeArgs<ExtArgs>>): Prisma__LogTypeClient<$Result.GetResult<Prisma.$LogTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Log model
   */ 
  interface LogFieldRefs {
    readonly id: FieldRef<"Log", 'Int'>
    readonly user: FieldRef<"Log", 'String'>
    readonly context: FieldRef<"Log", 'Int'>
    readonly message: FieldRef<"Log", 'String'>
    readonly type: FieldRef<"Log", 'Int'>
    readonly level: FieldRef<"Log", 'Int'>
    readonly timestamp: FieldRef<"Log", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data?: XOR<LogCreateInput, LogUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
  }


  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
  }


  /**
   * Log.LogLevel
   */
  export type Log$LogLevelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLevel
     */
    select?: LogLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLevelInclude<ExtArgs> | null
    where?: LogLevelWhereInput
  }


  /**
   * Log.LogType
   */
  export type Log$LogTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogType
     */
    select?: LogTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTypeInclude<ExtArgs> | null
    where?: LogTypeWhereInput
  }


  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogInclude<ExtArgs> | null
  }



  /**
   * Model PendingPost
   */

  export type AggregatePendingPost = {
    _count: PendingPostCountAggregateOutputType | null
    _avg: PendingPostAvgAggregateOutputType | null
    _sum: PendingPostSumAggregateOutputType | null
    _min: PendingPostMinAggregateOutputType | null
    _max: PendingPostMaxAggregateOutputType | null
  }

  export type PendingPostAvgAggregateOutputType = {
    id: number | null
    community: number | null
    status: number | null
  }

  export type PendingPostSumAggregateOutputType = {
    id: number | null
    community: number | null
    status: number | null
  }

  export type PendingPostMinAggregateOutputType = {
    id: number | null
    Content: string | null
    fileUrl: string | null
    community: number | null
    user: string | null
    caption: string | null
    status: number | null
    confirmationToken: string | null
  }

  export type PendingPostMaxAggregateOutputType = {
    id: number | null
    Content: string | null
    fileUrl: string | null
    community: number | null
    user: string | null
    caption: string | null
    status: number | null
    confirmationToken: string | null
  }

  export type PendingPostCountAggregateOutputType = {
    id: number
    Content: number
    fileUrl: number
    community: number
    user: number
    caption: number
    status: number
    confirmationToken: number
    _all: number
  }


  export type PendingPostAvgAggregateInputType = {
    id?: true
    community?: true
    status?: true
  }

  export type PendingPostSumAggregateInputType = {
    id?: true
    community?: true
    status?: true
  }

  export type PendingPostMinAggregateInputType = {
    id?: true
    Content?: true
    fileUrl?: true
    community?: true
    user?: true
    caption?: true
    status?: true
    confirmationToken?: true
  }

  export type PendingPostMaxAggregateInputType = {
    id?: true
    Content?: true
    fileUrl?: true
    community?: true
    user?: true
    caption?: true
    status?: true
    confirmationToken?: true
  }

  export type PendingPostCountAggregateInputType = {
    id?: true
    Content?: true
    fileUrl?: true
    community?: true
    user?: true
    caption?: true
    status?: true
    confirmationToken?: true
    _all?: true
  }

  export type PendingPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingPost to aggregate.
     */
    where?: PendingPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPosts to fetch.
     */
    orderBy?: PendingPostOrderByWithRelationInput | PendingPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendingPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingPosts
    **/
    _count?: true | PendingPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendingPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendingPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendingPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendingPostMaxAggregateInputType
  }

  export type GetPendingPostAggregateType<T extends PendingPostAggregateArgs> = {
        [P in keyof T & keyof AggregatePendingPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingPost[P]>
      : GetScalarType<T[P], AggregatePendingPost[P]>
  }




  export type PendingPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingPostWhereInput
    orderBy?: PendingPostOrderByWithAggregationInput | PendingPostOrderByWithAggregationInput[]
    by: PendingPostScalarFieldEnum[] | PendingPostScalarFieldEnum
    having?: PendingPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendingPostCountAggregateInputType | true
    _avg?: PendingPostAvgAggregateInputType
    _sum?: PendingPostSumAggregateInputType
    _min?: PendingPostMinAggregateInputType
    _max?: PendingPostMaxAggregateInputType
  }

  export type PendingPostGroupByOutputType = {
    id: number
    Content: string | null
    fileUrl: string
    community: number
    user: string
    caption: string | null
    status: number | null
    confirmationToken: string | null
    _count: PendingPostCountAggregateOutputType | null
    _avg: PendingPostAvgAggregateOutputType | null
    _sum: PendingPostSumAggregateOutputType | null
    _min: PendingPostMinAggregateOutputType | null
    _max: PendingPostMaxAggregateOutputType | null
  }

  type GetPendingPostGroupByPayload<T extends PendingPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendingPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendingPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendingPostGroupByOutputType[P]>
            : GetScalarType<T[P], PendingPostGroupByOutputType[P]>
        }
      >
    >


  export type PendingPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Content?: boolean
    fileUrl?: boolean
    community?: boolean
    user?: boolean
    caption?: boolean
    status?: boolean
    confirmationToken?: boolean
    PendingPostStatus?: boolean | PendingPost$PendingPostStatusArgs<ExtArgs>
    _count?: boolean | PendingPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingPost"]>

  export type PendingPostSelectScalar = {
    id?: boolean
    Content?: boolean
    fileUrl?: boolean
    community?: boolean
    user?: boolean
    caption?: boolean
    status?: boolean
    confirmationToken?: boolean
  }

  export type PendingPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PendingPostStatus?: boolean | PendingPost$PendingPostStatusArgs<ExtArgs>
    _count?: boolean | PendingPostCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PendingPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PendingPost"
    objects: {
      PendingPostStatus: Prisma.$PendingPostStatusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      Content: string | null
      fileUrl: string
      community: number
      user: string
      caption: string | null
      status: number | null
      confirmationToken: string | null
    }, ExtArgs["result"]["pendingPost"]>
    composites: {}
  }


  type PendingPostGetPayload<S extends boolean | null | undefined | PendingPostDefaultArgs> = $Result.GetResult<Prisma.$PendingPostPayload, S>

  type PendingPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PendingPostFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: PendingPostCountAggregateInputType | true
    }

  export interface PendingPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PendingPost'], meta: { name: 'PendingPost' } }
    /**
     * Find zero or one PendingPost that matches the filter.
     * @param {PendingPostFindUniqueArgs} args - Arguments to find a PendingPost
     * @example
     * // Get one PendingPost
     * const pendingPost = await prisma.pendingPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PendingPostFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PendingPostFindUniqueArgs<ExtArgs>>
    ): Prisma__PendingPostClient<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PendingPost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PendingPostFindUniqueOrThrowArgs} args - Arguments to find a PendingPost
     * @example
     * // Get one PendingPost
     * const pendingPost = await prisma.pendingPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PendingPostFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingPostFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PendingPostClient<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PendingPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostFindFirstArgs} args - Arguments to find a PendingPost
     * @example
     * // Get one PendingPost
     * const pendingPost = await prisma.pendingPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PendingPostFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingPostFindFirstArgs<ExtArgs>>
    ): Prisma__PendingPostClient<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PendingPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostFindFirstOrThrowArgs} args - Arguments to find a PendingPost
     * @example
     * // Get one PendingPost
     * const pendingPost = await prisma.pendingPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PendingPostFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingPostFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PendingPostClient<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PendingPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingPosts
     * const pendingPosts = await prisma.pendingPost.findMany()
     * 
     * // Get first 10 PendingPosts
     * const pendingPosts = await prisma.pendingPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingPostWithIdOnly = await prisma.pendingPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PendingPostFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingPostFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PendingPost.
     * @param {PendingPostCreateArgs} args - Arguments to create a PendingPost.
     * @example
     * // Create one PendingPost
     * const PendingPost = await prisma.pendingPost.create({
     *   data: {
     *     // ... data to create a PendingPost
     *   }
     * })
     * 
    **/
    create<T extends PendingPostCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PendingPostCreateArgs<ExtArgs>>
    ): Prisma__PendingPostClient<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PendingPosts.
     *     @param {PendingPostCreateManyArgs} args - Arguments to create many PendingPosts.
     *     @example
     *     // Create many PendingPosts
     *     const pendingPost = await prisma.pendingPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PendingPostCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingPostCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PendingPost.
     * @param {PendingPostDeleteArgs} args - Arguments to delete one PendingPost.
     * @example
     * // Delete one PendingPost
     * const PendingPost = await prisma.pendingPost.delete({
     *   where: {
     *     // ... filter to delete one PendingPost
     *   }
     * })
     * 
    **/
    delete<T extends PendingPostDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PendingPostDeleteArgs<ExtArgs>>
    ): Prisma__PendingPostClient<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PendingPost.
     * @param {PendingPostUpdateArgs} args - Arguments to update one PendingPost.
     * @example
     * // Update one PendingPost
     * const pendingPost = await prisma.pendingPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PendingPostUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PendingPostUpdateArgs<ExtArgs>>
    ): Prisma__PendingPostClient<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PendingPosts.
     * @param {PendingPostDeleteManyArgs} args - Arguments to filter PendingPosts to delete.
     * @example
     * // Delete a few PendingPosts
     * const { count } = await prisma.pendingPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PendingPostDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingPostDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingPosts
     * const pendingPost = await prisma.pendingPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PendingPostUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PendingPostUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PendingPost.
     * @param {PendingPostUpsertArgs} args - Arguments to update or create a PendingPost.
     * @example
     * // Update or create a PendingPost
     * const pendingPost = await prisma.pendingPost.upsert({
     *   create: {
     *     // ... data to create a PendingPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingPost we want to update
     *   }
     * })
    **/
    upsert<T extends PendingPostUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PendingPostUpsertArgs<ExtArgs>>
    ): Prisma__PendingPostClient<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PendingPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostCountArgs} args - Arguments to filter PendingPosts to count.
     * @example
     * // Count the number of PendingPosts
     * const count = await prisma.pendingPost.count({
     *   where: {
     *     // ... the filter for the PendingPosts we want to count
     *   }
     * })
    **/
    count<T extends PendingPostCountArgs>(
      args?: Subset<T, PendingPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingPostAggregateArgs>(args: Subset<T, PendingPostAggregateArgs>): Prisma.PrismaPromise<GetPendingPostAggregateType<T>>

    /**
     * Group by PendingPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingPostGroupByArgs['orderBy'] }
        : { orderBy?: PendingPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PendingPost model
   */
  readonly fields: PendingPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendingPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    PendingPostStatus<T extends PendingPost$PendingPostStatusArgs<ExtArgs> = {}>(args?: Subset<T, PendingPost$PendingPostStatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingPostStatusPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PendingPost model
   */ 
  interface PendingPostFieldRefs {
    readonly id: FieldRef<"PendingPost", 'Int'>
    readonly Content: FieldRef<"PendingPost", 'String'>
    readonly fileUrl: FieldRef<"PendingPost", 'String'>
    readonly community: FieldRef<"PendingPost", 'Int'>
    readonly user: FieldRef<"PendingPost", 'String'>
    readonly caption: FieldRef<"PendingPost", 'String'>
    readonly status: FieldRef<"PendingPost", 'Int'>
    readonly confirmationToken: FieldRef<"PendingPost", 'String'>
  }
    

  // Custom InputTypes

  /**
   * PendingPost findUnique
   */
  export type PendingPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    /**
     * Filter, which PendingPost to fetch.
     */
    where: PendingPostWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * PendingPost findUniqueOrThrow
   */
  export type PendingPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    /**
     * Filter, which PendingPost to fetch.
     */
    where: PendingPostWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * PendingPost findFirst
   */
  export type PendingPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    /**
     * Filter, which PendingPost to fetch.
     */
    where?: PendingPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPosts to fetch.
     */
    orderBy?: PendingPostOrderByWithRelationInput | PendingPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingPosts.
     */
    cursor?: PendingPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingPosts.
     */
    distinct?: PendingPostScalarFieldEnum | PendingPostScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * PendingPost findFirstOrThrow
   */
  export type PendingPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    /**
     * Filter, which PendingPost to fetch.
     */
    where?: PendingPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPosts to fetch.
     */
    orderBy?: PendingPostOrderByWithRelationInput | PendingPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingPosts.
     */
    cursor?: PendingPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingPosts.
     */
    distinct?: PendingPostScalarFieldEnum | PendingPostScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * PendingPost findMany
   */
  export type PendingPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    /**
     * Filter, which PendingPosts to fetch.
     */
    where?: PendingPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPosts to fetch.
     */
    orderBy?: PendingPostOrderByWithRelationInput | PendingPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingPosts.
     */
    cursor?: PendingPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPosts.
     */
    skip?: number
    distinct?: PendingPostScalarFieldEnum | PendingPostScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * PendingPost create
   */
  export type PendingPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    /**
     * The data needed to create a PendingPost.
     */
    data: XOR<PendingPostCreateInput, PendingPostUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * PendingPost createMany
   */
  export type PendingPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PendingPosts.
     */
    data: PendingPostCreateManyInput | PendingPostCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PendingPost update
   */
  export type PendingPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    /**
     * The data needed to update a PendingPost.
     */
    data: XOR<PendingPostUpdateInput, PendingPostUncheckedUpdateInput>
    /**
     * Choose, which PendingPost to update.
     */
    where: PendingPostWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * PendingPost updateMany
   */
  export type PendingPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PendingPosts.
     */
    data: XOR<PendingPostUpdateManyMutationInput, PendingPostUncheckedUpdateManyInput>
    /**
     * Filter which PendingPosts to update
     */
    where?: PendingPostWhereInput
  }


  /**
   * PendingPost upsert
   */
  export type PendingPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    /**
     * The filter to search for the PendingPost to update in case it exists.
     */
    where: PendingPostWhereUniqueInput
    /**
     * In case the PendingPost found by the `where` argument doesn't exist, create a new PendingPost with this data.
     */
    create: XOR<PendingPostCreateInput, PendingPostUncheckedCreateInput>
    /**
     * In case the PendingPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendingPostUpdateInput, PendingPostUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * PendingPost delete
   */
  export type PendingPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    /**
     * Filter which PendingPost to delete.
     */
    where: PendingPostWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * PendingPost deleteMany
   */
  export type PendingPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingPosts to delete
     */
    where?: PendingPostWhereInput
  }


  /**
   * PendingPost.PendingPostStatus
   */
  export type PendingPost$PendingPostStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPostStatus
     */
    select?: PendingPostStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostStatusInclude<ExtArgs> | null
    where?: PendingPostStatusWhereInput
    orderBy?: PendingPostStatusOrderByWithRelationInput | PendingPostStatusOrderByWithRelationInput[]
    cursor?: PendingPostStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendingPostStatusScalarFieldEnum | PendingPostStatusScalarFieldEnum[]
  }


  /**
   * PendingPost without action
   */
  export type PendingPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
  }



  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    id: number | null
    community: number | null
  }

  export type PostSumAggregateOutputType = {
    id: number | null
    community: number | null
  }

  export type PostMinAggregateOutputType = {
    id: number | null
    Content: string | null
    fileUrl: string | null
    community: number | null
    user: string | null
    caption: string | null
  }

  export type PostMaxAggregateOutputType = {
    id: number | null
    Content: string | null
    fileUrl: string | null
    community: number | null
    user: string | null
    caption: string | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    Content: number
    fileUrl: number
    community: number
    user: number
    caption: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    id?: true
    community?: true
  }

  export type PostSumAggregateInputType = {
    id?: true
    community?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    Content?: true
    fileUrl?: true
    community?: true
    user?: true
    caption?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    Content?: true
    fileUrl?: true
    community?: true
    user?: true
    caption?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    Content?: true
    fileUrl?: true
    community?: true
    user?: true
    caption?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: number
    Content: string | null
    fileUrl: string
    community: number
    user: string
    caption: string | null
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Content?: boolean
    fileUrl?: boolean
    community?: boolean
    user?: boolean
    caption?: boolean
    Comment?: boolean | Post$CommentArgs<ExtArgs>
    Like?: boolean | Post$LikeArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    Content?: boolean
    fileUrl?: boolean
    community?: boolean
    user?: boolean
    caption?: boolean
  }

  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | Post$CommentArgs<ExtArgs>
    Like?: boolean | Post$LikeArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      Comment: Prisma.$CommentPayload<ExtArgs>[]
      Like: Prisma.$LikePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      Content: string | null
      fileUrl: string
      community: number
      user: string
      caption: string | null
    }, ExtArgs["result"]["post"]>
    composites: {}
  }


  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Post that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
    **/
    create<T extends PostCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PostCreateArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Posts.
     *     @param {PostCreateManyArgs} args - Arguments to create many Posts.
     *     @example
     *     // Create many Posts
     *     const post = await prisma.post.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
    **/
    delete<T extends PostDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PostDeleteArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PostUpdateArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
    **/
    upsert<T extends PostUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PostUpsertArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Comment<T extends Post$CommentArgs<ExtArgs> = {}>(args?: Subset<T, Post$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null>;

    Like<T extends Post$LikeArgs<ExtArgs> = {}>(args?: Subset<T, Post$LikeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Post model
   */ 
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'Int'>
    readonly Content: FieldRef<"Post", 'String'>
    readonly fileUrl: FieldRef<"Post", 'String'>
    readonly community: FieldRef<"Post", 'Int'>
    readonly user: FieldRef<"Post", 'String'>
    readonly caption: FieldRef<"Post", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }


  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }


  /**
   * Post.Comment
   */
  export type Post$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Post.Like
   */
  export type Post$LikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }


  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
  }



  /**
   * Model Preferences
   */

  export type AggregatePreferences = {
    _count: PreferencesCountAggregateOutputType | null
    _avg: PreferencesAvgAggregateOutputType | null
    _sum: PreferencesSumAggregateOutputType | null
    _min: PreferencesMinAggregateOutputType | null
    _max: PreferencesMaxAggregateOutputType | null
  }

  export type PreferencesAvgAggregateOutputType = {
    id: number | null
  }

  export type PreferencesSumAggregateOutputType = {
    id: number | null
  }

  export type PreferencesMinAggregateOutputType = {
    id: number | null
    user: string | null
    enableContextBasedAuth: boolean | null
  }

  export type PreferencesMaxAggregateOutputType = {
    id: number | null
    user: string | null
    enableContextBasedAuth: boolean | null
  }

  export type PreferencesCountAggregateOutputType = {
    id: number
    user: number
    enableContextBasedAuth: number
    _all: number
  }


  export type PreferencesAvgAggregateInputType = {
    id?: true
  }

  export type PreferencesSumAggregateInputType = {
    id?: true
  }

  export type PreferencesMinAggregateInputType = {
    id?: true
    user?: true
    enableContextBasedAuth?: true
  }

  export type PreferencesMaxAggregateInputType = {
    id?: true
    user?: true
    enableContextBasedAuth?: true
  }

  export type PreferencesCountAggregateInputType = {
    id?: true
    user?: true
    enableContextBasedAuth?: true
    _all?: true
  }

  export type PreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Preferences to aggregate.
     */
    where?: PreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preferences to fetch.
     */
    orderBy?: PreferencesOrderByWithRelationInput | PreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Preferences
    **/
    _count?: true | PreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreferencesMaxAggregateInputType
  }

  export type GetPreferencesAggregateType<T extends PreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregatePreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreferences[P]>
      : GetScalarType<T[P], AggregatePreferences[P]>
  }




  export type PreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferencesWhereInput
    orderBy?: PreferencesOrderByWithAggregationInput | PreferencesOrderByWithAggregationInput[]
    by: PreferencesScalarFieldEnum[] | PreferencesScalarFieldEnum
    having?: PreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreferencesCountAggregateInputType | true
    _avg?: PreferencesAvgAggregateInputType
    _sum?: PreferencesSumAggregateInputType
    _min?: PreferencesMinAggregateInputType
    _max?: PreferencesMaxAggregateInputType
  }

  export type PreferencesGroupByOutputType = {
    id: number
    user: string | null
    enableContextBasedAuth: boolean | null
    _count: PreferencesCountAggregateOutputType | null
    _avg: PreferencesAvgAggregateOutputType | null
    _sum: PreferencesSumAggregateOutputType | null
    _min: PreferencesMinAggregateOutputType | null
    _max: PreferencesMaxAggregateOutputType | null
  }

  type GetPreferencesGroupByPayload<T extends PreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], PreferencesGroupByOutputType[P]>
        }
      >
    >


  export type PreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user?: boolean
    enableContextBasedAuth?: boolean
  }, ExtArgs["result"]["preferences"]>

  export type PreferencesSelectScalar = {
    id?: boolean
    user?: boolean
    enableContextBasedAuth?: boolean
  }


  export type $PreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Preferences"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user: string | null
      enableContextBasedAuth: boolean | null
    }, ExtArgs["result"]["preferences"]>
    composites: {}
  }


  type PreferencesGetPayload<S extends boolean | null | undefined | PreferencesDefaultArgs> = $Result.GetResult<Prisma.$PreferencesPayload, S>

  type PreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PreferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: PreferencesCountAggregateInputType | true
    }

  export interface PreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Preferences'], meta: { name: 'Preferences' } }
    /**
     * Find zero or one Preferences that matches the filter.
     * @param {PreferencesFindUniqueArgs} args - Arguments to find a Preferences
     * @example
     * // Get one Preferences
     * const preferences = await prisma.preferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PreferencesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PreferencesFindUniqueArgs<ExtArgs>>
    ): Prisma__PreferencesClient<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Preferences that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PreferencesFindUniqueOrThrowArgs} args - Arguments to find a Preferences
     * @example
     * // Get one Preferences
     * const preferences = await prisma.preferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PreferencesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferencesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PreferencesClient<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesFindFirstArgs} args - Arguments to find a Preferences
     * @example
     * // Get one Preferences
     * const preferences = await prisma.preferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PreferencesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferencesFindFirstArgs<ExtArgs>>
    ): Prisma__PreferencesClient<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Preferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesFindFirstOrThrowArgs} args - Arguments to find a Preferences
     * @example
     * // Get one Preferences
     * const preferences = await prisma.preferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PreferencesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferencesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PreferencesClient<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Preferences
     * const preferences = await prisma.preferences.findMany()
     * 
     * // Get first 10 Preferences
     * const preferences = await prisma.preferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preferencesWithIdOnly = await prisma.preferences.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PreferencesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferencesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Preferences.
     * @param {PreferencesCreateArgs} args - Arguments to create a Preferences.
     * @example
     * // Create one Preferences
     * const Preferences = await prisma.preferences.create({
     *   data: {
     *     // ... data to create a Preferences
     *   }
     * })
     * 
    **/
    create<T extends PreferencesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PreferencesCreateArgs<ExtArgs>>
    ): Prisma__PreferencesClient<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Preferences.
     *     @param {PreferencesCreateManyArgs} args - Arguments to create many Preferences.
     *     @example
     *     // Create many Preferences
     *     const preferences = await prisma.preferences.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PreferencesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferencesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Preferences.
     * @param {PreferencesDeleteArgs} args - Arguments to delete one Preferences.
     * @example
     * // Delete one Preferences
     * const Preferences = await prisma.preferences.delete({
     *   where: {
     *     // ... filter to delete one Preferences
     *   }
     * })
     * 
    **/
    delete<T extends PreferencesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PreferencesDeleteArgs<ExtArgs>>
    ): Prisma__PreferencesClient<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Preferences.
     * @param {PreferencesUpdateArgs} args - Arguments to update one Preferences.
     * @example
     * // Update one Preferences
     * const preferences = await prisma.preferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PreferencesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PreferencesUpdateArgs<ExtArgs>>
    ): Prisma__PreferencesClient<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Preferences.
     * @param {PreferencesDeleteManyArgs} args - Arguments to filter Preferences to delete.
     * @example
     * // Delete a few Preferences
     * const { count } = await prisma.preferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PreferencesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferencesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Preferences
     * const preferences = await prisma.preferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PreferencesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PreferencesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Preferences.
     * @param {PreferencesUpsertArgs} args - Arguments to update or create a Preferences.
     * @example
     * // Update or create a Preferences
     * const preferences = await prisma.preferences.upsert({
     *   create: {
     *     // ... data to create a Preferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Preferences we want to update
     *   }
     * })
    **/
    upsert<T extends PreferencesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PreferencesUpsertArgs<ExtArgs>>
    ): Prisma__PreferencesClient<$Result.GetResult<Prisma.$PreferencesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesCountArgs} args - Arguments to filter Preferences to count.
     * @example
     * // Count the number of Preferences
     * const count = await prisma.preferences.count({
     *   where: {
     *     // ... the filter for the Preferences we want to count
     *   }
     * })
    **/
    count<T extends PreferencesCountArgs>(
      args?: Subset<T, PreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreferencesAggregateArgs>(args: Subset<T, PreferencesAggregateArgs>): Prisma.PrismaPromise<GetPreferencesAggregateType<T>>

    /**
     * Group by Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreferencesGroupByArgs['orderBy'] }
        : { orderBy?: PreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Preferences model
   */
  readonly fields: PreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Preferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Preferences model
   */ 
  interface PreferencesFieldRefs {
    readonly id: FieldRef<"Preferences", 'Int'>
    readonly user: FieldRef<"Preferences", 'String'>
    readonly enableContextBasedAuth: FieldRef<"Preferences", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Preferences findUnique
   */
  export type PreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * Filter, which Preferences to fetch.
     */
    where: PreferencesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Preferences findUniqueOrThrow
   */
  export type PreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * Filter, which Preferences to fetch.
     */
    where: PreferencesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Preferences findFirst
   */
  export type PreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * Filter, which Preferences to fetch.
     */
    where?: PreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preferences to fetch.
     */
    orderBy?: PreferencesOrderByWithRelationInput | PreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Preferences.
     */
    cursor?: PreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Preferences.
     */
    distinct?: PreferencesScalarFieldEnum | PreferencesScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Preferences findFirstOrThrow
   */
  export type PreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * Filter, which Preferences to fetch.
     */
    where?: PreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preferences to fetch.
     */
    orderBy?: PreferencesOrderByWithRelationInput | PreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Preferences.
     */
    cursor?: PreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Preferences.
     */
    distinct?: PreferencesScalarFieldEnum | PreferencesScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Preferences findMany
   */
  export type PreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * Filter, which Preferences to fetch.
     */
    where?: PreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preferences to fetch.
     */
    orderBy?: PreferencesOrderByWithRelationInput | PreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Preferences.
     */
    cursor?: PreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preferences.
     */
    skip?: number
    distinct?: PreferencesScalarFieldEnum | PreferencesScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Preferences create
   */
  export type PreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * The data needed to create a Preferences.
     */
    data?: XOR<PreferencesCreateInput, PreferencesUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Preferences createMany
   */
  export type PreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Preferences.
     */
    data: PreferencesCreateManyInput | PreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Preferences update
   */
  export type PreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * The data needed to update a Preferences.
     */
    data: XOR<PreferencesUpdateInput, PreferencesUncheckedUpdateInput>
    /**
     * Choose, which Preferences to update.
     */
    where: PreferencesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Preferences updateMany
   */
  export type PreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Preferences.
     */
    data: XOR<PreferencesUpdateManyMutationInput, PreferencesUncheckedUpdateManyInput>
    /**
     * Filter which Preferences to update
     */
    where?: PreferencesWhereInput
  }


  /**
   * Preferences upsert
   */
  export type PreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * The filter to search for the Preferences to update in case it exists.
     */
    where: PreferencesWhereUniqueInput
    /**
     * In case the Preferences found by the `where` argument doesn't exist, create a new Preferences with this data.
     */
    create: XOR<PreferencesCreateInput, PreferencesUncheckedCreateInput>
    /**
     * In case the Preferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PreferencesUpdateInput, PreferencesUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Preferences delete
   */
  export type PreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
    /**
     * Filter which Preferences to delete.
     */
    where: PreferencesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Preferences deleteMany
   */
  export type PreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Preferences to delete
     */
    where?: PreferencesWhereInput
  }


  /**
   * Preferences without action
   */
  export type PreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null
  }



  /**
   * Model Relationship
   */

  export type AggregateRelationship = {
    _count: RelationshipCountAggregateOutputType | null
    _avg: RelationshipAvgAggregateOutputType | null
    _sum: RelationshipSumAggregateOutputType | null
    _min: RelationshipMinAggregateOutputType | null
    _max: RelationshipMaxAggregateOutputType | null
  }

  export type RelationshipAvgAggregateOutputType = {
    id: number | null
  }

  export type RelationshipSumAggregateOutputType = {
    id: number | null
  }

  export type RelationshipMinAggregateOutputType = {
    id: number | null
    follower: string | null
    following: string | null
  }

  export type RelationshipMaxAggregateOutputType = {
    id: number | null
    follower: string | null
    following: string | null
  }

  export type RelationshipCountAggregateOutputType = {
    id: number
    follower: number
    following: number
    _all: number
  }


  export type RelationshipAvgAggregateInputType = {
    id?: true
  }

  export type RelationshipSumAggregateInputType = {
    id?: true
  }

  export type RelationshipMinAggregateInputType = {
    id?: true
    follower?: true
    following?: true
  }

  export type RelationshipMaxAggregateInputType = {
    id?: true
    follower?: true
    following?: true
  }

  export type RelationshipCountAggregateInputType = {
    id?: true
    follower?: true
    following?: true
    _all?: true
  }

  export type RelationshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Relationship to aggregate.
     */
    where?: RelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relationships to fetch.
     */
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Relationships
    **/
    _count?: true | RelationshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelationshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelationshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelationshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelationshipMaxAggregateInputType
  }

  export type GetRelationshipAggregateType<T extends RelationshipAggregateArgs> = {
        [P in keyof T & keyof AggregateRelationship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelationship[P]>
      : GetScalarType<T[P], AggregateRelationship[P]>
  }




  export type RelationshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationshipWhereInput
    orderBy?: RelationshipOrderByWithAggregationInput | RelationshipOrderByWithAggregationInput[]
    by: RelationshipScalarFieldEnum[] | RelationshipScalarFieldEnum
    having?: RelationshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelationshipCountAggregateInputType | true
    _avg?: RelationshipAvgAggregateInputType
    _sum?: RelationshipSumAggregateInputType
    _min?: RelationshipMinAggregateInputType
    _max?: RelationshipMaxAggregateInputType
  }

  export type RelationshipGroupByOutputType = {
    id: number
    follower: string
    following: string
    _count: RelationshipCountAggregateOutputType | null
    _avg: RelationshipAvgAggregateOutputType | null
    _sum: RelationshipSumAggregateOutputType | null
    _min: RelationshipMinAggregateOutputType | null
    _max: RelationshipMaxAggregateOutputType | null
  }

  type GetRelationshipGroupByPayload<T extends RelationshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelationshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelationshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelationshipGroupByOutputType[P]>
            : GetScalarType<T[P], RelationshipGroupByOutputType[P]>
        }
      >
    >


  export type RelationshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    follower?: boolean
    following?: boolean
  }, ExtArgs["result"]["relationship"]>

  export type RelationshipSelectScalar = {
    id?: boolean
    follower?: boolean
    following?: boolean
  }


  export type $RelationshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Relationship"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      follower: string
      following: string
    }, ExtArgs["result"]["relationship"]>
    composites: {}
  }


  type RelationshipGetPayload<S extends boolean | null | undefined | RelationshipDefaultArgs> = $Result.GetResult<Prisma.$RelationshipPayload, S>

  type RelationshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RelationshipFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: RelationshipCountAggregateInputType | true
    }

  export interface RelationshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Relationship'], meta: { name: 'Relationship' } }
    /**
     * Find zero or one Relationship that matches the filter.
     * @param {RelationshipFindUniqueArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RelationshipFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RelationshipFindUniqueArgs<ExtArgs>>
    ): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Relationship that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RelationshipFindUniqueOrThrowArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RelationshipFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RelationshipFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Relationship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipFindFirstArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RelationshipFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RelationshipFindFirstArgs<ExtArgs>>
    ): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Relationship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipFindFirstOrThrowArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RelationshipFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RelationshipFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Relationships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Relationships
     * const relationships = await prisma.relationship.findMany()
     * 
     * // Get first 10 Relationships
     * const relationships = await prisma.relationship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relationshipWithIdOnly = await prisma.relationship.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RelationshipFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RelationshipFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Relationship.
     * @param {RelationshipCreateArgs} args - Arguments to create a Relationship.
     * @example
     * // Create one Relationship
     * const Relationship = await prisma.relationship.create({
     *   data: {
     *     // ... data to create a Relationship
     *   }
     * })
     * 
    **/
    create<T extends RelationshipCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RelationshipCreateArgs<ExtArgs>>
    ): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Relationships.
     *     @param {RelationshipCreateManyArgs} args - Arguments to create many Relationships.
     *     @example
     *     // Create many Relationships
     *     const relationship = await prisma.relationship.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RelationshipCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RelationshipCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Relationship.
     * @param {RelationshipDeleteArgs} args - Arguments to delete one Relationship.
     * @example
     * // Delete one Relationship
     * const Relationship = await prisma.relationship.delete({
     *   where: {
     *     // ... filter to delete one Relationship
     *   }
     * })
     * 
    **/
    delete<T extends RelationshipDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RelationshipDeleteArgs<ExtArgs>>
    ): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Relationship.
     * @param {RelationshipUpdateArgs} args - Arguments to update one Relationship.
     * @example
     * // Update one Relationship
     * const relationship = await prisma.relationship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RelationshipUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RelationshipUpdateArgs<ExtArgs>>
    ): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Relationships.
     * @param {RelationshipDeleteManyArgs} args - Arguments to filter Relationships to delete.
     * @example
     * // Delete a few Relationships
     * const { count } = await prisma.relationship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RelationshipDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RelationshipDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Relationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Relationships
     * const relationship = await prisma.relationship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RelationshipUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RelationshipUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Relationship.
     * @param {RelationshipUpsertArgs} args - Arguments to update or create a Relationship.
     * @example
     * // Update or create a Relationship
     * const relationship = await prisma.relationship.upsert({
     *   create: {
     *     // ... data to create a Relationship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Relationship we want to update
     *   }
     * })
    **/
    upsert<T extends RelationshipUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RelationshipUpsertArgs<ExtArgs>>
    ): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Relationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipCountArgs} args - Arguments to filter Relationships to count.
     * @example
     * // Count the number of Relationships
     * const count = await prisma.relationship.count({
     *   where: {
     *     // ... the filter for the Relationships we want to count
     *   }
     * })
    **/
    count<T extends RelationshipCountArgs>(
      args?: Subset<T, RelationshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelationshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Relationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelationshipAggregateArgs>(args: Subset<T, RelationshipAggregateArgs>): Prisma.PrismaPromise<GetRelationshipAggregateType<T>>

    /**
     * Group by Relationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelationshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelationshipGroupByArgs['orderBy'] }
        : { orderBy?: RelationshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelationshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelationshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Relationship model
   */
  readonly fields: RelationshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Relationship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelationshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Relationship model
   */ 
  interface RelationshipFieldRefs {
    readonly id: FieldRef<"Relationship", 'Int'>
    readonly follower: FieldRef<"Relationship", 'String'>
    readonly following: FieldRef<"Relationship", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Relationship findUnique
   */
  export type RelationshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Filter, which Relationship to fetch.
     */
    where: RelationshipWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Relationship findUniqueOrThrow
   */
  export type RelationshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Filter, which Relationship to fetch.
     */
    where: RelationshipWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Relationship findFirst
   */
  export type RelationshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Filter, which Relationship to fetch.
     */
    where?: RelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relationships to fetch.
     */
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Relationships.
     */
    cursor?: RelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Relationships.
     */
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Relationship findFirstOrThrow
   */
  export type RelationshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Filter, which Relationship to fetch.
     */
    where?: RelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relationships to fetch.
     */
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Relationships.
     */
    cursor?: RelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Relationships.
     */
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Relationship findMany
   */
  export type RelationshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Filter, which Relationships to fetch.
     */
    where?: RelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relationships to fetch.
     */
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Relationships.
     */
    cursor?: RelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relationships.
     */
    skip?: number
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Relationship create
   */
  export type RelationshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * The data needed to create a Relationship.
     */
    data: XOR<RelationshipCreateInput, RelationshipUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Relationship createMany
   */
  export type RelationshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Relationships.
     */
    data: RelationshipCreateManyInput | RelationshipCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Relationship update
   */
  export type RelationshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * The data needed to update a Relationship.
     */
    data: XOR<RelationshipUpdateInput, RelationshipUncheckedUpdateInput>
    /**
     * Choose, which Relationship to update.
     */
    where: RelationshipWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Relationship updateMany
   */
  export type RelationshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Relationships.
     */
    data: XOR<RelationshipUpdateManyMutationInput, RelationshipUncheckedUpdateManyInput>
    /**
     * Filter which Relationships to update
     */
    where?: RelationshipWhereInput
  }


  /**
   * Relationship upsert
   */
  export type RelationshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * The filter to search for the Relationship to update in case it exists.
     */
    where: RelationshipWhereUniqueInput
    /**
     * In case the Relationship found by the `where` argument doesn't exist, create a new Relationship with this data.
     */
    create: XOR<RelationshipCreateInput, RelationshipUncheckedCreateInput>
    /**
     * In case the Relationship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelationshipUpdateInput, RelationshipUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Relationship delete
   */
  export type RelationshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Filter which Relationship to delete.
     */
    where: RelationshipWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Relationship deleteMany
   */
  export type RelationshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Relationships to delete
     */
    where?: RelationshipWhereInput
  }


  /**
   * Relationship without action
   */
  export type RelationshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
  }



  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    id: number | null
    post: number | null
    community: number | null
  }

  export type ReportSumAggregateOutputType = {
    id: number | null
    post: number | null
    community: number | null
  }

  export type ReportMinAggregateOutputType = {
    id: number | null
    reportedBy: string | null
    post: number | null
    community: number | null
    reportReason: string | null
    reportDate: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: number | null
    reportedBy: string | null
    post: number | null
    community: number | null
    reportReason: string | null
    reportDate: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    reportedBy: number
    post: number
    community: number
    reportReason: number
    reportDate: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    id?: true
    post?: true
    community?: true
  }

  export type ReportSumAggregateInputType = {
    id?: true
    post?: true
    community?: true
  }

  export type ReportMinAggregateInputType = {
    id?: true
    reportedBy?: true
    post?: true
    community?: true
    reportReason?: true
    reportDate?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    reportedBy?: true
    post?: true
    community?: true
    reportReason?: true
    reportDate?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    reportedBy?: true
    post?: true
    community?: true
    reportReason?: true
    reportDate?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: number
    reportedBy: string
    post: number
    community: number
    reportReason: string | null
    reportDate: Date | null
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportedBy?: boolean
    post?: boolean
    community?: boolean
    reportReason?: boolean
    reportDate?: boolean
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    reportedBy?: boolean
    post?: boolean
    community?: boolean
    reportReason?: boolean
    reportDate?: boolean
  }


  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reportedBy: string
      post: number
      community: number
      reportReason: string | null
      reportDate: Date | null
    }, ExtArgs["result"]["report"]>
    composites: {}
  }


  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
    **/
    create<T extends ReportCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportCreateArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reports.
     *     @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     *     @example
     *     // Create many Reports
     *     const report = await prisma.report.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReportCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
    **/
    delete<T extends ReportDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
    **/
    upsert<T extends ReportUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'Int'>
    readonly reportedBy: FieldRef<"Report", 'String'>
    readonly post: FieldRef<"Report", 'Int'>
    readonly community: FieldRef<"Report", 'Int'>
    readonly reportReason: FieldRef<"Report", 'String'>
    readonly reportDate: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }


  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }


  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
  }



  /**
   * Model Token
   */

  export type AggregateToken = {
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  export type TokenAvgAggregateOutputType = {
    id: number | null
  }

  export type TokenSumAggregateOutputType = {
    id: number | null
  }

  export type TokenMinAggregateOutputType = {
    id: number | null
    user: string | null
    refreshToken: string | null
    accessToken: string | null
    createdAt: Date | null
  }

  export type TokenMaxAggregateOutputType = {
    id: number | null
    user: string | null
    refreshToken: string | null
    accessToken: string | null
    createdAt: Date | null
  }

  export type TokenCountAggregateOutputType = {
    id: number
    user: number
    refreshToken: number
    accessToken: number
    createdAt: number
    _all: number
  }


  export type TokenAvgAggregateInputType = {
    id?: true
  }

  export type TokenSumAggregateInputType = {
    id?: true
  }

  export type TokenMinAggregateInputType = {
    id?: true
    user?: true
    refreshToken?: true
    accessToken?: true
    createdAt?: true
  }

  export type TokenMaxAggregateInputType = {
    id?: true
    user?: true
    refreshToken?: true
    accessToken?: true
    createdAt?: true
  }

  export type TokenCountAggregateInputType = {
    id?: true
    user?: true
    refreshToken?: true
    accessToken?: true
    createdAt?: true
    _all?: true
  }

  export type TokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Token to aggregate.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tokens
    **/
    _count?: true | TokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMaxAggregateInputType
  }

  export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
        [P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken[P]>
      : GetScalarType<T[P], AggregateToken[P]>
  }




  export type TokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithAggregationInput | TokenOrderByWithAggregationInput[]
    by: TokenScalarFieldEnum[] | TokenScalarFieldEnum
    having?: TokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenCountAggregateInputType | true
    _avg?: TokenAvgAggregateInputType
    _sum?: TokenSumAggregateInputType
    _min?: TokenMinAggregateInputType
    _max?: TokenMaxAggregateInputType
  }

  export type TokenGroupByOutputType = {
    id: number
    user: string
    refreshToken: string | null
    accessToken: string | null
    createdAt: Date | null
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  type GetTokenGroupByPayload<T extends TokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenGroupByOutputType[P]>
            : GetScalarType<T[P], TokenGroupByOutputType[P]>
        }
      >
    >


  export type TokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    createdAt?: boolean
    User?: boolean | Token$UserArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectScalar = {
    id?: boolean
    user?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    createdAt?: boolean
  }

  export type TokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Token$UserArgs<ExtArgs>
  }


  export type $TokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Token"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user: string
      refreshToken: string | null
      accessToken: string | null
      createdAt: Date | null
    }, ExtArgs["result"]["token"]>
    composites: {}
  }


  type TokenGetPayload<S extends boolean | null | undefined | TokenDefaultArgs> = $Result.GetResult<Prisma.$TokenPayload, S>

  type TokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TokenFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: TokenCountAggregateInputType | true
    }

  export interface TokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Token'], meta: { name: 'Token' } }
    /**
     * Find zero or one Token that matches the filter.
     * @param {TokenFindUniqueArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TokenFindUniqueArgs<ExtArgs>>
    ): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Token that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TokenFindUniqueOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TokenFindFirstArgs<ExtArgs>>
    ): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.token.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenWithIdOnly = await prisma.token.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Token.
     * @param {TokenCreateArgs} args - Arguments to create a Token.
     * @example
     * // Create one Token
     * const Token = await prisma.token.create({
     *   data: {
     *     // ... data to create a Token
     *   }
     * })
     * 
    **/
    create<T extends TokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TokenCreateArgs<ExtArgs>>
    ): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tokens.
     *     @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
     *     @example
     *     // Create many Tokens
     *     const token = await prisma.token.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Token.
     * @param {TokenDeleteArgs} args - Arguments to delete one Token.
     * @example
     * // Delete one Token
     * const Token = await prisma.token.delete({
     *   where: {
     *     // ... filter to delete one Token
     *   }
     * })
     * 
    **/
    delete<T extends TokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TokenDeleteArgs<ExtArgs>>
    ): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Token.
     * @param {TokenUpdateArgs} args - Arguments to update one Token.
     * @example
     * // Update one Token
     * const token = await prisma.token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TokenUpdateArgs<ExtArgs>>
    ): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tokens.
     * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Token.
     * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
     * @example
     * // Update or create a Token
     * const token = await prisma.token.upsert({
     *   create: {
     *     // ... data to create a Token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token we want to update
     *   }
     * })
    **/
    upsert<T extends TokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TokenUpsertArgs<ExtArgs>>
    ): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.token.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends TokenCountArgs>(
      args?: Subset<T, TokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): Prisma.PrismaPromise<GetTokenAggregateType<T>>

    /**
     * Group by Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenGroupByArgs['orderBy'] }
        : { orderBy?: TokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Token model
   */
  readonly fields: TokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    User<T extends Token$UserArgs<ExtArgs> = {}>(args?: Subset<T, Token$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Token model
   */ 
  interface TokenFieldRefs {
    readonly id: FieldRef<"Token", 'Int'>
    readonly user: FieldRef<"Token", 'String'>
    readonly refreshToken: FieldRef<"Token", 'String'>
    readonly accessToken: FieldRef<"Token", 'String'>
    readonly createdAt: FieldRef<"Token", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Token findUnique
   */
  export type TokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Token findUniqueOrThrow
   */
  export type TokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Token findFirst
   */
  export type TokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Token findFirstOrThrow
   */
  export type TokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Token findMany
   */
  export type TokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Tokens to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Token create
   */
  export type TokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to create a Token.
     */
    data: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Token createMany
   */
  export type TokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Token update
   */
  export type TokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to update a Token.
     */
    data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    /**
     * Choose, which Token to update.
     */
    where: TokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Token updateMany
   */
  export type TokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
  }


  /**
   * Token upsert
   */
  export type TokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The filter to search for the Token to update in case it exists.
     */
    where: TokenWhereUniqueInput
    /**
     * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
     */
    create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    /**
     * In case the Token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Token delete
   */
  export type TokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter which Token to delete.
     */
    where: TokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Token deleteMany
   */
  export type TokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tokens to delete
     */
    where?: TokenWhereInput
  }


  /**
   * Token.User
   */
  export type Token$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Token without action
   */
  export type TokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
  }



  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    height: number | null
    weight: number | null
    age: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    height: number | null
    weight: number | null
    age: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    avatarUrl: string | null
    bio: string | null
    createdAt: Date | null
    isEmailVerified: boolean | null
    height: number | null
    weight: number | null
    age: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    avatarUrl: string | null
    bio: string | null
    createdAt: Date | null
    isEmailVerified: boolean | null
    height: number | null
    weight: number | null
    age: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    firstName: number
    lastName: number
    email: number
    password: number
    avatarUrl: number
    bio: number
    createdAt: number
    isEmailVerified: number
    height: number
    weight: number
    age: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    height?: true
    weight?: true
    age?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    height?: true
    weight?: true
    age?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    avatarUrl?: true
    bio?: true
    createdAt?: true
    isEmailVerified?: true
    height?: true
    weight?: true
    age?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    avatarUrl?: true
    bio?: true
    createdAt?: true
    isEmailVerified?: true
    height?: true
    weight?: true
    age?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    avatarUrl?: true
    bio?: true
    createdAt?: true
    isEmailVerified?: true
    height?: true
    weight?: true
    age?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    firstName: string
    lastName: string
    email: string
    password: string
    avatarUrl: string | null
    bio: string | null
    createdAt: Date | null
    isEmailVerified: boolean | null
    height: number | null
    weight: number | null
    age: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    avatarUrl?: boolean
    bio?: boolean
    createdAt?: boolean
    isEmailVerified?: boolean
    height?: boolean
    weight?: boolean
    age?: boolean
    CommunityUser?: boolean | User$CommunityUserArgs<ExtArgs>
    Token?: boolean | User$TokenArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    avatarUrl?: boolean
    bio?: boolean
    createdAt?: boolean
    isEmailVerified?: boolean
    height?: boolean
    weight?: boolean
    age?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CommunityUser?: boolean | User$CommunityUserArgs<ExtArgs>
    Token?: boolean | User$TokenArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      CommunityUser: Prisma.$CommunityUserPayload<ExtArgs>[]
      Token: Prisma.$TokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      firstName: string
      lastName: string
      email: string
      password: string
      avatarUrl: string | null
      bio: string | null
      createdAt: Date | null
      isEmailVerified: boolean | null
      height: number | null
      weight: number | null
      age: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    CommunityUser<T extends User$CommunityUserArgs<ExtArgs> = {}>(args?: Subset<T, User$CommunityUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    Token<T extends User$TokenArgs<ExtArgs> = {}>(args?: Subset<T, User$TokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly isEmailVerified: FieldRef<"User", 'Boolean'>
    readonly height: FieldRef<"User", 'Float'>
    readonly weight: FieldRef<"User", 'Float'>
    readonly age: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.CommunityUser
   */
  export type User$CommunityUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityUser
     */
    select?: CommunityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityUserInclude<ExtArgs> | null
    where?: CommunityUserWhereInput
    orderBy?: CommunityUserOrderByWithRelationInput | CommunityUserOrderByWithRelationInput[]
    cursor?: CommunityUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityUserScalarFieldEnum | CommunityUserScalarFieldEnum[]
  }


  /**
   * User.Token
   */
  export type User$TokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    cursor?: TokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model UserRoles
   */

  export type AggregateUserRoles = {
    _count: UserRolesCountAggregateOutputType | null
    _avg: UserRolesAvgAggregateOutputType | null
    _sum: UserRolesSumAggregateOutputType | null
    _min: UserRolesMinAggregateOutputType | null
    _max: UserRolesMaxAggregateOutputType | null
  }

  export type UserRolesAvgAggregateOutputType = {
    id: number | null
  }

  export type UserRolesSumAggregateOutputType = {
    id: number | null
  }

  export type UserRolesMinAggregateOutputType = {
    id: number | null
    role: string | null
  }

  export type UserRolesMaxAggregateOutputType = {
    id: number | null
    role: string | null
  }

  export type UserRolesCountAggregateOutputType = {
    id: number
    role: number
    _all: number
  }


  export type UserRolesAvgAggregateInputType = {
    id?: true
  }

  export type UserRolesSumAggregateInputType = {
    id?: true
  }

  export type UserRolesMinAggregateInputType = {
    id?: true
    role?: true
  }

  export type UserRolesMaxAggregateInputType = {
    id?: true
    role?: true
  }

  export type UserRolesCountAggregateInputType = {
    id?: true
    role?: true
    _all?: true
  }

  export type UserRolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to aggregate.
     */
    where?: UserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRolesOrderByWithRelationInput | UserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRolesMaxAggregateInputType
  }

  export type GetUserRolesAggregateType<T extends UserRolesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRoles[P]>
      : GetScalarType<T[P], AggregateUserRoles[P]>
  }




  export type UserRolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRolesWhereInput
    orderBy?: UserRolesOrderByWithAggregationInput | UserRolesOrderByWithAggregationInput[]
    by: UserRolesScalarFieldEnum[] | UserRolesScalarFieldEnum
    having?: UserRolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRolesCountAggregateInputType | true
    _avg?: UserRolesAvgAggregateInputType
    _sum?: UserRolesSumAggregateInputType
    _min?: UserRolesMinAggregateInputType
    _max?: UserRolesMaxAggregateInputType
  }

  export type UserRolesGroupByOutputType = {
    id: number
    role: string | null
    _count: UserRolesCountAggregateOutputType | null
    _avg: UserRolesAvgAggregateOutputType | null
    _sum: UserRolesSumAggregateOutputType | null
    _min: UserRolesMinAggregateOutputType | null
    _max: UserRolesMaxAggregateOutputType | null
  }

  type GetUserRolesGroupByPayload<T extends UserRolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRolesGroupByOutputType[P]>
            : GetScalarType<T[P], UserRolesGroupByOutputType[P]>
        }
      >
    >


  export type UserRolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    CommunityUser?: boolean | UserRoles$CommunityUserArgs<ExtArgs>
    _count?: boolean | UserRolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRoles"]>

  export type UserRolesSelectScalar = {
    id?: boolean
    role?: boolean
  }

  export type UserRolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CommunityUser?: boolean | UserRoles$CommunityUserArgs<ExtArgs>
    _count?: boolean | UserRolesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserRolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRoles"
    objects: {
      CommunityUser: Prisma.$CommunityUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      role: string | null
    }, ExtArgs["result"]["userRoles"]>
    composites: {}
  }


  type UserRolesGetPayload<S extends boolean | null | undefined | UserRolesDefaultArgs> = $Result.GetResult<Prisma.$UserRolesPayload, S>

  type UserRolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRolesFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: UserRolesCountAggregateInputType | true
    }

  export interface UserRolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRoles'], meta: { name: 'UserRoles' } }
    /**
     * Find zero or one UserRoles that matches the filter.
     * @param {UserRolesFindUniqueArgs} args - Arguments to find a UserRoles
     * @example
     * // Get one UserRoles
     * const userRoles = await prisma.userRoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserRolesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserRolesFindUniqueArgs<ExtArgs>>
    ): Prisma__UserRolesClient<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserRoles that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserRolesFindUniqueOrThrowArgs} args - Arguments to find a UserRoles
     * @example
     * // Get one UserRoles
     * const userRoles = await prisma.userRoles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserRolesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserRolesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserRolesClient<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesFindFirstArgs} args - Arguments to find a UserRoles
     * @example
     * // Get one UserRoles
     * const userRoles = await prisma.userRoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserRolesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserRolesFindFirstArgs<ExtArgs>>
    ): Prisma__UserRolesClient<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserRoles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesFindFirstOrThrowArgs} args - Arguments to find a UserRoles
     * @example
     * // Get one UserRoles
     * const userRoles = await prisma.userRoles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserRolesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserRolesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserRolesClient<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRoles.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRoles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRolesWithIdOnly = await prisma.userRoles.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserRolesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserRolesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserRoles.
     * @param {UserRolesCreateArgs} args - Arguments to create a UserRoles.
     * @example
     * // Create one UserRoles
     * const UserRoles = await prisma.userRoles.create({
     *   data: {
     *     // ... data to create a UserRoles
     *   }
     * })
     * 
    **/
    create<T extends UserRolesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserRolesCreateArgs<ExtArgs>>
    ): Prisma__UserRolesClient<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserRoles.
     *     @param {UserRolesCreateManyArgs} args - Arguments to create many UserRoles.
     *     @example
     *     // Create many UserRoles
     *     const userRoles = await prisma.userRoles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserRolesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserRolesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserRoles.
     * @param {UserRolesDeleteArgs} args - Arguments to delete one UserRoles.
     * @example
     * // Delete one UserRoles
     * const UserRoles = await prisma.userRoles.delete({
     *   where: {
     *     // ... filter to delete one UserRoles
     *   }
     * })
     * 
    **/
    delete<T extends UserRolesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserRolesDeleteArgs<ExtArgs>>
    ): Prisma__UserRolesClient<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserRoles.
     * @param {UserRolesUpdateArgs} args - Arguments to update one UserRoles.
     * @example
     * // Update one UserRoles
     * const userRoles = await prisma.userRoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserRolesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserRolesUpdateArgs<ExtArgs>>
    ): Prisma__UserRolesClient<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRolesDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserRolesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserRolesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRoles = await prisma.userRoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserRolesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserRolesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRoles.
     * @param {UserRolesUpsertArgs} args - Arguments to update or create a UserRoles.
     * @example
     * // Update or create a UserRoles
     * const userRoles = await prisma.userRoles.upsert({
     *   create: {
     *     // ... data to create a UserRoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRoles we want to update
     *   }
     * })
    **/
    upsert<T extends UserRolesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserRolesUpsertArgs<ExtArgs>>
    ): Prisma__UserRolesClient<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRoles.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRolesCountArgs>(
      args?: Subset<T, UserRolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRolesAggregateArgs>(args: Subset<T, UserRolesAggregateArgs>): Prisma.PrismaPromise<GetUserRolesAggregateType<T>>

    /**
     * Group by UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRolesGroupByArgs['orderBy'] }
        : { orderBy?: UserRolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRoles model
   */
  readonly fields: UserRolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    CommunityUser<T extends UserRoles$CommunityUserArgs<ExtArgs> = {}>(args?: Subset<T, UserRoles$CommunityUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserRoles model
   */ 
  interface UserRolesFieldRefs {
    readonly id: FieldRef<"UserRoles", 'Int'>
    readonly role: FieldRef<"UserRoles", 'String'>
  }
    

  // Custom InputTypes

  /**
   * UserRoles findUnique
   */
  export type UserRolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where: UserRolesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * UserRoles findUniqueOrThrow
   */
  export type UserRolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where: UserRolesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * UserRoles findFirst
   */
  export type UserRolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRolesOrderByWithRelationInput | UserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRolesScalarFieldEnum | UserRolesScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * UserRoles findFirstOrThrow
   */
  export type UserRolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRolesOrderByWithRelationInput | UserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRolesScalarFieldEnum | UserRolesScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * UserRoles findMany
   */
  export type UserRolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRolesOrderByWithRelationInput | UserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRolesScalarFieldEnum | UserRolesScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * UserRoles create
   */
  export type UserRolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRoles.
     */
    data: XOR<UserRolesCreateInput, UserRolesUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * UserRoles createMany
   */
  export type UserRolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRolesCreateManyInput | UserRolesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserRoles update
   */
  export type UserRolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRoles.
     */
    data: XOR<UserRolesUpdateInput, UserRolesUncheckedUpdateInput>
    /**
     * Choose, which UserRoles to update.
     */
    where: UserRolesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * UserRoles updateMany
   */
  export type UserRolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRolesUpdateManyMutationInput, UserRolesUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRolesWhereInput
  }


  /**
   * UserRoles upsert
   */
  export type UserRolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRoles to update in case it exists.
     */
    where: UserRolesWhereUniqueInput
    /**
     * In case the UserRoles found by the `where` argument doesn't exist, create a new UserRoles with this data.
     */
    create: XOR<UserRolesCreateInput, UserRolesUncheckedCreateInput>
    /**
     * In case the UserRoles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRolesUpdateInput, UserRolesUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * UserRoles delete
   */
  export type UserRolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude<ExtArgs> | null
    /**
     * Filter which UserRoles to delete.
     */
    where: UserRolesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * UserRoles deleteMany
   */
  export type UserRolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRolesWhereInput
  }


  /**
   * UserRoles.CommunityUser
   */
  export type UserRoles$CommunityUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityUser
     */
    select?: CommunityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityUserInclude<ExtArgs> | null
    where?: CommunityUserWhereInput
    orderBy?: CommunityUserOrderByWithRelationInput | CommunityUserOrderByWithRelationInput[]
    cursor?: CommunityUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityUserScalarFieldEnum | CommunityUserScalarFieldEnum[]
  }


  /**
   * UserRoles without action
   */
  export type UserRolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude<ExtArgs> | null
  }



  /**
   * Model Email
   */

  export type AggregateEmail = {
    _count: EmailCountAggregateOutputType | null
    _avg: EmailAvgAggregateOutputType | null
    _sum: EmailSumAggregateOutputType | null
    _min: EmailMinAggregateOutputType | null
    _max: EmailMaxAggregateOutputType | null
  }

  export type EmailAvgAggregateOutputType = {
    id: number | null
    for: number | null
  }

  export type EmailSumAggregateOutputType = {
    id: number | null
    for: number | null
  }

  export type EmailMinAggregateOutputType = {
    id: number | null
    email: string | null
    verificationCode: string | null
    messageId: string | null
    for: number | null
    createdAt: Date | null
  }

  export type EmailMaxAggregateOutputType = {
    id: number | null
    email: string | null
    verificationCode: string | null
    messageId: string | null
    for: number | null
    createdAt: Date | null
  }

  export type EmailCountAggregateOutputType = {
    id: number
    email: number
    verificationCode: number
    messageId: number
    for: number
    createdAt: number
    _all: number
  }


  export type EmailAvgAggregateInputType = {
    id?: true
    for?: true
  }

  export type EmailSumAggregateInputType = {
    id?: true
    for?: true
  }

  export type EmailMinAggregateInputType = {
    id?: true
    email?: true
    verificationCode?: true
    messageId?: true
    for?: true
    createdAt?: true
  }

  export type EmailMaxAggregateInputType = {
    id?: true
    email?: true
    verificationCode?: true
    messageId?: true
    for?: true
    createdAt?: true
  }

  export type EmailCountAggregateInputType = {
    id?: true
    email?: true
    verificationCode?: true
    messageId?: true
    for?: true
    createdAt?: true
    _all?: true
  }

  export type EmailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Email to aggregate.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Emails
    **/
    _count?: true | EmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailMaxAggregateInputType
  }

  export type GetEmailAggregateType<T extends EmailAggregateArgs> = {
        [P in keyof T & keyof AggregateEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmail[P]>
      : GetScalarType<T[P], AggregateEmail[P]>
  }




  export type EmailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailWhereInput
    orderBy?: EmailOrderByWithAggregationInput | EmailOrderByWithAggregationInput[]
    by: EmailScalarFieldEnum[] | EmailScalarFieldEnum
    having?: EmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailCountAggregateInputType | true
    _avg?: EmailAvgAggregateInputType
    _sum?: EmailSumAggregateInputType
    _min?: EmailMinAggregateInputType
    _max?: EmailMaxAggregateInputType
  }

  export type EmailGroupByOutputType = {
    id: number
    email: string | null
    verificationCode: string | null
    messageId: string | null
    for: number | null
    createdAt: Date | null
    _count: EmailCountAggregateOutputType | null
    _avg: EmailAvgAggregateOutputType | null
    _sum: EmailSumAggregateOutputType | null
    _min: EmailMinAggregateOutputType | null
    _max: EmailMaxAggregateOutputType | null
  }

  type GetEmailGroupByPayload<T extends EmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailGroupByOutputType[P]>
            : GetScalarType<T[P], EmailGroupByOutputType[P]>
        }
      >
    >


  export type EmailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    verificationCode?: boolean
    messageId?: boolean
    for?: boolean
    createdAt?: boolean
    EmailFor?: boolean | Email$EmailForArgs<ExtArgs>
  }, ExtArgs["result"]["email"]>

  export type EmailSelectScalar = {
    id?: boolean
    email?: boolean
    verificationCode?: boolean
    messageId?: boolean
    for?: boolean
    createdAt?: boolean
  }

  export type EmailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmailFor?: boolean | Email$EmailForArgs<ExtArgs>
  }


  export type $EmailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Email"
    objects: {
      EmailFor: Prisma.$EmailForPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string | null
      verificationCode: string | null
      messageId: string | null
      for: number | null
      createdAt: Date | null
    }, ExtArgs["result"]["email"]>
    composites: {}
  }


  type EmailGetPayload<S extends boolean | null | undefined | EmailDefaultArgs> = $Result.GetResult<Prisma.$EmailPayload, S>

  type EmailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: EmailCountAggregateInputType | true
    }

  export interface EmailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Email'], meta: { name: 'Email' } }
    /**
     * Find zero or one Email that matches the filter.
     * @param {EmailFindUniqueArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Email that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailFindUniqueOrThrowArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Email that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindFirstArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailFindFirstArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Email that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindFirstOrThrowArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Emails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emails
     * const emails = await prisma.email.findMany()
     * 
     * // Get first 10 Emails
     * const emails = await prisma.email.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailWithIdOnly = await prisma.email.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Email.
     * @param {EmailCreateArgs} args - Arguments to create a Email.
     * @example
     * // Create one Email
     * const Email = await prisma.email.create({
     *   data: {
     *     // ... data to create a Email
     *   }
     * })
     * 
    **/
    create<T extends EmailCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailCreateArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Emails.
     *     @param {EmailCreateManyArgs} args - Arguments to create many Emails.
     *     @example
     *     // Create many Emails
     *     const email = await prisma.email.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Email.
     * @param {EmailDeleteArgs} args - Arguments to delete one Email.
     * @example
     * // Delete one Email
     * const Email = await prisma.email.delete({
     *   where: {
     *     // ... filter to delete one Email
     *   }
     * })
     * 
    **/
    delete<T extends EmailDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailDeleteArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Email.
     * @param {EmailUpdateArgs} args - Arguments to update one Email.
     * @example
     * // Update one Email
     * const email = await prisma.email.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailUpdateArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Emails.
     * @param {EmailDeleteManyArgs} args - Arguments to filter Emails to delete.
     * @example
     * // Delete a few Emails
     * const { count } = await prisma.email.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emails
     * const email = await prisma.email.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Email.
     * @param {EmailUpsertArgs} args - Arguments to update or create a Email.
     * @example
     * // Update or create a Email
     * const email = await prisma.email.upsert({
     *   create: {
     *     // ... data to create a Email
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email we want to update
     *   }
     * })
    **/
    upsert<T extends EmailUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailUpsertArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCountArgs} args - Arguments to filter Emails to count.
     * @example
     * // Count the number of Emails
     * const count = await prisma.email.count({
     *   where: {
     *     // ... the filter for the Emails we want to count
     *   }
     * })
    **/
    count<T extends EmailCountArgs>(
      args?: Subset<T, EmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAggregateArgs>(args: Subset<T, EmailAggregateArgs>): Prisma.PrismaPromise<GetEmailAggregateType<T>>

    /**
     * Group by Email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailGroupByArgs['orderBy'] }
        : { orderBy?: EmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Email model
   */
  readonly fields: EmailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Email.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    EmailFor<T extends Email$EmailForArgs<ExtArgs> = {}>(args?: Subset<T, Email$EmailForArgs<ExtArgs>>): Prisma__EmailForClient<$Result.GetResult<Prisma.$EmailForPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Email model
   */ 
  interface EmailFieldRefs {
    readonly id: FieldRef<"Email", 'Int'>
    readonly email: FieldRef<"Email", 'String'>
    readonly verificationCode: FieldRef<"Email", 'String'>
    readonly messageId: FieldRef<"Email", 'String'>
    readonly for: FieldRef<"Email", 'Int'>
    readonly createdAt: FieldRef<"Email", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Email findUnique
   */
  export type EmailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where: EmailWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Email findUniqueOrThrow
   */
  export type EmailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where: EmailWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Email findFirst
   */
  export type EmailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emails.
     */
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Email findFirstOrThrow
   */
  export type EmailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emails.
     */
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Email findMany
   */
  export type EmailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Emails to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Email create
   */
  export type EmailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The data needed to create a Email.
     */
    data?: XOR<EmailCreateInput, EmailUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Email createMany
   */
  export type EmailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Emails.
     */
    data: EmailCreateManyInput | EmailCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Email update
   */
  export type EmailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The data needed to update a Email.
     */
    data: XOR<EmailUpdateInput, EmailUncheckedUpdateInput>
    /**
     * Choose, which Email to update.
     */
    where: EmailWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Email updateMany
   */
  export type EmailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Emails.
     */
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyInput>
    /**
     * Filter which Emails to update
     */
    where?: EmailWhereInput
  }


  /**
   * Email upsert
   */
  export type EmailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The filter to search for the Email to update in case it exists.
     */
    where: EmailWhereUniqueInput
    /**
     * In case the Email found by the `where` argument doesn't exist, create a new Email with this data.
     */
    create: XOR<EmailCreateInput, EmailUncheckedCreateInput>
    /**
     * In case the Email was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailUpdateInput, EmailUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Email delete
   */
  export type EmailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter which Email to delete.
     */
    where: EmailWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Email deleteMany
   */
  export type EmailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emails to delete
     */
    where?: EmailWhereInput
  }


  /**
   * Email.EmailFor
   */
  export type Email$EmailForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailFor
     */
    select?: EmailForSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailForInclude<ExtArgs> | null
    where?: EmailForWhereInput
  }


  /**
   * Email without action
   */
  export type EmailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
  }



  /**
   * Model EmailFor
   */

  export type AggregateEmailFor = {
    _count: EmailForCountAggregateOutputType | null
    _avg: EmailForAvgAggregateOutputType | null
    _sum: EmailForSumAggregateOutputType | null
    _min: EmailForMinAggregateOutputType | null
    _max: EmailForMaxAggregateOutputType | null
  }

  export type EmailForAvgAggregateOutputType = {
    id: number | null
  }

  export type EmailForSumAggregateOutputType = {
    id: number | null
  }

  export type EmailForMinAggregateOutputType = {
    id: number | null
    for: string | null
  }

  export type EmailForMaxAggregateOutputType = {
    id: number | null
    for: string | null
  }

  export type EmailForCountAggregateOutputType = {
    id: number
    for: number
    _all: number
  }


  export type EmailForAvgAggregateInputType = {
    id?: true
  }

  export type EmailForSumAggregateInputType = {
    id?: true
  }

  export type EmailForMinAggregateInputType = {
    id?: true
    for?: true
  }

  export type EmailForMaxAggregateInputType = {
    id?: true
    for?: true
  }

  export type EmailForCountAggregateInputType = {
    id?: true
    for?: true
    _all?: true
  }

  export type EmailForAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailFor to aggregate.
     */
    where?: EmailForWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailFors to fetch.
     */
    orderBy?: EmailForOrderByWithRelationInput | EmailForOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailForWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailFors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailFors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailFors
    **/
    _count?: true | EmailForCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailForAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailForSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailForMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailForMaxAggregateInputType
  }

  export type GetEmailForAggregateType<T extends EmailForAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailFor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailFor[P]>
      : GetScalarType<T[P], AggregateEmailFor[P]>
  }




  export type EmailForGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailForWhereInput
    orderBy?: EmailForOrderByWithAggregationInput | EmailForOrderByWithAggregationInput[]
    by: EmailForScalarFieldEnum[] | EmailForScalarFieldEnum
    having?: EmailForScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailForCountAggregateInputType | true
    _avg?: EmailForAvgAggregateInputType
    _sum?: EmailForSumAggregateInputType
    _min?: EmailForMinAggregateInputType
    _max?: EmailForMaxAggregateInputType
  }

  export type EmailForGroupByOutputType = {
    id: number
    for: string | null
    _count: EmailForCountAggregateOutputType | null
    _avg: EmailForAvgAggregateOutputType | null
    _sum: EmailForSumAggregateOutputType | null
    _min: EmailForMinAggregateOutputType | null
    _max: EmailForMaxAggregateOutputType | null
  }

  type GetEmailForGroupByPayload<T extends EmailForGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailForGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailForGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailForGroupByOutputType[P]>
            : GetScalarType<T[P], EmailForGroupByOutputType[P]>
        }
      >
    >


  export type EmailForSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    for?: boolean
    Email?: boolean | EmailFor$EmailArgs<ExtArgs>
    _count?: boolean | EmailForCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailFor"]>

  export type EmailForSelectScalar = {
    id?: boolean
    for?: boolean
  }

  export type EmailForInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Email?: boolean | EmailFor$EmailArgs<ExtArgs>
    _count?: boolean | EmailForCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EmailForPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailFor"
    objects: {
      Email: Prisma.$EmailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      for: string | null
    }, ExtArgs["result"]["emailFor"]>
    composites: {}
  }


  type EmailForGetPayload<S extends boolean | null | undefined | EmailForDefaultArgs> = $Result.GetResult<Prisma.$EmailForPayload, S>

  type EmailForCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailForFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: EmailForCountAggregateInputType | true
    }

  export interface EmailForDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailFor'], meta: { name: 'EmailFor' } }
    /**
     * Find zero or one EmailFor that matches the filter.
     * @param {EmailForFindUniqueArgs} args - Arguments to find a EmailFor
     * @example
     * // Get one EmailFor
     * const emailFor = await prisma.emailFor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailForFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailForFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailForClient<$Result.GetResult<Prisma.$EmailForPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmailFor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailForFindUniqueOrThrowArgs} args - Arguments to find a EmailFor
     * @example
     * // Get one EmailFor
     * const emailFor = await prisma.emailFor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailForFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailForFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailForClient<$Result.GetResult<Prisma.$EmailForPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmailFor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailForFindFirstArgs} args - Arguments to find a EmailFor
     * @example
     * // Get one EmailFor
     * const emailFor = await prisma.emailFor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailForFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailForFindFirstArgs<ExtArgs>>
    ): Prisma__EmailForClient<$Result.GetResult<Prisma.$EmailForPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmailFor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailForFindFirstOrThrowArgs} args - Arguments to find a EmailFor
     * @example
     * // Get one EmailFor
     * const emailFor = await prisma.emailFor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailForFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailForFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailForClient<$Result.GetResult<Prisma.$EmailForPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmailFors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailForFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailFors
     * const emailFors = await prisma.emailFor.findMany()
     * 
     * // Get first 10 EmailFors
     * const emailFors = await prisma.emailFor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailForWithIdOnly = await prisma.emailFor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailForFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailForFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailForPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmailFor.
     * @param {EmailForCreateArgs} args - Arguments to create a EmailFor.
     * @example
     * // Create one EmailFor
     * const EmailFor = await prisma.emailFor.create({
     *   data: {
     *     // ... data to create a EmailFor
     *   }
     * })
     * 
    **/
    create<T extends EmailForCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailForCreateArgs<ExtArgs>>
    ): Prisma__EmailForClient<$Result.GetResult<Prisma.$EmailForPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmailFors.
     *     @param {EmailForCreateManyArgs} args - Arguments to create many EmailFors.
     *     @example
     *     // Create many EmailFors
     *     const emailFor = await prisma.emailFor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailForCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailForCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailFor.
     * @param {EmailForDeleteArgs} args - Arguments to delete one EmailFor.
     * @example
     * // Delete one EmailFor
     * const EmailFor = await prisma.emailFor.delete({
     *   where: {
     *     // ... filter to delete one EmailFor
     *   }
     * })
     * 
    **/
    delete<T extends EmailForDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailForDeleteArgs<ExtArgs>>
    ): Prisma__EmailForClient<$Result.GetResult<Prisma.$EmailForPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmailFor.
     * @param {EmailForUpdateArgs} args - Arguments to update one EmailFor.
     * @example
     * // Update one EmailFor
     * const emailFor = await prisma.emailFor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailForUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailForUpdateArgs<ExtArgs>>
    ): Prisma__EmailForClient<$Result.GetResult<Prisma.$EmailForPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmailFors.
     * @param {EmailForDeleteManyArgs} args - Arguments to filter EmailFors to delete.
     * @example
     * // Delete a few EmailFors
     * const { count } = await prisma.emailFor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailForDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailForDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailFors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailForUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailFors
     * const emailFor = await prisma.emailFor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailForUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailForUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailFor.
     * @param {EmailForUpsertArgs} args - Arguments to update or create a EmailFor.
     * @example
     * // Update or create a EmailFor
     * const emailFor = await prisma.emailFor.upsert({
     *   create: {
     *     // ... data to create a EmailFor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailFor we want to update
     *   }
     * })
    **/
    upsert<T extends EmailForUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailForUpsertArgs<ExtArgs>>
    ): Prisma__EmailForClient<$Result.GetResult<Prisma.$EmailForPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmailFors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailForCountArgs} args - Arguments to filter EmailFors to count.
     * @example
     * // Count the number of EmailFors
     * const count = await prisma.emailFor.count({
     *   where: {
     *     // ... the filter for the EmailFors we want to count
     *   }
     * })
    **/
    count<T extends EmailForCountArgs>(
      args?: Subset<T, EmailForCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailForCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailFor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailForAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailForAggregateArgs>(args: Subset<T, EmailForAggregateArgs>): Prisma.PrismaPromise<GetEmailForAggregateType<T>>

    /**
     * Group by EmailFor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailForGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailForGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailForGroupByArgs['orderBy'] }
        : { orderBy?: EmailForGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailForGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailForGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailFor model
   */
  readonly fields: EmailForFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailFor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailForClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Email<T extends EmailFor$EmailArgs<ExtArgs> = {}>(args?: Subset<T, EmailFor$EmailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmailFor model
   */ 
  interface EmailForFieldRefs {
    readonly id: FieldRef<"EmailFor", 'Int'>
    readonly for: FieldRef<"EmailFor", 'String'>
  }
    

  // Custom InputTypes

  /**
   * EmailFor findUnique
   */
  export type EmailForFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailFor
     */
    select?: EmailForSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailForInclude<ExtArgs> | null
    /**
     * Filter, which EmailFor to fetch.
     */
    where: EmailForWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * EmailFor findUniqueOrThrow
   */
  export type EmailForFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailFor
     */
    select?: EmailForSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailForInclude<ExtArgs> | null
    /**
     * Filter, which EmailFor to fetch.
     */
    where: EmailForWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * EmailFor findFirst
   */
  export type EmailForFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailFor
     */
    select?: EmailForSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailForInclude<ExtArgs> | null
    /**
     * Filter, which EmailFor to fetch.
     */
    where?: EmailForWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailFors to fetch.
     */
    orderBy?: EmailForOrderByWithRelationInput | EmailForOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailFors.
     */
    cursor?: EmailForWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailFors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailFors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailFors.
     */
    distinct?: EmailForScalarFieldEnum | EmailForScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * EmailFor findFirstOrThrow
   */
  export type EmailForFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailFor
     */
    select?: EmailForSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailForInclude<ExtArgs> | null
    /**
     * Filter, which EmailFor to fetch.
     */
    where?: EmailForWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailFors to fetch.
     */
    orderBy?: EmailForOrderByWithRelationInput | EmailForOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailFors.
     */
    cursor?: EmailForWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailFors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailFors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailFors.
     */
    distinct?: EmailForScalarFieldEnum | EmailForScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * EmailFor findMany
   */
  export type EmailForFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailFor
     */
    select?: EmailForSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailForInclude<ExtArgs> | null
    /**
     * Filter, which EmailFors to fetch.
     */
    where?: EmailForWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailFors to fetch.
     */
    orderBy?: EmailForOrderByWithRelationInput | EmailForOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailFors.
     */
    cursor?: EmailForWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailFors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailFors.
     */
    skip?: number
    distinct?: EmailForScalarFieldEnum | EmailForScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * EmailFor create
   */
  export type EmailForCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailFor
     */
    select?: EmailForSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailForInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailFor.
     */
    data: XOR<EmailForCreateInput, EmailForUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * EmailFor createMany
   */
  export type EmailForCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailFors.
     */
    data: EmailForCreateManyInput | EmailForCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmailFor update
   */
  export type EmailForUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailFor
     */
    select?: EmailForSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailForInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailFor.
     */
    data: XOR<EmailForUpdateInput, EmailForUncheckedUpdateInput>
    /**
     * Choose, which EmailFor to update.
     */
    where: EmailForWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * EmailFor updateMany
   */
  export type EmailForUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailFors.
     */
    data: XOR<EmailForUpdateManyMutationInput, EmailForUncheckedUpdateManyInput>
    /**
     * Filter which EmailFors to update
     */
    where?: EmailForWhereInput
  }


  /**
   * EmailFor upsert
   */
  export type EmailForUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailFor
     */
    select?: EmailForSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailForInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailFor to update in case it exists.
     */
    where: EmailForWhereUniqueInput
    /**
     * In case the EmailFor found by the `where` argument doesn't exist, create a new EmailFor with this data.
     */
    create: XOR<EmailForCreateInput, EmailForUncheckedCreateInput>
    /**
     * In case the EmailFor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailForUpdateInput, EmailForUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * EmailFor delete
   */
  export type EmailForDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailFor
     */
    select?: EmailForSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailForInclude<ExtArgs> | null
    /**
     * Filter which EmailFor to delete.
     */
    where: EmailForWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * EmailFor deleteMany
   */
  export type EmailForDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailFors to delete
     */
    where?: EmailForWhereInput
  }


  /**
   * EmailFor.Email
   */
  export type EmailFor$EmailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    where?: EmailWhereInput
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    cursor?: EmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }


  /**
   * EmailFor without action
   */
  export type EmailForDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailFor
     */
    select?: EmailForSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailForInclude<ExtArgs> | null
  }



  /**
   * Model Leaderboard
   */

  export type AggregateLeaderboard = {
    _count: LeaderboardCountAggregateOutputType | null
    _avg: LeaderboardAvgAggregateOutputType | null
    _sum: LeaderboardSumAggregateOutputType | null
    _min: LeaderboardMinAggregateOutputType | null
    _max: LeaderboardMaxAggregateOutputType | null
  }

  export type LeaderboardAvgAggregateOutputType = {
    id: number | null
    community: number | null
  }

  export type LeaderboardSumAggregateOutputType = {
    id: number | null
    community: number | null
  }

  export type LeaderboardMinAggregateOutputType = {
    id: number | null
    community: number | null
  }

  export type LeaderboardMaxAggregateOutputType = {
    id: number | null
    community: number | null
  }

  export type LeaderboardCountAggregateOutputType = {
    id: number
    community: number
    _all: number
  }


  export type LeaderboardAvgAggregateInputType = {
    id?: true
    community?: true
  }

  export type LeaderboardSumAggregateInputType = {
    id?: true
    community?: true
  }

  export type LeaderboardMinAggregateInputType = {
    id?: true
    community?: true
  }

  export type LeaderboardMaxAggregateInputType = {
    id?: true
    community?: true
  }

  export type LeaderboardCountAggregateInputType = {
    id?: true
    community?: true
    _all?: true
  }

  export type LeaderboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaderboard to aggregate.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leaderboards
    **/
    _count?: true | LeaderboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaderboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaderboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaderboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaderboardMaxAggregateInputType
  }

  export type GetLeaderboardAggregateType<T extends LeaderboardAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaderboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaderboard[P]>
      : GetScalarType<T[P], AggregateLeaderboard[P]>
  }




  export type LeaderboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardWhereInput
    orderBy?: LeaderboardOrderByWithAggregationInput | LeaderboardOrderByWithAggregationInput[]
    by: LeaderboardScalarFieldEnum[] | LeaderboardScalarFieldEnum
    having?: LeaderboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaderboardCountAggregateInputType | true
    _avg?: LeaderboardAvgAggregateInputType
    _sum?: LeaderboardSumAggregateInputType
    _min?: LeaderboardMinAggregateInputType
    _max?: LeaderboardMaxAggregateInputType
  }

  export type LeaderboardGroupByOutputType = {
    id: number
    community: number
    _count: LeaderboardCountAggregateOutputType | null
    _avg: LeaderboardAvgAggregateOutputType | null
    _sum: LeaderboardSumAggregateOutputType | null
    _min: LeaderboardMinAggregateOutputType | null
    _max: LeaderboardMaxAggregateOutputType | null
  }

  type GetLeaderboardGroupByPayload<T extends LeaderboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaderboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaderboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaderboardGroupByOutputType[P]>
            : GetScalarType<T[P], LeaderboardGroupByOutputType[P]>
        }
      >
    >


  export type LeaderboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    community?: boolean
    LeaderboardSubmission?: boolean | Leaderboard$LeaderboardSubmissionArgs<ExtArgs>
    _count?: boolean | LeaderboardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboard"]>

  export type LeaderboardSelectScalar = {
    id?: boolean
    community?: boolean
  }

  export type LeaderboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LeaderboardSubmission?: boolean | Leaderboard$LeaderboardSubmissionArgs<ExtArgs>
    _count?: boolean | LeaderboardCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $LeaderboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leaderboard"
    objects: {
      LeaderboardSubmission: Prisma.$LeaderboardSubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      community: number
    }, ExtArgs["result"]["leaderboard"]>
    composites: {}
  }


  type LeaderboardGetPayload<S extends boolean | null | undefined | LeaderboardDefaultArgs> = $Result.GetResult<Prisma.$LeaderboardPayload, S>

  type LeaderboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaderboardFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: LeaderboardCountAggregateInputType | true
    }

  export interface LeaderboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leaderboard'], meta: { name: 'Leaderboard' } }
    /**
     * Find zero or one Leaderboard that matches the filter.
     * @param {LeaderboardFindUniqueArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LeaderboardFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardFindUniqueArgs<ExtArgs>>
    ): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Leaderboard that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LeaderboardFindUniqueOrThrowArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LeaderboardFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Leaderboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardFindFirstArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LeaderboardFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardFindFirstArgs<ExtArgs>>
    ): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Leaderboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardFindFirstOrThrowArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LeaderboardFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Leaderboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leaderboards
     * const leaderboards = await prisma.leaderboard.findMany()
     * 
     * // Get first 10 Leaderboards
     * const leaderboards = await prisma.leaderboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaderboardWithIdOnly = await prisma.leaderboard.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LeaderboardFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Leaderboard.
     * @param {LeaderboardCreateArgs} args - Arguments to create a Leaderboard.
     * @example
     * // Create one Leaderboard
     * const Leaderboard = await prisma.leaderboard.create({
     *   data: {
     *     // ... data to create a Leaderboard
     *   }
     * })
     * 
    **/
    create<T extends LeaderboardCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardCreateArgs<ExtArgs>>
    ): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Leaderboards.
     *     @param {LeaderboardCreateManyArgs} args - Arguments to create many Leaderboards.
     *     @example
     *     // Create many Leaderboards
     *     const leaderboard = await prisma.leaderboard.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LeaderboardCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Leaderboard.
     * @param {LeaderboardDeleteArgs} args - Arguments to delete one Leaderboard.
     * @example
     * // Delete one Leaderboard
     * const Leaderboard = await prisma.leaderboard.delete({
     *   where: {
     *     // ... filter to delete one Leaderboard
     *   }
     * })
     * 
    **/
    delete<T extends LeaderboardDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardDeleteArgs<ExtArgs>>
    ): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Leaderboard.
     * @param {LeaderboardUpdateArgs} args - Arguments to update one Leaderboard.
     * @example
     * // Update one Leaderboard
     * const leaderboard = await prisma.leaderboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LeaderboardUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardUpdateArgs<ExtArgs>>
    ): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Leaderboards.
     * @param {LeaderboardDeleteManyArgs} args - Arguments to filter Leaderboards to delete.
     * @example
     * // Delete a few Leaderboards
     * const { count } = await prisma.leaderboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LeaderboardDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leaderboards
     * const leaderboard = await prisma.leaderboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LeaderboardUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Leaderboard.
     * @param {LeaderboardUpsertArgs} args - Arguments to update or create a Leaderboard.
     * @example
     * // Update or create a Leaderboard
     * const leaderboard = await prisma.leaderboard.upsert({
     *   create: {
     *     // ... data to create a Leaderboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leaderboard we want to update
     *   }
     * })
    **/
    upsert<T extends LeaderboardUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardUpsertArgs<ExtArgs>>
    ): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Leaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardCountArgs} args - Arguments to filter Leaderboards to count.
     * @example
     * // Count the number of Leaderboards
     * const count = await prisma.leaderboard.count({
     *   where: {
     *     // ... the filter for the Leaderboards we want to count
     *   }
     * })
    **/
    count<T extends LeaderboardCountArgs>(
      args?: Subset<T, LeaderboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaderboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaderboardAggregateArgs>(args: Subset<T, LeaderboardAggregateArgs>): Prisma.PrismaPromise<GetLeaderboardAggregateType<T>>

    /**
     * Group by Leaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaderboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaderboardGroupByArgs['orderBy'] }
        : { orderBy?: LeaderboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaderboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaderboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leaderboard model
   */
  readonly fields: LeaderboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leaderboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaderboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    LeaderboardSubmission<T extends Leaderboard$LeaderboardSubmissionArgs<ExtArgs> = {}>(args?: Subset<T, Leaderboard$LeaderboardSubmissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardSubmissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Leaderboard model
   */ 
  interface LeaderboardFieldRefs {
    readonly id: FieldRef<"Leaderboard", 'Int'>
    readonly community: FieldRef<"Leaderboard", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Leaderboard findUnique
   */
  export type LeaderboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where: LeaderboardWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Leaderboard findUniqueOrThrow
   */
  export type LeaderboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where: LeaderboardWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Leaderboard findFirst
   */
  export type LeaderboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaderboards.
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaderboards.
     */
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Leaderboard findFirstOrThrow
   */
  export type LeaderboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaderboards.
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaderboards.
     */
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Leaderboard findMany
   */
  export type LeaderboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboards to fetch.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leaderboards.
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Leaderboard create
   */
  export type LeaderboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to create a Leaderboard.
     */
    data: XOR<LeaderboardCreateInput, LeaderboardUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Leaderboard createMany
   */
  export type LeaderboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leaderboards.
     */
    data: LeaderboardCreateManyInput | LeaderboardCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Leaderboard update
   */
  export type LeaderboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to update a Leaderboard.
     */
    data: XOR<LeaderboardUpdateInput, LeaderboardUncheckedUpdateInput>
    /**
     * Choose, which Leaderboard to update.
     */
    where: LeaderboardWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Leaderboard updateMany
   */
  export type LeaderboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leaderboards.
     */
    data: XOR<LeaderboardUpdateManyMutationInput, LeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which Leaderboards to update
     */
    where?: LeaderboardWhereInput
  }


  /**
   * Leaderboard upsert
   */
  export type LeaderboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * The filter to search for the Leaderboard to update in case it exists.
     */
    where: LeaderboardWhereUniqueInput
    /**
     * In case the Leaderboard found by the `where` argument doesn't exist, create a new Leaderboard with this data.
     */
    create: XOR<LeaderboardCreateInput, LeaderboardUncheckedCreateInput>
    /**
     * In case the Leaderboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaderboardUpdateInput, LeaderboardUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Leaderboard delete
   */
  export type LeaderboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter which Leaderboard to delete.
     */
    where: LeaderboardWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * Leaderboard deleteMany
   */
  export type LeaderboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaderboards to delete
     */
    where?: LeaderboardWhereInput
  }


  /**
   * Leaderboard.LeaderboardSubmission
   */
  export type Leaderboard$LeaderboardSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmission
     */
    select?: LeaderboardSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionInclude<ExtArgs> | null
    where?: LeaderboardSubmissionWhereInput
    orderBy?: LeaderboardSubmissionOrderByWithRelationInput | LeaderboardSubmissionOrderByWithRelationInput[]
    cursor?: LeaderboardSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaderboardSubmissionScalarFieldEnum | LeaderboardSubmissionScalarFieldEnum[]
  }


  /**
   * Leaderboard without action
   */
  export type LeaderboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
  }



  /**
   * Model LeaderboardSubmission
   */

  export type AggregateLeaderboardSubmission = {
    _count: LeaderboardSubmissionCountAggregateOutputType | null
    _avg: LeaderboardSubmissionAvgAggregateOutputType | null
    _sum: LeaderboardSubmissionSumAggregateOutputType | null
    _min: LeaderboardSubmissionMinAggregateOutputType | null
    _max: LeaderboardSubmissionMaxAggregateOutputType | null
  }

  export type LeaderboardSubmissionAvgAggregateOutputType = {
    id: number | null
    community: number | null
    verifiedBy: number | null
    type: number | null
    rank: number | null
    leaderboardId: number | null
  }

  export type LeaderboardSubmissionSumAggregateOutputType = {
    id: number | null
    community: number | null
    verifiedBy: number | null
    type: number | null
    rank: number | null
    leaderboardId: number | null
  }

  export type LeaderboardSubmissionMinAggregateOutputType = {
    id: number | null
    user: string | null
    community: number | null
    entryUrl: string | null
    verifiedBy: number | null
    weight: string | null
    type: number | null
    verifiedAt: Date | null
    rank: number | null
    leaderboardId: number | null
  }

  export type LeaderboardSubmissionMaxAggregateOutputType = {
    id: number | null
    user: string | null
    community: number | null
    entryUrl: string | null
    verifiedBy: number | null
    weight: string | null
    type: number | null
    verifiedAt: Date | null
    rank: number | null
    leaderboardId: number | null
  }

  export type LeaderboardSubmissionCountAggregateOutputType = {
    id: number
    user: number
    community: number
    entryUrl: number
    verifiedBy: number
    weight: number
    type: number
    verifiedAt: number
    rank: number
    leaderboardId: number
    _all: number
  }


  export type LeaderboardSubmissionAvgAggregateInputType = {
    id?: true
    community?: true
    verifiedBy?: true
    type?: true
    rank?: true
    leaderboardId?: true
  }

  export type LeaderboardSubmissionSumAggregateInputType = {
    id?: true
    community?: true
    verifiedBy?: true
    type?: true
    rank?: true
    leaderboardId?: true
  }

  export type LeaderboardSubmissionMinAggregateInputType = {
    id?: true
    user?: true
    community?: true
    entryUrl?: true
    verifiedBy?: true
    weight?: true
    type?: true
    verifiedAt?: true
    rank?: true
    leaderboardId?: true
  }

  export type LeaderboardSubmissionMaxAggregateInputType = {
    id?: true
    user?: true
    community?: true
    entryUrl?: true
    verifiedBy?: true
    weight?: true
    type?: true
    verifiedAt?: true
    rank?: true
    leaderboardId?: true
  }

  export type LeaderboardSubmissionCountAggregateInputType = {
    id?: true
    user?: true
    community?: true
    entryUrl?: true
    verifiedBy?: true
    weight?: true
    type?: true
    verifiedAt?: true
    rank?: true
    leaderboardId?: true
    _all?: true
  }

  export type LeaderboardSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaderboardSubmission to aggregate.
     */
    where?: LeaderboardSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardSubmissions to fetch.
     */
    orderBy?: LeaderboardSubmissionOrderByWithRelationInput | LeaderboardSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaderboardSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaderboardSubmissions
    **/
    _count?: true | LeaderboardSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaderboardSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaderboardSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaderboardSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaderboardSubmissionMaxAggregateInputType
  }

  export type GetLeaderboardSubmissionAggregateType<T extends LeaderboardSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaderboardSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaderboardSubmission[P]>
      : GetScalarType<T[P], AggregateLeaderboardSubmission[P]>
  }




  export type LeaderboardSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardSubmissionWhereInput
    orderBy?: LeaderboardSubmissionOrderByWithAggregationInput | LeaderboardSubmissionOrderByWithAggregationInput[]
    by: LeaderboardSubmissionScalarFieldEnum[] | LeaderboardSubmissionScalarFieldEnum
    having?: LeaderboardSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaderboardSubmissionCountAggregateInputType | true
    _avg?: LeaderboardSubmissionAvgAggregateInputType
    _sum?: LeaderboardSubmissionSumAggregateInputType
    _min?: LeaderboardSubmissionMinAggregateInputType
    _max?: LeaderboardSubmissionMaxAggregateInputType
  }

  export type LeaderboardSubmissionGroupByOutputType = {
    id: number
    user: string | null
    community: number | null
    entryUrl: string | null
    verifiedBy: number | null
    weight: string | null
    type: number | null
    verifiedAt: Date | null
    rank: number | null
    leaderboardId: number | null
    _count: LeaderboardSubmissionCountAggregateOutputType | null
    _avg: LeaderboardSubmissionAvgAggregateOutputType | null
    _sum: LeaderboardSubmissionSumAggregateOutputType | null
    _min: LeaderboardSubmissionMinAggregateOutputType | null
    _max: LeaderboardSubmissionMaxAggregateOutputType | null
  }

  type GetLeaderboardSubmissionGroupByPayload<T extends LeaderboardSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaderboardSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaderboardSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaderboardSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], LeaderboardSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type LeaderboardSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user?: boolean
    community?: boolean
    entryUrl?: boolean
    verifiedBy?: boolean
    weight?: boolean
    type?: boolean
    verifiedAt?: boolean
    rank?: boolean
    leaderboardId?: boolean
    LeaderboardSubmissionType?: boolean | LeaderboardSubmission$LeaderboardSubmissionTypeArgs<ExtArgs>
    Leaderboard?: boolean | LeaderboardSubmission$LeaderboardArgs<ExtArgs>
    _count?: boolean | LeaderboardSubmissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboardSubmission"]>

  export type LeaderboardSubmissionSelectScalar = {
    id?: boolean
    user?: boolean
    community?: boolean
    entryUrl?: boolean
    verifiedBy?: boolean
    weight?: boolean
    type?: boolean
    verifiedAt?: boolean
    rank?: boolean
    leaderboardId?: boolean
  }

  export type LeaderboardSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LeaderboardSubmissionType?: boolean | LeaderboardSubmission$LeaderboardSubmissionTypeArgs<ExtArgs>
    Leaderboard?: boolean | LeaderboardSubmission$LeaderboardArgs<ExtArgs>
    _count?: boolean | LeaderboardSubmissionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $LeaderboardSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaderboardSubmission"
    objects: {
      LeaderboardSubmissionType: Prisma.$LeaderboardSubmissionTypePayload<ExtArgs>[]
      Leaderboard: Prisma.$LeaderboardPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user: string | null
      community: number | null
      entryUrl: string | null
      verifiedBy: number | null
      weight: string | null
      type: number | null
      verifiedAt: Date | null
      rank: number | null
      leaderboardId: number | null
    }, ExtArgs["result"]["leaderboardSubmission"]>
    composites: {}
  }


  type LeaderboardSubmissionGetPayload<S extends boolean | null | undefined | LeaderboardSubmissionDefaultArgs> = $Result.GetResult<Prisma.$LeaderboardSubmissionPayload, S>

  type LeaderboardSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaderboardSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: LeaderboardSubmissionCountAggregateInputType | true
    }

  export interface LeaderboardSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaderboardSubmission'], meta: { name: 'LeaderboardSubmission' } }
    /**
     * Find zero or one LeaderboardSubmission that matches the filter.
     * @param {LeaderboardSubmissionFindUniqueArgs} args - Arguments to find a LeaderboardSubmission
     * @example
     * // Get one LeaderboardSubmission
     * const leaderboardSubmission = await prisma.leaderboardSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LeaderboardSubmissionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardSubmissionFindUniqueArgs<ExtArgs>>
    ): Prisma__LeaderboardSubmissionClient<$Result.GetResult<Prisma.$LeaderboardSubmissionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LeaderboardSubmission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LeaderboardSubmissionFindUniqueOrThrowArgs} args - Arguments to find a LeaderboardSubmission
     * @example
     * // Get one LeaderboardSubmission
     * const leaderboardSubmission = await prisma.leaderboardSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LeaderboardSubmissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardSubmissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LeaderboardSubmissionClient<$Result.GetResult<Prisma.$LeaderboardSubmissionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LeaderboardSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSubmissionFindFirstArgs} args - Arguments to find a LeaderboardSubmission
     * @example
     * // Get one LeaderboardSubmission
     * const leaderboardSubmission = await prisma.leaderboardSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LeaderboardSubmissionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardSubmissionFindFirstArgs<ExtArgs>>
    ): Prisma__LeaderboardSubmissionClient<$Result.GetResult<Prisma.$LeaderboardSubmissionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LeaderboardSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSubmissionFindFirstOrThrowArgs} args - Arguments to find a LeaderboardSubmission
     * @example
     * // Get one LeaderboardSubmission
     * const leaderboardSubmission = await prisma.leaderboardSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LeaderboardSubmissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardSubmissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LeaderboardSubmissionClient<$Result.GetResult<Prisma.$LeaderboardSubmissionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LeaderboardSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSubmissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaderboardSubmissions
     * const leaderboardSubmissions = await prisma.leaderboardSubmission.findMany()
     * 
     * // Get first 10 LeaderboardSubmissions
     * const leaderboardSubmissions = await prisma.leaderboardSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaderboardSubmissionWithIdOnly = await prisma.leaderboardSubmission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LeaderboardSubmissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardSubmissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardSubmissionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LeaderboardSubmission.
     * @param {LeaderboardSubmissionCreateArgs} args - Arguments to create a LeaderboardSubmission.
     * @example
     * // Create one LeaderboardSubmission
     * const LeaderboardSubmission = await prisma.leaderboardSubmission.create({
     *   data: {
     *     // ... data to create a LeaderboardSubmission
     *   }
     * })
     * 
    **/
    create<T extends LeaderboardSubmissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardSubmissionCreateArgs<ExtArgs>>
    ): Prisma__LeaderboardSubmissionClient<$Result.GetResult<Prisma.$LeaderboardSubmissionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LeaderboardSubmissions.
     *     @param {LeaderboardSubmissionCreateManyArgs} args - Arguments to create many LeaderboardSubmissions.
     *     @example
     *     // Create many LeaderboardSubmissions
     *     const leaderboardSubmission = await prisma.leaderboardSubmission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LeaderboardSubmissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardSubmissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LeaderboardSubmission.
     * @param {LeaderboardSubmissionDeleteArgs} args - Arguments to delete one LeaderboardSubmission.
     * @example
     * // Delete one LeaderboardSubmission
     * const LeaderboardSubmission = await prisma.leaderboardSubmission.delete({
     *   where: {
     *     // ... filter to delete one LeaderboardSubmission
     *   }
     * })
     * 
    **/
    delete<T extends LeaderboardSubmissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardSubmissionDeleteArgs<ExtArgs>>
    ): Prisma__LeaderboardSubmissionClient<$Result.GetResult<Prisma.$LeaderboardSubmissionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LeaderboardSubmission.
     * @param {LeaderboardSubmissionUpdateArgs} args - Arguments to update one LeaderboardSubmission.
     * @example
     * // Update one LeaderboardSubmission
     * const leaderboardSubmission = await prisma.leaderboardSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LeaderboardSubmissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardSubmissionUpdateArgs<ExtArgs>>
    ): Prisma__LeaderboardSubmissionClient<$Result.GetResult<Prisma.$LeaderboardSubmissionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LeaderboardSubmissions.
     * @param {LeaderboardSubmissionDeleteManyArgs} args - Arguments to filter LeaderboardSubmissions to delete.
     * @example
     * // Delete a few LeaderboardSubmissions
     * const { count } = await prisma.leaderboardSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LeaderboardSubmissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardSubmissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaderboardSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaderboardSubmissions
     * const leaderboardSubmission = await prisma.leaderboardSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LeaderboardSubmissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardSubmissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaderboardSubmission.
     * @param {LeaderboardSubmissionUpsertArgs} args - Arguments to update or create a LeaderboardSubmission.
     * @example
     * // Update or create a LeaderboardSubmission
     * const leaderboardSubmission = await prisma.leaderboardSubmission.upsert({
     *   create: {
     *     // ... data to create a LeaderboardSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaderboardSubmission we want to update
     *   }
     * })
    **/
    upsert<T extends LeaderboardSubmissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardSubmissionUpsertArgs<ExtArgs>>
    ): Prisma__LeaderboardSubmissionClient<$Result.GetResult<Prisma.$LeaderboardSubmissionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LeaderboardSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSubmissionCountArgs} args - Arguments to filter LeaderboardSubmissions to count.
     * @example
     * // Count the number of LeaderboardSubmissions
     * const count = await prisma.leaderboardSubmission.count({
     *   where: {
     *     // ... the filter for the LeaderboardSubmissions we want to count
     *   }
     * })
    **/
    count<T extends LeaderboardSubmissionCountArgs>(
      args?: Subset<T, LeaderboardSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaderboardSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaderboardSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaderboardSubmissionAggregateArgs>(args: Subset<T, LeaderboardSubmissionAggregateArgs>): Prisma.PrismaPromise<GetLeaderboardSubmissionAggregateType<T>>

    /**
     * Group by LeaderboardSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaderboardSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaderboardSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: LeaderboardSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaderboardSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaderboardSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaderboardSubmission model
   */
  readonly fields: LeaderboardSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaderboardSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaderboardSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    LeaderboardSubmissionType<T extends LeaderboardSubmission$LeaderboardSubmissionTypeArgs<ExtArgs> = {}>(args?: Subset<T, LeaderboardSubmission$LeaderboardSubmissionTypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardSubmissionTypePayload<ExtArgs>, T, 'findMany'> | Null>;

    Leaderboard<T extends LeaderboardSubmission$LeaderboardArgs<ExtArgs> = {}>(args?: Subset<T, LeaderboardSubmission$LeaderboardArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LeaderboardSubmission model
   */ 
  interface LeaderboardSubmissionFieldRefs {
    readonly id: FieldRef<"LeaderboardSubmission", 'Int'>
    readonly user: FieldRef<"LeaderboardSubmission", 'String'>
    readonly community: FieldRef<"LeaderboardSubmission", 'Int'>
    readonly entryUrl: FieldRef<"LeaderboardSubmission", 'String'>
    readonly verifiedBy: FieldRef<"LeaderboardSubmission", 'Int'>
    readonly weight: FieldRef<"LeaderboardSubmission", 'String'>
    readonly type: FieldRef<"LeaderboardSubmission", 'Int'>
    readonly verifiedAt: FieldRef<"LeaderboardSubmission", 'DateTime'>
    readonly rank: FieldRef<"LeaderboardSubmission", 'Int'>
    readonly leaderboardId: FieldRef<"LeaderboardSubmission", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * LeaderboardSubmission findUnique
   */
  export type LeaderboardSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmission
     */
    select?: LeaderboardSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardSubmission to fetch.
     */
    where: LeaderboardSubmissionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LeaderboardSubmission findUniqueOrThrow
   */
  export type LeaderboardSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmission
     */
    select?: LeaderboardSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardSubmission to fetch.
     */
    where: LeaderboardSubmissionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LeaderboardSubmission findFirst
   */
  export type LeaderboardSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmission
     */
    select?: LeaderboardSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardSubmission to fetch.
     */
    where?: LeaderboardSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardSubmissions to fetch.
     */
    orderBy?: LeaderboardSubmissionOrderByWithRelationInput | LeaderboardSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaderboardSubmissions.
     */
    cursor?: LeaderboardSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaderboardSubmissions.
     */
    distinct?: LeaderboardSubmissionScalarFieldEnum | LeaderboardSubmissionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LeaderboardSubmission findFirstOrThrow
   */
  export type LeaderboardSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmission
     */
    select?: LeaderboardSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardSubmission to fetch.
     */
    where?: LeaderboardSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardSubmissions to fetch.
     */
    orderBy?: LeaderboardSubmissionOrderByWithRelationInput | LeaderboardSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaderboardSubmissions.
     */
    cursor?: LeaderboardSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaderboardSubmissions.
     */
    distinct?: LeaderboardSubmissionScalarFieldEnum | LeaderboardSubmissionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LeaderboardSubmission findMany
   */
  export type LeaderboardSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmission
     */
    select?: LeaderboardSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardSubmissions to fetch.
     */
    where?: LeaderboardSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardSubmissions to fetch.
     */
    orderBy?: LeaderboardSubmissionOrderByWithRelationInput | LeaderboardSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaderboardSubmissions.
     */
    cursor?: LeaderboardSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardSubmissions.
     */
    skip?: number
    distinct?: LeaderboardSubmissionScalarFieldEnum | LeaderboardSubmissionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LeaderboardSubmission create
   */
  export type LeaderboardSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmission
     */
    select?: LeaderboardSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaderboardSubmission.
     */
    data?: XOR<LeaderboardSubmissionCreateInput, LeaderboardSubmissionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LeaderboardSubmission createMany
   */
  export type LeaderboardSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaderboardSubmissions.
     */
    data: LeaderboardSubmissionCreateManyInput | LeaderboardSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LeaderboardSubmission update
   */
  export type LeaderboardSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmission
     */
    select?: LeaderboardSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaderboardSubmission.
     */
    data: XOR<LeaderboardSubmissionUpdateInput, LeaderboardSubmissionUncheckedUpdateInput>
    /**
     * Choose, which LeaderboardSubmission to update.
     */
    where: LeaderboardSubmissionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LeaderboardSubmission updateMany
   */
  export type LeaderboardSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaderboardSubmissions.
     */
    data: XOR<LeaderboardSubmissionUpdateManyMutationInput, LeaderboardSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which LeaderboardSubmissions to update
     */
    where?: LeaderboardSubmissionWhereInput
  }


  /**
   * LeaderboardSubmission upsert
   */
  export type LeaderboardSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmission
     */
    select?: LeaderboardSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaderboardSubmission to update in case it exists.
     */
    where: LeaderboardSubmissionWhereUniqueInput
    /**
     * In case the LeaderboardSubmission found by the `where` argument doesn't exist, create a new LeaderboardSubmission with this data.
     */
    create: XOR<LeaderboardSubmissionCreateInput, LeaderboardSubmissionUncheckedCreateInput>
    /**
     * In case the LeaderboardSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaderboardSubmissionUpdateInput, LeaderboardSubmissionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LeaderboardSubmission delete
   */
  export type LeaderboardSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmission
     */
    select?: LeaderboardSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionInclude<ExtArgs> | null
    /**
     * Filter which LeaderboardSubmission to delete.
     */
    where: LeaderboardSubmissionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LeaderboardSubmission deleteMany
   */
  export type LeaderboardSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaderboardSubmissions to delete
     */
    where?: LeaderboardSubmissionWhereInput
  }


  /**
   * LeaderboardSubmission.LeaderboardSubmissionType
   */
  export type LeaderboardSubmission$LeaderboardSubmissionTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmissionType
     */
    select?: LeaderboardSubmissionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionTypeInclude<ExtArgs> | null
    where?: LeaderboardSubmissionTypeWhereInput
    orderBy?: LeaderboardSubmissionTypeOrderByWithRelationInput | LeaderboardSubmissionTypeOrderByWithRelationInput[]
    cursor?: LeaderboardSubmissionTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaderboardSubmissionTypeScalarFieldEnum | LeaderboardSubmissionTypeScalarFieldEnum[]
  }


  /**
   * LeaderboardSubmission.Leaderboard
   */
  export type LeaderboardSubmission$LeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardInclude<ExtArgs> | null
    where?: LeaderboardWhereInput
  }


  /**
   * LeaderboardSubmission without action
   */
  export type LeaderboardSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmission
     */
    select?: LeaderboardSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionInclude<ExtArgs> | null
  }



  /**
   * Model LeaderboardSubmissionType
   */

  export type AggregateLeaderboardSubmissionType = {
    _count: LeaderboardSubmissionTypeCountAggregateOutputType | null
    _avg: LeaderboardSubmissionTypeAvgAggregateOutputType | null
    _sum: LeaderboardSubmissionTypeSumAggregateOutputType | null
    _min: LeaderboardSubmissionTypeMinAggregateOutputType | null
    _max: LeaderboardSubmissionTypeMaxAggregateOutputType | null
  }

  export type LeaderboardSubmissionTypeAvgAggregateOutputType = {
    id: number | null
    leaderboardSubmissionId: number | null
  }

  export type LeaderboardSubmissionTypeSumAggregateOutputType = {
    id: number | null
    leaderboardSubmissionId: number | null
  }

  export type LeaderboardSubmissionTypeMinAggregateOutputType = {
    id: number | null
    type: string | null
    leaderboardSubmissionId: number | null
  }

  export type LeaderboardSubmissionTypeMaxAggregateOutputType = {
    id: number | null
    type: string | null
    leaderboardSubmissionId: number | null
  }

  export type LeaderboardSubmissionTypeCountAggregateOutputType = {
    id: number
    type: number
    leaderboardSubmissionId: number
    _all: number
  }


  export type LeaderboardSubmissionTypeAvgAggregateInputType = {
    id?: true
    leaderboardSubmissionId?: true
  }

  export type LeaderboardSubmissionTypeSumAggregateInputType = {
    id?: true
    leaderboardSubmissionId?: true
  }

  export type LeaderboardSubmissionTypeMinAggregateInputType = {
    id?: true
    type?: true
    leaderboardSubmissionId?: true
  }

  export type LeaderboardSubmissionTypeMaxAggregateInputType = {
    id?: true
    type?: true
    leaderboardSubmissionId?: true
  }

  export type LeaderboardSubmissionTypeCountAggregateInputType = {
    id?: true
    type?: true
    leaderboardSubmissionId?: true
    _all?: true
  }

  export type LeaderboardSubmissionTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaderboardSubmissionType to aggregate.
     */
    where?: LeaderboardSubmissionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardSubmissionTypes to fetch.
     */
    orderBy?: LeaderboardSubmissionTypeOrderByWithRelationInput | LeaderboardSubmissionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaderboardSubmissionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardSubmissionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardSubmissionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaderboardSubmissionTypes
    **/
    _count?: true | LeaderboardSubmissionTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaderboardSubmissionTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaderboardSubmissionTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaderboardSubmissionTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaderboardSubmissionTypeMaxAggregateInputType
  }

  export type GetLeaderboardSubmissionTypeAggregateType<T extends LeaderboardSubmissionTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaderboardSubmissionType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaderboardSubmissionType[P]>
      : GetScalarType<T[P], AggregateLeaderboardSubmissionType[P]>
  }




  export type LeaderboardSubmissionTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardSubmissionTypeWhereInput
    orderBy?: LeaderboardSubmissionTypeOrderByWithAggregationInput | LeaderboardSubmissionTypeOrderByWithAggregationInput[]
    by: LeaderboardSubmissionTypeScalarFieldEnum[] | LeaderboardSubmissionTypeScalarFieldEnum
    having?: LeaderboardSubmissionTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaderboardSubmissionTypeCountAggregateInputType | true
    _avg?: LeaderboardSubmissionTypeAvgAggregateInputType
    _sum?: LeaderboardSubmissionTypeSumAggregateInputType
    _min?: LeaderboardSubmissionTypeMinAggregateInputType
    _max?: LeaderboardSubmissionTypeMaxAggregateInputType
  }

  export type LeaderboardSubmissionTypeGroupByOutputType = {
    id: number
    type: string | null
    leaderboardSubmissionId: number | null
    _count: LeaderboardSubmissionTypeCountAggregateOutputType | null
    _avg: LeaderboardSubmissionTypeAvgAggregateOutputType | null
    _sum: LeaderboardSubmissionTypeSumAggregateOutputType | null
    _min: LeaderboardSubmissionTypeMinAggregateOutputType | null
    _max: LeaderboardSubmissionTypeMaxAggregateOutputType | null
  }

  type GetLeaderboardSubmissionTypeGroupByPayload<T extends LeaderboardSubmissionTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaderboardSubmissionTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaderboardSubmissionTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaderboardSubmissionTypeGroupByOutputType[P]>
            : GetScalarType<T[P], LeaderboardSubmissionTypeGroupByOutputType[P]>
        }
      >
    >


  export type LeaderboardSubmissionTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    leaderboardSubmissionId?: boolean
    LeaderboardSubmission?: boolean | LeaderboardSubmissionType$LeaderboardSubmissionArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboardSubmissionType"]>

  export type LeaderboardSubmissionTypeSelectScalar = {
    id?: boolean
    type?: boolean
    leaderboardSubmissionId?: boolean
  }

  export type LeaderboardSubmissionTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LeaderboardSubmission?: boolean | LeaderboardSubmissionType$LeaderboardSubmissionArgs<ExtArgs>
  }


  export type $LeaderboardSubmissionTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaderboardSubmissionType"
    objects: {
      LeaderboardSubmission: Prisma.$LeaderboardSubmissionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string | null
      leaderboardSubmissionId: number | null
    }, ExtArgs["result"]["leaderboardSubmissionType"]>
    composites: {}
  }


  type LeaderboardSubmissionTypeGetPayload<S extends boolean | null | undefined | LeaderboardSubmissionTypeDefaultArgs> = $Result.GetResult<Prisma.$LeaderboardSubmissionTypePayload, S>

  type LeaderboardSubmissionTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaderboardSubmissionTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: LeaderboardSubmissionTypeCountAggregateInputType | true
    }

  export interface LeaderboardSubmissionTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaderboardSubmissionType'], meta: { name: 'LeaderboardSubmissionType' } }
    /**
     * Find zero or one LeaderboardSubmissionType that matches the filter.
     * @param {LeaderboardSubmissionTypeFindUniqueArgs} args - Arguments to find a LeaderboardSubmissionType
     * @example
     * // Get one LeaderboardSubmissionType
     * const leaderboardSubmissionType = await prisma.leaderboardSubmissionType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LeaderboardSubmissionTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardSubmissionTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__LeaderboardSubmissionTypeClient<$Result.GetResult<Prisma.$LeaderboardSubmissionTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LeaderboardSubmissionType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LeaderboardSubmissionTypeFindUniqueOrThrowArgs} args - Arguments to find a LeaderboardSubmissionType
     * @example
     * // Get one LeaderboardSubmissionType
     * const leaderboardSubmissionType = await prisma.leaderboardSubmissionType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LeaderboardSubmissionTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardSubmissionTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LeaderboardSubmissionTypeClient<$Result.GetResult<Prisma.$LeaderboardSubmissionTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LeaderboardSubmissionType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSubmissionTypeFindFirstArgs} args - Arguments to find a LeaderboardSubmissionType
     * @example
     * // Get one LeaderboardSubmissionType
     * const leaderboardSubmissionType = await prisma.leaderboardSubmissionType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LeaderboardSubmissionTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardSubmissionTypeFindFirstArgs<ExtArgs>>
    ): Prisma__LeaderboardSubmissionTypeClient<$Result.GetResult<Prisma.$LeaderboardSubmissionTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LeaderboardSubmissionType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSubmissionTypeFindFirstOrThrowArgs} args - Arguments to find a LeaderboardSubmissionType
     * @example
     * // Get one LeaderboardSubmissionType
     * const leaderboardSubmissionType = await prisma.leaderboardSubmissionType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LeaderboardSubmissionTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardSubmissionTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LeaderboardSubmissionTypeClient<$Result.GetResult<Prisma.$LeaderboardSubmissionTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LeaderboardSubmissionTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSubmissionTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaderboardSubmissionTypes
     * const leaderboardSubmissionTypes = await prisma.leaderboardSubmissionType.findMany()
     * 
     * // Get first 10 LeaderboardSubmissionTypes
     * const leaderboardSubmissionTypes = await prisma.leaderboardSubmissionType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaderboardSubmissionTypeWithIdOnly = await prisma.leaderboardSubmissionType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LeaderboardSubmissionTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardSubmissionTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardSubmissionTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LeaderboardSubmissionType.
     * @param {LeaderboardSubmissionTypeCreateArgs} args - Arguments to create a LeaderboardSubmissionType.
     * @example
     * // Create one LeaderboardSubmissionType
     * const LeaderboardSubmissionType = await prisma.leaderboardSubmissionType.create({
     *   data: {
     *     // ... data to create a LeaderboardSubmissionType
     *   }
     * })
     * 
    **/
    create<T extends LeaderboardSubmissionTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardSubmissionTypeCreateArgs<ExtArgs>>
    ): Prisma__LeaderboardSubmissionTypeClient<$Result.GetResult<Prisma.$LeaderboardSubmissionTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LeaderboardSubmissionTypes.
     *     @param {LeaderboardSubmissionTypeCreateManyArgs} args - Arguments to create many LeaderboardSubmissionTypes.
     *     @example
     *     // Create many LeaderboardSubmissionTypes
     *     const leaderboardSubmissionType = await prisma.leaderboardSubmissionType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LeaderboardSubmissionTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardSubmissionTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LeaderboardSubmissionType.
     * @param {LeaderboardSubmissionTypeDeleteArgs} args - Arguments to delete one LeaderboardSubmissionType.
     * @example
     * // Delete one LeaderboardSubmissionType
     * const LeaderboardSubmissionType = await prisma.leaderboardSubmissionType.delete({
     *   where: {
     *     // ... filter to delete one LeaderboardSubmissionType
     *   }
     * })
     * 
    **/
    delete<T extends LeaderboardSubmissionTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardSubmissionTypeDeleteArgs<ExtArgs>>
    ): Prisma__LeaderboardSubmissionTypeClient<$Result.GetResult<Prisma.$LeaderboardSubmissionTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LeaderboardSubmissionType.
     * @param {LeaderboardSubmissionTypeUpdateArgs} args - Arguments to update one LeaderboardSubmissionType.
     * @example
     * // Update one LeaderboardSubmissionType
     * const leaderboardSubmissionType = await prisma.leaderboardSubmissionType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LeaderboardSubmissionTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardSubmissionTypeUpdateArgs<ExtArgs>>
    ): Prisma__LeaderboardSubmissionTypeClient<$Result.GetResult<Prisma.$LeaderboardSubmissionTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LeaderboardSubmissionTypes.
     * @param {LeaderboardSubmissionTypeDeleteManyArgs} args - Arguments to filter LeaderboardSubmissionTypes to delete.
     * @example
     * // Delete a few LeaderboardSubmissionTypes
     * const { count } = await prisma.leaderboardSubmissionType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LeaderboardSubmissionTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LeaderboardSubmissionTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaderboardSubmissionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSubmissionTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaderboardSubmissionTypes
     * const leaderboardSubmissionType = await prisma.leaderboardSubmissionType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LeaderboardSubmissionTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardSubmissionTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaderboardSubmissionType.
     * @param {LeaderboardSubmissionTypeUpsertArgs} args - Arguments to update or create a LeaderboardSubmissionType.
     * @example
     * // Update or create a LeaderboardSubmissionType
     * const leaderboardSubmissionType = await prisma.leaderboardSubmissionType.upsert({
     *   create: {
     *     // ... data to create a LeaderboardSubmissionType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaderboardSubmissionType we want to update
     *   }
     * })
    **/
    upsert<T extends LeaderboardSubmissionTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LeaderboardSubmissionTypeUpsertArgs<ExtArgs>>
    ): Prisma__LeaderboardSubmissionTypeClient<$Result.GetResult<Prisma.$LeaderboardSubmissionTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LeaderboardSubmissionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSubmissionTypeCountArgs} args - Arguments to filter LeaderboardSubmissionTypes to count.
     * @example
     * // Count the number of LeaderboardSubmissionTypes
     * const count = await prisma.leaderboardSubmissionType.count({
     *   where: {
     *     // ... the filter for the LeaderboardSubmissionTypes we want to count
     *   }
     * })
    **/
    count<T extends LeaderboardSubmissionTypeCountArgs>(
      args?: Subset<T, LeaderboardSubmissionTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaderboardSubmissionTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaderboardSubmissionType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSubmissionTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaderboardSubmissionTypeAggregateArgs>(args: Subset<T, LeaderboardSubmissionTypeAggregateArgs>): Prisma.PrismaPromise<GetLeaderboardSubmissionTypeAggregateType<T>>

    /**
     * Group by LeaderboardSubmissionType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSubmissionTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaderboardSubmissionTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaderboardSubmissionTypeGroupByArgs['orderBy'] }
        : { orderBy?: LeaderboardSubmissionTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaderboardSubmissionTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaderboardSubmissionTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaderboardSubmissionType model
   */
  readonly fields: LeaderboardSubmissionTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaderboardSubmissionType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaderboardSubmissionTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    LeaderboardSubmission<T extends LeaderboardSubmissionType$LeaderboardSubmissionArgs<ExtArgs> = {}>(args?: Subset<T, LeaderboardSubmissionType$LeaderboardSubmissionArgs<ExtArgs>>): Prisma__LeaderboardSubmissionClient<$Result.GetResult<Prisma.$LeaderboardSubmissionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LeaderboardSubmissionType model
   */ 
  interface LeaderboardSubmissionTypeFieldRefs {
    readonly id: FieldRef<"LeaderboardSubmissionType", 'Int'>
    readonly type: FieldRef<"LeaderboardSubmissionType", 'String'>
    readonly leaderboardSubmissionId: FieldRef<"LeaderboardSubmissionType", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * LeaderboardSubmissionType findUnique
   */
  export type LeaderboardSubmissionTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmissionType
     */
    select?: LeaderboardSubmissionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardSubmissionType to fetch.
     */
    where: LeaderboardSubmissionTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LeaderboardSubmissionType findUniqueOrThrow
   */
  export type LeaderboardSubmissionTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmissionType
     */
    select?: LeaderboardSubmissionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardSubmissionType to fetch.
     */
    where: LeaderboardSubmissionTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LeaderboardSubmissionType findFirst
   */
  export type LeaderboardSubmissionTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmissionType
     */
    select?: LeaderboardSubmissionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardSubmissionType to fetch.
     */
    where?: LeaderboardSubmissionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardSubmissionTypes to fetch.
     */
    orderBy?: LeaderboardSubmissionTypeOrderByWithRelationInput | LeaderboardSubmissionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaderboardSubmissionTypes.
     */
    cursor?: LeaderboardSubmissionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardSubmissionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardSubmissionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaderboardSubmissionTypes.
     */
    distinct?: LeaderboardSubmissionTypeScalarFieldEnum | LeaderboardSubmissionTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LeaderboardSubmissionType findFirstOrThrow
   */
  export type LeaderboardSubmissionTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmissionType
     */
    select?: LeaderboardSubmissionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardSubmissionType to fetch.
     */
    where?: LeaderboardSubmissionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardSubmissionTypes to fetch.
     */
    orderBy?: LeaderboardSubmissionTypeOrderByWithRelationInput | LeaderboardSubmissionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaderboardSubmissionTypes.
     */
    cursor?: LeaderboardSubmissionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardSubmissionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardSubmissionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaderboardSubmissionTypes.
     */
    distinct?: LeaderboardSubmissionTypeScalarFieldEnum | LeaderboardSubmissionTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LeaderboardSubmissionType findMany
   */
  export type LeaderboardSubmissionTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmissionType
     */
    select?: LeaderboardSubmissionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardSubmissionTypes to fetch.
     */
    where?: LeaderboardSubmissionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardSubmissionTypes to fetch.
     */
    orderBy?: LeaderboardSubmissionTypeOrderByWithRelationInput | LeaderboardSubmissionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaderboardSubmissionTypes.
     */
    cursor?: LeaderboardSubmissionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardSubmissionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardSubmissionTypes.
     */
    skip?: number
    distinct?: LeaderboardSubmissionTypeScalarFieldEnum | LeaderboardSubmissionTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LeaderboardSubmissionType create
   */
  export type LeaderboardSubmissionTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmissionType
     */
    select?: LeaderboardSubmissionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaderboardSubmissionType.
     */
    data: XOR<LeaderboardSubmissionTypeCreateInput, LeaderboardSubmissionTypeUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LeaderboardSubmissionType createMany
   */
  export type LeaderboardSubmissionTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaderboardSubmissionTypes.
     */
    data: LeaderboardSubmissionTypeCreateManyInput | LeaderboardSubmissionTypeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LeaderboardSubmissionType update
   */
  export type LeaderboardSubmissionTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmissionType
     */
    select?: LeaderboardSubmissionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaderboardSubmissionType.
     */
    data: XOR<LeaderboardSubmissionTypeUpdateInput, LeaderboardSubmissionTypeUncheckedUpdateInput>
    /**
     * Choose, which LeaderboardSubmissionType to update.
     */
    where: LeaderboardSubmissionTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LeaderboardSubmissionType updateMany
   */
  export type LeaderboardSubmissionTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaderboardSubmissionTypes.
     */
    data: XOR<LeaderboardSubmissionTypeUpdateManyMutationInput, LeaderboardSubmissionTypeUncheckedUpdateManyInput>
    /**
     * Filter which LeaderboardSubmissionTypes to update
     */
    where?: LeaderboardSubmissionTypeWhereInput
  }


  /**
   * LeaderboardSubmissionType upsert
   */
  export type LeaderboardSubmissionTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmissionType
     */
    select?: LeaderboardSubmissionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaderboardSubmissionType to update in case it exists.
     */
    where: LeaderboardSubmissionTypeWhereUniqueInput
    /**
     * In case the LeaderboardSubmissionType found by the `where` argument doesn't exist, create a new LeaderboardSubmissionType with this data.
     */
    create: XOR<LeaderboardSubmissionTypeCreateInput, LeaderboardSubmissionTypeUncheckedCreateInput>
    /**
     * In case the LeaderboardSubmissionType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaderboardSubmissionTypeUpdateInput, LeaderboardSubmissionTypeUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LeaderboardSubmissionType delete
   */
  export type LeaderboardSubmissionTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmissionType
     */
    select?: LeaderboardSubmissionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionTypeInclude<ExtArgs> | null
    /**
     * Filter which LeaderboardSubmissionType to delete.
     */
    where: LeaderboardSubmissionTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LeaderboardSubmissionType deleteMany
   */
  export type LeaderboardSubmissionTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaderboardSubmissionTypes to delete
     */
    where?: LeaderboardSubmissionTypeWhereInput
  }


  /**
   * LeaderboardSubmissionType.LeaderboardSubmission
   */
  export type LeaderboardSubmissionType$LeaderboardSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmission
     */
    select?: LeaderboardSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionInclude<ExtArgs> | null
    where?: LeaderboardSubmissionWhereInput
  }


  /**
   * LeaderboardSubmissionType without action
   */
  export type LeaderboardSubmissionTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSubmissionType
     */
    select?: LeaderboardSubmissionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LeaderboardSubmissionTypeInclude<ExtArgs> | null
  }



  /**
   * Model PendingPostStatus
   */

  export type AggregatePendingPostStatus = {
    _count: PendingPostStatusCountAggregateOutputType | null
    _avg: PendingPostStatusAvgAggregateOutputType | null
    _sum: PendingPostStatusSumAggregateOutputType | null
    _min: PendingPostStatusMinAggregateOutputType | null
    _max: PendingPostStatusMaxAggregateOutputType | null
  }

  export type PendingPostStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type PendingPostStatusSumAggregateOutputType = {
    id: number | null
  }

  export type PendingPostStatusMinAggregateOutputType = {
    id: number | null
    status: string | null
  }

  export type PendingPostStatusMaxAggregateOutputType = {
    id: number | null
    status: string | null
  }

  export type PendingPostStatusCountAggregateOutputType = {
    id: number
    status: number
    _all: number
  }


  export type PendingPostStatusAvgAggregateInputType = {
    id?: true
  }

  export type PendingPostStatusSumAggregateInputType = {
    id?: true
  }

  export type PendingPostStatusMinAggregateInputType = {
    id?: true
    status?: true
  }

  export type PendingPostStatusMaxAggregateInputType = {
    id?: true
    status?: true
  }

  export type PendingPostStatusCountAggregateInputType = {
    id?: true
    status?: true
    _all?: true
  }

  export type PendingPostStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingPostStatus to aggregate.
     */
    where?: PendingPostStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPostStatuses to fetch.
     */
    orderBy?: PendingPostStatusOrderByWithRelationInput | PendingPostStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendingPostStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPostStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPostStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingPostStatuses
    **/
    _count?: true | PendingPostStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendingPostStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendingPostStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendingPostStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendingPostStatusMaxAggregateInputType
  }

  export type GetPendingPostStatusAggregateType<T extends PendingPostStatusAggregateArgs> = {
        [P in keyof T & keyof AggregatePendingPostStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingPostStatus[P]>
      : GetScalarType<T[P], AggregatePendingPostStatus[P]>
  }




  export type PendingPostStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingPostStatusWhereInput
    orderBy?: PendingPostStatusOrderByWithAggregationInput | PendingPostStatusOrderByWithAggregationInput[]
    by: PendingPostStatusScalarFieldEnum[] | PendingPostStatusScalarFieldEnum
    having?: PendingPostStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendingPostStatusCountAggregateInputType | true
    _avg?: PendingPostStatusAvgAggregateInputType
    _sum?: PendingPostStatusSumAggregateInputType
    _min?: PendingPostStatusMinAggregateInputType
    _max?: PendingPostStatusMaxAggregateInputType
  }

  export type PendingPostStatusGroupByOutputType = {
    id: number
    status: string | null
    _count: PendingPostStatusCountAggregateOutputType | null
    _avg: PendingPostStatusAvgAggregateOutputType | null
    _sum: PendingPostStatusSumAggregateOutputType | null
    _min: PendingPostStatusMinAggregateOutputType | null
    _max: PendingPostStatusMaxAggregateOutputType | null
  }

  type GetPendingPostStatusGroupByPayload<T extends PendingPostStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendingPostStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendingPostStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendingPostStatusGroupByOutputType[P]>
            : GetScalarType<T[P], PendingPostStatusGroupByOutputType[P]>
        }
      >
    >


  export type PendingPostStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    PendingPost?: boolean | PendingPostStatus$PendingPostArgs<ExtArgs>
    _count?: boolean | PendingPostStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingPostStatus"]>

  export type PendingPostStatusSelectScalar = {
    id?: boolean
    status?: boolean
  }

  export type PendingPostStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PendingPost?: boolean | PendingPostStatus$PendingPostArgs<ExtArgs>
    _count?: boolean | PendingPostStatusCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PendingPostStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PendingPostStatus"
    objects: {
      PendingPost: Prisma.$PendingPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      status: string | null
    }, ExtArgs["result"]["pendingPostStatus"]>
    composites: {}
  }


  type PendingPostStatusGetPayload<S extends boolean | null | undefined | PendingPostStatusDefaultArgs> = $Result.GetResult<Prisma.$PendingPostStatusPayload, S>

  type PendingPostStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PendingPostStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: PendingPostStatusCountAggregateInputType | true
    }

  export interface PendingPostStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PendingPostStatus'], meta: { name: 'PendingPostStatus' } }
    /**
     * Find zero or one PendingPostStatus that matches the filter.
     * @param {PendingPostStatusFindUniqueArgs} args - Arguments to find a PendingPostStatus
     * @example
     * // Get one PendingPostStatus
     * const pendingPostStatus = await prisma.pendingPostStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PendingPostStatusFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PendingPostStatusFindUniqueArgs<ExtArgs>>
    ): Prisma__PendingPostStatusClient<$Result.GetResult<Prisma.$PendingPostStatusPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PendingPostStatus that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PendingPostStatusFindUniqueOrThrowArgs} args - Arguments to find a PendingPostStatus
     * @example
     * // Get one PendingPostStatus
     * const pendingPostStatus = await prisma.pendingPostStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PendingPostStatusFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingPostStatusFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PendingPostStatusClient<$Result.GetResult<Prisma.$PendingPostStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PendingPostStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostStatusFindFirstArgs} args - Arguments to find a PendingPostStatus
     * @example
     * // Get one PendingPostStatus
     * const pendingPostStatus = await prisma.pendingPostStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PendingPostStatusFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingPostStatusFindFirstArgs<ExtArgs>>
    ): Prisma__PendingPostStatusClient<$Result.GetResult<Prisma.$PendingPostStatusPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PendingPostStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostStatusFindFirstOrThrowArgs} args - Arguments to find a PendingPostStatus
     * @example
     * // Get one PendingPostStatus
     * const pendingPostStatus = await prisma.pendingPostStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PendingPostStatusFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingPostStatusFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PendingPostStatusClient<$Result.GetResult<Prisma.$PendingPostStatusPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PendingPostStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostStatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingPostStatuses
     * const pendingPostStatuses = await prisma.pendingPostStatus.findMany()
     * 
     * // Get first 10 PendingPostStatuses
     * const pendingPostStatuses = await prisma.pendingPostStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingPostStatusWithIdOnly = await prisma.pendingPostStatus.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PendingPostStatusFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingPostStatusFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingPostStatusPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PendingPostStatus.
     * @param {PendingPostStatusCreateArgs} args - Arguments to create a PendingPostStatus.
     * @example
     * // Create one PendingPostStatus
     * const PendingPostStatus = await prisma.pendingPostStatus.create({
     *   data: {
     *     // ... data to create a PendingPostStatus
     *   }
     * })
     * 
    **/
    create<T extends PendingPostStatusCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PendingPostStatusCreateArgs<ExtArgs>>
    ): Prisma__PendingPostStatusClient<$Result.GetResult<Prisma.$PendingPostStatusPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PendingPostStatuses.
     *     @param {PendingPostStatusCreateManyArgs} args - Arguments to create many PendingPostStatuses.
     *     @example
     *     // Create many PendingPostStatuses
     *     const pendingPostStatus = await prisma.pendingPostStatus.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PendingPostStatusCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingPostStatusCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PendingPostStatus.
     * @param {PendingPostStatusDeleteArgs} args - Arguments to delete one PendingPostStatus.
     * @example
     * // Delete one PendingPostStatus
     * const PendingPostStatus = await prisma.pendingPostStatus.delete({
     *   where: {
     *     // ... filter to delete one PendingPostStatus
     *   }
     * })
     * 
    **/
    delete<T extends PendingPostStatusDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PendingPostStatusDeleteArgs<ExtArgs>>
    ): Prisma__PendingPostStatusClient<$Result.GetResult<Prisma.$PendingPostStatusPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PendingPostStatus.
     * @param {PendingPostStatusUpdateArgs} args - Arguments to update one PendingPostStatus.
     * @example
     * // Update one PendingPostStatus
     * const pendingPostStatus = await prisma.pendingPostStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PendingPostStatusUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PendingPostStatusUpdateArgs<ExtArgs>>
    ): Prisma__PendingPostStatusClient<$Result.GetResult<Prisma.$PendingPostStatusPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PendingPostStatuses.
     * @param {PendingPostStatusDeleteManyArgs} args - Arguments to filter PendingPostStatuses to delete.
     * @example
     * // Delete a few PendingPostStatuses
     * const { count } = await prisma.pendingPostStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PendingPostStatusDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PendingPostStatusDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingPostStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingPostStatuses
     * const pendingPostStatus = await prisma.pendingPostStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PendingPostStatusUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PendingPostStatusUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PendingPostStatus.
     * @param {PendingPostStatusUpsertArgs} args - Arguments to update or create a PendingPostStatus.
     * @example
     * // Update or create a PendingPostStatus
     * const pendingPostStatus = await prisma.pendingPostStatus.upsert({
     *   create: {
     *     // ... data to create a PendingPostStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingPostStatus we want to update
     *   }
     * })
    **/
    upsert<T extends PendingPostStatusUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PendingPostStatusUpsertArgs<ExtArgs>>
    ): Prisma__PendingPostStatusClient<$Result.GetResult<Prisma.$PendingPostStatusPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PendingPostStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostStatusCountArgs} args - Arguments to filter PendingPostStatuses to count.
     * @example
     * // Count the number of PendingPostStatuses
     * const count = await prisma.pendingPostStatus.count({
     *   where: {
     *     // ... the filter for the PendingPostStatuses we want to count
     *   }
     * })
    **/
    count<T extends PendingPostStatusCountArgs>(
      args?: Subset<T, PendingPostStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingPostStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingPostStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingPostStatusAggregateArgs>(args: Subset<T, PendingPostStatusAggregateArgs>): Prisma.PrismaPromise<GetPendingPostStatusAggregateType<T>>

    /**
     * Group by PendingPostStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPostStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingPostStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingPostStatusGroupByArgs['orderBy'] }
        : { orderBy?: PendingPostStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingPostStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingPostStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PendingPostStatus model
   */
  readonly fields: PendingPostStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingPostStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendingPostStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    PendingPost<T extends PendingPostStatus$PendingPostArgs<ExtArgs> = {}>(args?: Subset<T, PendingPostStatus$PendingPostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingPostPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PendingPostStatus model
   */ 
  interface PendingPostStatusFieldRefs {
    readonly id: FieldRef<"PendingPostStatus", 'Int'>
    readonly status: FieldRef<"PendingPostStatus", 'String'>
  }
    

  // Custom InputTypes

  /**
   * PendingPostStatus findUnique
   */
  export type PendingPostStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPostStatus
     */
    select?: PendingPostStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostStatusInclude<ExtArgs> | null
    /**
     * Filter, which PendingPostStatus to fetch.
     */
    where: PendingPostStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * PendingPostStatus findUniqueOrThrow
   */
  export type PendingPostStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPostStatus
     */
    select?: PendingPostStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostStatusInclude<ExtArgs> | null
    /**
     * Filter, which PendingPostStatus to fetch.
     */
    where: PendingPostStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * PendingPostStatus findFirst
   */
  export type PendingPostStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPostStatus
     */
    select?: PendingPostStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostStatusInclude<ExtArgs> | null
    /**
     * Filter, which PendingPostStatus to fetch.
     */
    where?: PendingPostStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPostStatuses to fetch.
     */
    orderBy?: PendingPostStatusOrderByWithRelationInput | PendingPostStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingPostStatuses.
     */
    cursor?: PendingPostStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPostStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPostStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingPostStatuses.
     */
    distinct?: PendingPostStatusScalarFieldEnum | PendingPostStatusScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * PendingPostStatus findFirstOrThrow
   */
  export type PendingPostStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPostStatus
     */
    select?: PendingPostStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostStatusInclude<ExtArgs> | null
    /**
     * Filter, which PendingPostStatus to fetch.
     */
    where?: PendingPostStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPostStatuses to fetch.
     */
    orderBy?: PendingPostStatusOrderByWithRelationInput | PendingPostStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingPostStatuses.
     */
    cursor?: PendingPostStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPostStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPostStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingPostStatuses.
     */
    distinct?: PendingPostStatusScalarFieldEnum | PendingPostStatusScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * PendingPostStatus findMany
   */
  export type PendingPostStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPostStatus
     */
    select?: PendingPostStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostStatusInclude<ExtArgs> | null
    /**
     * Filter, which PendingPostStatuses to fetch.
     */
    where?: PendingPostStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPostStatuses to fetch.
     */
    orderBy?: PendingPostStatusOrderByWithRelationInput | PendingPostStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingPostStatuses.
     */
    cursor?: PendingPostStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPostStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPostStatuses.
     */
    skip?: number
    distinct?: PendingPostStatusScalarFieldEnum | PendingPostStatusScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * PendingPostStatus create
   */
  export type PendingPostStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPostStatus
     */
    select?: PendingPostStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a PendingPostStatus.
     */
    data: XOR<PendingPostStatusCreateInput, PendingPostStatusUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * PendingPostStatus createMany
   */
  export type PendingPostStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PendingPostStatuses.
     */
    data: PendingPostStatusCreateManyInput | PendingPostStatusCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PendingPostStatus update
   */
  export type PendingPostStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPostStatus
     */
    select?: PendingPostStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a PendingPostStatus.
     */
    data: XOR<PendingPostStatusUpdateInput, PendingPostStatusUncheckedUpdateInput>
    /**
     * Choose, which PendingPostStatus to update.
     */
    where: PendingPostStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * PendingPostStatus updateMany
   */
  export type PendingPostStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PendingPostStatuses.
     */
    data: XOR<PendingPostStatusUpdateManyMutationInput, PendingPostStatusUncheckedUpdateManyInput>
    /**
     * Filter which PendingPostStatuses to update
     */
    where?: PendingPostStatusWhereInput
  }


  /**
   * PendingPostStatus upsert
   */
  export type PendingPostStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPostStatus
     */
    select?: PendingPostStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the PendingPostStatus to update in case it exists.
     */
    where: PendingPostStatusWhereUniqueInput
    /**
     * In case the PendingPostStatus found by the `where` argument doesn't exist, create a new PendingPostStatus with this data.
     */
    create: XOR<PendingPostStatusCreateInput, PendingPostStatusUncheckedCreateInput>
    /**
     * In case the PendingPostStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendingPostStatusUpdateInput, PendingPostStatusUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * PendingPostStatus delete
   */
  export type PendingPostStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPostStatus
     */
    select?: PendingPostStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostStatusInclude<ExtArgs> | null
    /**
     * Filter which PendingPostStatus to delete.
     */
    where: PendingPostStatusWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * PendingPostStatus deleteMany
   */
  export type PendingPostStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingPostStatuses to delete
     */
    where?: PendingPostStatusWhereInput
  }


  /**
   * PendingPostStatus.PendingPost
   */
  export type PendingPostStatus$PendingPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPost
     */
    select?: PendingPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostInclude<ExtArgs> | null
    where?: PendingPostWhereInput
    orderBy?: PendingPostOrderByWithRelationInput | PendingPostOrderByWithRelationInput[]
    cursor?: PendingPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendingPostScalarFieldEnum | PendingPostScalarFieldEnum[]
  }


  /**
   * PendingPostStatus without action
   */
  export type PendingPostStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPostStatus
     */
    select?: PendingPostStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingPostStatusInclude<ExtArgs> | null
  }



  /**
   * Model LogLevel
   */

  export type AggregateLogLevel = {
    _count: LogLevelCountAggregateOutputType | null
    _avg: LogLevelAvgAggregateOutputType | null
    _sum: LogLevelSumAggregateOutputType | null
    _min: LogLevelMinAggregateOutputType | null
    _max: LogLevelMaxAggregateOutputType | null
  }

  export type LogLevelAvgAggregateOutputType = {
    id: number | null
  }

  export type LogLevelSumAggregateOutputType = {
    id: number | null
  }

  export type LogLevelMinAggregateOutputType = {
    id: number | null
    level: string | null
  }

  export type LogLevelMaxAggregateOutputType = {
    id: number | null
    level: string | null
  }

  export type LogLevelCountAggregateOutputType = {
    id: number
    level: number
    _all: number
  }


  export type LogLevelAvgAggregateInputType = {
    id?: true
  }

  export type LogLevelSumAggregateInputType = {
    id?: true
  }

  export type LogLevelMinAggregateInputType = {
    id?: true
    level?: true
  }

  export type LogLevelMaxAggregateInputType = {
    id?: true
    level?: true
  }

  export type LogLevelCountAggregateInputType = {
    id?: true
    level?: true
    _all?: true
  }

  export type LogLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogLevel to aggregate.
     */
    where?: LogLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogLevels to fetch.
     */
    orderBy?: LogLevelOrderByWithRelationInput | LogLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogLevels
    **/
    _count?: true | LogLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogLevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogLevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogLevelMaxAggregateInputType
  }

  export type GetLogLevelAggregateType<T extends LogLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateLogLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogLevel[P]>
      : GetScalarType<T[P], AggregateLogLevel[P]>
  }




  export type LogLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogLevelWhereInput
    orderBy?: LogLevelOrderByWithAggregationInput | LogLevelOrderByWithAggregationInput[]
    by: LogLevelScalarFieldEnum[] | LogLevelScalarFieldEnum
    having?: LogLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogLevelCountAggregateInputType | true
    _avg?: LogLevelAvgAggregateInputType
    _sum?: LogLevelSumAggregateInputType
    _min?: LogLevelMinAggregateInputType
    _max?: LogLevelMaxAggregateInputType
  }

  export type LogLevelGroupByOutputType = {
    id: number
    level: string | null
    _count: LogLevelCountAggregateOutputType | null
    _avg: LogLevelAvgAggregateOutputType | null
    _sum: LogLevelSumAggregateOutputType | null
    _min: LogLevelMinAggregateOutputType | null
    _max: LogLevelMaxAggregateOutputType | null
  }

  type GetLogLevelGroupByPayload<T extends LogLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogLevelGroupByOutputType[P]>
            : GetScalarType<T[P], LogLevelGroupByOutputType[P]>
        }
      >
    >


  export type LogLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    Log?: boolean | LogLevel$LogArgs<ExtArgs>
    _count?: boolean | LogLevelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logLevel"]>

  export type LogLevelSelectScalar = {
    id?: boolean
    level?: boolean
  }

  export type LogLevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Log?: boolean | LogLevel$LogArgs<ExtArgs>
    _count?: boolean | LogLevelCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $LogLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogLevel"
    objects: {
      Log: Prisma.$LogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      level: string | null
    }, ExtArgs["result"]["logLevel"]>
    composites: {}
  }


  type LogLevelGetPayload<S extends boolean | null | undefined | LogLevelDefaultArgs> = $Result.GetResult<Prisma.$LogLevelPayload, S>

  type LogLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogLevelFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: LogLevelCountAggregateInputType | true
    }

  export interface LogLevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogLevel'], meta: { name: 'LogLevel' } }
    /**
     * Find zero or one LogLevel that matches the filter.
     * @param {LogLevelFindUniqueArgs} args - Arguments to find a LogLevel
     * @example
     * // Get one LogLevel
     * const logLevel = await prisma.logLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogLevelFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogLevelFindUniqueArgs<ExtArgs>>
    ): Prisma__LogLevelClient<$Result.GetResult<Prisma.$LogLevelPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LogLevel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogLevelFindUniqueOrThrowArgs} args - Arguments to find a LogLevel
     * @example
     * // Get one LogLevel
     * const logLevel = await prisma.logLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogLevelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogLevelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogLevelClient<$Result.GetResult<Prisma.$LogLevelPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LogLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLevelFindFirstArgs} args - Arguments to find a LogLevel
     * @example
     * // Get one LogLevel
     * const logLevel = await prisma.logLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogLevelFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogLevelFindFirstArgs<ExtArgs>>
    ): Prisma__LogLevelClient<$Result.GetResult<Prisma.$LogLevelPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LogLevel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLevelFindFirstOrThrowArgs} args - Arguments to find a LogLevel
     * @example
     * // Get one LogLevel
     * const logLevel = await prisma.logLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogLevelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogLevelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogLevelClient<$Result.GetResult<Prisma.$LogLevelPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LogLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLevelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogLevels
     * const logLevels = await prisma.logLevel.findMany()
     * 
     * // Get first 10 LogLevels
     * const logLevels = await prisma.logLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logLevelWithIdOnly = await prisma.logLevel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogLevelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogLevelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogLevelPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LogLevel.
     * @param {LogLevelCreateArgs} args - Arguments to create a LogLevel.
     * @example
     * // Create one LogLevel
     * const LogLevel = await prisma.logLevel.create({
     *   data: {
     *     // ... data to create a LogLevel
     *   }
     * })
     * 
    **/
    create<T extends LogLevelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogLevelCreateArgs<ExtArgs>>
    ): Prisma__LogLevelClient<$Result.GetResult<Prisma.$LogLevelPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LogLevels.
     *     @param {LogLevelCreateManyArgs} args - Arguments to create many LogLevels.
     *     @example
     *     // Create many LogLevels
     *     const logLevel = await prisma.logLevel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogLevelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogLevelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogLevel.
     * @param {LogLevelDeleteArgs} args - Arguments to delete one LogLevel.
     * @example
     * // Delete one LogLevel
     * const LogLevel = await prisma.logLevel.delete({
     *   where: {
     *     // ... filter to delete one LogLevel
     *   }
     * })
     * 
    **/
    delete<T extends LogLevelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogLevelDeleteArgs<ExtArgs>>
    ): Prisma__LogLevelClient<$Result.GetResult<Prisma.$LogLevelPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LogLevel.
     * @param {LogLevelUpdateArgs} args - Arguments to update one LogLevel.
     * @example
     * // Update one LogLevel
     * const logLevel = await prisma.logLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogLevelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogLevelUpdateArgs<ExtArgs>>
    ): Prisma__LogLevelClient<$Result.GetResult<Prisma.$LogLevelPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LogLevels.
     * @param {LogLevelDeleteManyArgs} args - Arguments to filter LogLevels to delete.
     * @example
     * // Delete a few LogLevels
     * const { count } = await prisma.logLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogLevelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogLevelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogLevels
     * const logLevel = await prisma.logLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogLevelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogLevelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogLevel.
     * @param {LogLevelUpsertArgs} args - Arguments to update or create a LogLevel.
     * @example
     * // Update or create a LogLevel
     * const logLevel = await prisma.logLevel.upsert({
     *   create: {
     *     // ... data to create a LogLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogLevel we want to update
     *   }
     * })
    **/
    upsert<T extends LogLevelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogLevelUpsertArgs<ExtArgs>>
    ): Prisma__LogLevelClient<$Result.GetResult<Prisma.$LogLevelPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LogLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLevelCountArgs} args - Arguments to filter LogLevels to count.
     * @example
     * // Count the number of LogLevels
     * const count = await prisma.logLevel.count({
     *   where: {
     *     // ... the filter for the LogLevels we want to count
     *   }
     * })
    **/
    count<T extends LogLevelCountArgs>(
      args?: Subset<T, LogLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogLevelAggregateArgs>(args: Subset<T, LogLevelAggregateArgs>): Prisma.PrismaPromise<GetLogLevelAggregateType<T>>

    /**
     * Group by LogLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogLevelGroupByArgs['orderBy'] }
        : { orderBy?: LogLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogLevel model
   */
  readonly fields: LogLevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogLevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Log<T extends LogLevel$LogArgs<ExtArgs> = {}>(args?: Subset<T, LogLevel$LogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LogLevel model
   */ 
  interface LogLevelFieldRefs {
    readonly id: FieldRef<"LogLevel", 'Int'>
    readonly level: FieldRef<"LogLevel", 'String'>
  }
    

  // Custom InputTypes

  /**
   * LogLevel findUnique
   */
  export type LogLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLevel
     */
    select?: LogLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLevelInclude<ExtArgs> | null
    /**
     * Filter, which LogLevel to fetch.
     */
    where: LogLevelWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LogLevel findUniqueOrThrow
   */
  export type LogLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLevel
     */
    select?: LogLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLevelInclude<ExtArgs> | null
    /**
     * Filter, which LogLevel to fetch.
     */
    where: LogLevelWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LogLevel findFirst
   */
  export type LogLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLevel
     */
    select?: LogLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLevelInclude<ExtArgs> | null
    /**
     * Filter, which LogLevel to fetch.
     */
    where?: LogLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogLevels to fetch.
     */
    orderBy?: LogLevelOrderByWithRelationInput | LogLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogLevels.
     */
    cursor?: LogLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogLevels.
     */
    distinct?: LogLevelScalarFieldEnum | LogLevelScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LogLevel findFirstOrThrow
   */
  export type LogLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLevel
     */
    select?: LogLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLevelInclude<ExtArgs> | null
    /**
     * Filter, which LogLevel to fetch.
     */
    where?: LogLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogLevels to fetch.
     */
    orderBy?: LogLevelOrderByWithRelationInput | LogLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogLevels.
     */
    cursor?: LogLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogLevels.
     */
    distinct?: LogLevelScalarFieldEnum | LogLevelScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LogLevel findMany
   */
  export type LogLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLevel
     */
    select?: LogLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLevelInclude<ExtArgs> | null
    /**
     * Filter, which LogLevels to fetch.
     */
    where?: LogLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogLevels to fetch.
     */
    orderBy?: LogLevelOrderByWithRelationInput | LogLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogLevels.
     */
    cursor?: LogLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogLevels.
     */
    skip?: number
    distinct?: LogLevelScalarFieldEnum | LogLevelScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LogLevel create
   */
  export type LogLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLevel
     */
    select?: LogLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLevelInclude<ExtArgs> | null
    /**
     * The data needed to create a LogLevel.
     */
    data: XOR<LogLevelCreateInput, LogLevelUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LogLevel createMany
   */
  export type LogLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogLevels.
     */
    data: LogLevelCreateManyInput | LogLevelCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LogLevel update
   */
  export type LogLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLevel
     */
    select?: LogLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLevelInclude<ExtArgs> | null
    /**
     * The data needed to update a LogLevel.
     */
    data: XOR<LogLevelUpdateInput, LogLevelUncheckedUpdateInput>
    /**
     * Choose, which LogLevel to update.
     */
    where: LogLevelWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LogLevel updateMany
   */
  export type LogLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogLevels.
     */
    data: XOR<LogLevelUpdateManyMutationInput, LogLevelUncheckedUpdateManyInput>
    /**
     * Filter which LogLevels to update
     */
    where?: LogLevelWhereInput
  }


  /**
   * LogLevel upsert
   */
  export type LogLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLevel
     */
    select?: LogLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLevelInclude<ExtArgs> | null
    /**
     * The filter to search for the LogLevel to update in case it exists.
     */
    where: LogLevelWhereUniqueInput
    /**
     * In case the LogLevel found by the `where` argument doesn't exist, create a new LogLevel with this data.
     */
    create: XOR<LogLevelCreateInput, LogLevelUncheckedCreateInput>
    /**
     * In case the LogLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogLevelUpdateInput, LogLevelUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LogLevel delete
   */
  export type LogLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLevel
     */
    select?: LogLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLevelInclude<ExtArgs> | null
    /**
     * Filter which LogLevel to delete.
     */
    where: LogLevelWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LogLevel deleteMany
   */
  export type LogLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogLevels to delete
     */
    where?: LogLevelWhereInput
  }


  /**
   * LogLevel.Log
   */
  export type LogLevel$LogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }


  /**
   * LogLevel without action
   */
  export type LogLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLevel
     */
    select?: LogLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLevelInclude<ExtArgs> | null
  }



  /**
   * Model LogType
   */

  export type AggregateLogType = {
    _count: LogTypeCountAggregateOutputType | null
    _avg: LogTypeAvgAggregateOutputType | null
    _sum: LogTypeSumAggregateOutputType | null
    _min: LogTypeMinAggregateOutputType | null
    _max: LogTypeMaxAggregateOutputType | null
  }

  export type LogTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type LogTypeSumAggregateOutputType = {
    id: number | null
  }

  export type LogTypeMinAggregateOutputType = {
    id: number | null
    type: string | null
  }

  export type LogTypeMaxAggregateOutputType = {
    id: number | null
    type: string | null
  }

  export type LogTypeCountAggregateOutputType = {
    id: number
    type: number
    _all: number
  }


  export type LogTypeAvgAggregateInputType = {
    id?: true
  }

  export type LogTypeSumAggregateInputType = {
    id?: true
  }

  export type LogTypeMinAggregateInputType = {
    id?: true
    type?: true
  }

  export type LogTypeMaxAggregateInputType = {
    id?: true
    type?: true
  }

  export type LogTypeCountAggregateInputType = {
    id?: true
    type?: true
    _all?: true
  }

  export type LogTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogType to aggregate.
     */
    where?: LogTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogTypes to fetch.
     */
    orderBy?: LogTypeOrderByWithRelationInput | LogTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogTypes
    **/
    _count?: true | LogTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogTypeMaxAggregateInputType
  }

  export type GetLogTypeAggregateType<T extends LogTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateLogType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogType[P]>
      : GetScalarType<T[P], AggregateLogType[P]>
  }




  export type LogTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogTypeWhereInput
    orderBy?: LogTypeOrderByWithAggregationInput | LogTypeOrderByWithAggregationInput[]
    by: LogTypeScalarFieldEnum[] | LogTypeScalarFieldEnum
    having?: LogTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogTypeCountAggregateInputType | true
    _avg?: LogTypeAvgAggregateInputType
    _sum?: LogTypeSumAggregateInputType
    _min?: LogTypeMinAggregateInputType
    _max?: LogTypeMaxAggregateInputType
  }

  export type LogTypeGroupByOutputType = {
    id: number
    type: string | null
    _count: LogTypeCountAggregateOutputType | null
    _avg: LogTypeAvgAggregateOutputType | null
    _sum: LogTypeSumAggregateOutputType | null
    _min: LogTypeMinAggregateOutputType | null
    _max: LogTypeMaxAggregateOutputType | null
  }

  type GetLogTypeGroupByPayload<T extends LogTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogTypeGroupByOutputType[P]>
            : GetScalarType<T[P], LogTypeGroupByOutputType[P]>
        }
      >
    >


  export type LogTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    Log?: boolean | LogType$LogArgs<ExtArgs>
    _count?: boolean | LogTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logType"]>

  export type LogTypeSelectScalar = {
    id?: boolean
    type?: boolean
  }

  export type LogTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Log?: boolean | LogType$LogArgs<ExtArgs>
    _count?: boolean | LogTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $LogTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogType"
    objects: {
      Log: Prisma.$LogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string | null
    }, ExtArgs["result"]["logType"]>
    composites: {}
  }


  type LogTypeGetPayload<S extends boolean | null | undefined | LogTypeDefaultArgs> = $Result.GetResult<Prisma.$LogTypePayload, S>

  type LogTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: LogTypeCountAggregateInputType | true
    }

  export interface LogTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogType'], meta: { name: 'LogType' } }
    /**
     * Find zero or one LogType that matches the filter.
     * @param {LogTypeFindUniqueArgs} args - Arguments to find a LogType
     * @example
     * // Get one LogType
     * const logType = await prisma.logType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__LogTypeClient<$Result.GetResult<Prisma.$LogTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LogType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogTypeFindUniqueOrThrowArgs} args - Arguments to find a LogType
     * @example
     * // Get one LogType
     * const logType = await prisma.logType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogTypeClient<$Result.GetResult<Prisma.$LogTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LogType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogTypeFindFirstArgs} args - Arguments to find a LogType
     * @example
     * // Get one LogType
     * const logType = await prisma.logType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogTypeFindFirstArgs<ExtArgs>>
    ): Prisma__LogTypeClient<$Result.GetResult<Prisma.$LogTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LogType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogTypeFindFirstOrThrowArgs} args - Arguments to find a LogType
     * @example
     * // Get one LogType
     * const logType = await prisma.logType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogTypeClient<$Result.GetResult<Prisma.$LogTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LogTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogTypes
     * const logTypes = await prisma.logType.findMany()
     * 
     * // Get first 10 LogTypes
     * const logTypes = await prisma.logType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logTypeWithIdOnly = await prisma.logType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LogType.
     * @param {LogTypeCreateArgs} args - Arguments to create a LogType.
     * @example
     * // Create one LogType
     * const LogType = await prisma.logType.create({
     *   data: {
     *     // ... data to create a LogType
     *   }
     * })
     * 
    **/
    create<T extends LogTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogTypeCreateArgs<ExtArgs>>
    ): Prisma__LogTypeClient<$Result.GetResult<Prisma.$LogTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LogTypes.
     *     @param {LogTypeCreateManyArgs} args - Arguments to create many LogTypes.
     *     @example
     *     // Create many LogTypes
     *     const logType = await prisma.logType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogType.
     * @param {LogTypeDeleteArgs} args - Arguments to delete one LogType.
     * @example
     * // Delete one LogType
     * const LogType = await prisma.logType.delete({
     *   where: {
     *     // ... filter to delete one LogType
     *   }
     * })
     * 
    **/
    delete<T extends LogTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogTypeDeleteArgs<ExtArgs>>
    ): Prisma__LogTypeClient<$Result.GetResult<Prisma.$LogTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LogType.
     * @param {LogTypeUpdateArgs} args - Arguments to update one LogType.
     * @example
     * // Update one LogType
     * const logType = await prisma.logType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogTypeUpdateArgs<ExtArgs>>
    ): Prisma__LogTypeClient<$Result.GetResult<Prisma.$LogTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LogTypes.
     * @param {LogTypeDeleteManyArgs} args - Arguments to filter LogTypes to delete.
     * @example
     * // Delete a few LogTypes
     * const { count } = await prisma.logType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogTypes
     * const logType = await prisma.logType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogType.
     * @param {LogTypeUpsertArgs} args - Arguments to update or create a LogType.
     * @example
     * // Update or create a LogType
     * const logType = await prisma.logType.upsert({
     *   create: {
     *     // ... data to create a LogType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogType we want to update
     *   }
     * })
    **/
    upsert<T extends LogTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogTypeUpsertArgs<ExtArgs>>
    ): Prisma__LogTypeClient<$Result.GetResult<Prisma.$LogTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LogTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogTypeCountArgs} args - Arguments to filter LogTypes to count.
     * @example
     * // Count the number of LogTypes
     * const count = await prisma.logType.count({
     *   where: {
     *     // ... the filter for the LogTypes we want to count
     *   }
     * })
    **/
    count<T extends LogTypeCountArgs>(
      args?: Subset<T, LogTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogTypeAggregateArgs>(args: Subset<T, LogTypeAggregateArgs>): Prisma.PrismaPromise<GetLogTypeAggregateType<T>>

    /**
     * Group by LogType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogTypeGroupByArgs['orderBy'] }
        : { orderBy?: LogTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogType model
   */
  readonly fields: LogTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Log<T extends LogType$LogArgs<ExtArgs> = {}>(args?: Subset<T, LogType$LogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LogType model
   */ 
  interface LogTypeFieldRefs {
    readonly id: FieldRef<"LogType", 'Int'>
    readonly type: FieldRef<"LogType", 'String'>
  }
    

  // Custom InputTypes

  /**
   * LogType findUnique
   */
  export type LogTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogType
     */
    select?: LogTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTypeInclude<ExtArgs> | null
    /**
     * Filter, which LogType to fetch.
     */
    where: LogTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LogType findUniqueOrThrow
   */
  export type LogTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogType
     */
    select?: LogTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTypeInclude<ExtArgs> | null
    /**
     * Filter, which LogType to fetch.
     */
    where: LogTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LogType findFirst
   */
  export type LogTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogType
     */
    select?: LogTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTypeInclude<ExtArgs> | null
    /**
     * Filter, which LogType to fetch.
     */
    where?: LogTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogTypes to fetch.
     */
    orderBy?: LogTypeOrderByWithRelationInput | LogTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogTypes.
     */
    cursor?: LogTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogTypes.
     */
    distinct?: LogTypeScalarFieldEnum | LogTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LogType findFirstOrThrow
   */
  export type LogTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogType
     */
    select?: LogTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTypeInclude<ExtArgs> | null
    /**
     * Filter, which LogType to fetch.
     */
    where?: LogTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogTypes to fetch.
     */
    orderBy?: LogTypeOrderByWithRelationInput | LogTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogTypes.
     */
    cursor?: LogTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogTypes.
     */
    distinct?: LogTypeScalarFieldEnum | LogTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LogType findMany
   */
  export type LogTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogType
     */
    select?: LogTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTypeInclude<ExtArgs> | null
    /**
     * Filter, which LogTypes to fetch.
     */
    where?: LogTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogTypes to fetch.
     */
    orderBy?: LogTypeOrderByWithRelationInput | LogTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogTypes.
     */
    cursor?: LogTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogTypes.
     */
    skip?: number
    distinct?: LogTypeScalarFieldEnum | LogTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LogType create
   */
  export type LogTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogType
     */
    select?: LogTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a LogType.
     */
    data: XOR<LogTypeCreateInput, LogTypeUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LogType createMany
   */
  export type LogTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogTypes.
     */
    data: LogTypeCreateManyInput | LogTypeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LogType update
   */
  export type LogTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogType
     */
    select?: LogTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a LogType.
     */
    data: XOR<LogTypeUpdateInput, LogTypeUncheckedUpdateInput>
    /**
     * Choose, which LogType to update.
     */
    where: LogTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LogType updateMany
   */
  export type LogTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogTypes.
     */
    data: XOR<LogTypeUpdateManyMutationInput, LogTypeUncheckedUpdateManyInput>
    /**
     * Filter which LogTypes to update
     */
    where?: LogTypeWhereInput
  }


  /**
   * LogType upsert
   */
  export type LogTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogType
     */
    select?: LogTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the LogType to update in case it exists.
     */
    where: LogTypeWhereUniqueInput
    /**
     * In case the LogType found by the `where` argument doesn't exist, create a new LogType with this data.
     */
    create: XOR<LogTypeCreateInput, LogTypeUncheckedCreateInput>
    /**
     * In case the LogType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogTypeUpdateInput, LogTypeUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LogType delete
   */
  export type LogTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogType
     */
    select?: LogTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTypeInclude<ExtArgs> | null
    /**
     * Filter which LogType to delete.
     */
    where: LogTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * LogType deleteMany
   */
  export type LogTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogTypes to delete
     */
    where?: LogTypeWhereInput
  }


  /**
   * LogType.Log
   */
  export type LogType$LogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }


  /**
   * LogType without action
   */
  export type LogTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogType
     */
    select?: LogTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTypeInclude<ExtArgs> | null
  }



  /**
   * Model SuspiciousLogin
   */

  export type AggregateSuspiciousLogin = {
    _count: SuspiciousLoginCountAggregateOutputType | null
    _avg: SuspiciousLoginAvgAggregateOutputType | null
    _sum: SuspiciousLoginSumAggregateOutputType | null
    _min: SuspiciousLoginMinAggregateOutputType | null
    _max: SuspiciousLoginMaxAggregateOutputType | null
  }

  export type SuspiciousLoginAvgAggregateOutputType = {
    id: number | null
    unverifiedAttempts: number | null
  }

  export type SuspiciousLoginSumAggregateOutputType = {
    id: number | null
    unverifiedAttempts: number | null
  }

  export type SuspiciousLoginMinAggregateOutputType = {
    id: number | null
    user: string | null
    ip: string | null
    country: string | null
    city: string | null
    os: string | null
    device: string | null
    deviceType: string | null
    isTrusted: boolean | null
    unverifiedAttempts: number | null
    isBlocked: boolean | null
  }

  export type SuspiciousLoginMaxAggregateOutputType = {
    id: number | null
    user: string | null
    ip: string | null
    country: string | null
    city: string | null
    os: string | null
    device: string | null
    deviceType: string | null
    isTrusted: boolean | null
    unverifiedAttempts: number | null
    isBlocked: boolean | null
  }

  export type SuspiciousLoginCountAggregateOutputType = {
    id: number
    user: number
    ip: number
    country: number
    city: number
    os: number
    device: number
    deviceType: number
    isTrusted: number
    unverifiedAttempts: number
    isBlocked: number
    _all: number
  }


  export type SuspiciousLoginAvgAggregateInputType = {
    id?: true
    unverifiedAttempts?: true
  }

  export type SuspiciousLoginSumAggregateInputType = {
    id?: true
    unverifiedAttempts?: true
  }

  export type SuspiciousLoginMinAggregateInputType = {
    id?: true
    user?: true
    ip?: true
    country?: true
    city?: true
    os?: true
    device?: true
    deviceType?: true
    isTrusted?: true
    unverifiedAttempts?: true
    isBlocked?: true
  }

  export type SuspiciousLoginMaxAggregateInputType = {
    id?: true
    user?: true
    ip?: true
    country?: true
    city?: true
    os?: true
    device?: true
    deviceType?: true
    isTrusted?: true
    unverifiedAttempts?: true
    isBlocked?: true
  }

  export type SuspiciousLoginCountAggregateInputType = {
    id?: true
    user?: true
    ip?: true
    country?: true
    city?: true
    os?: true
    device?: true
    deviceType?: true
    isTrusted?: true
    unverifiedAttempts?: true
    isBlocked?: true
    _all?: true
  }

  export type SuspiciousLoginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuspiciousLogin to aggregate.
     */
    where?: SuspiciousLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuspiciousLogins to fetch.
     */
    orderBy?: SuspiciousLoginOrderByWithRelationInput | SuspiciousLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuspiciousLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuspiciousLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuspiciousLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuspiciousLogins
    **/
    _count?: true | SuspiciousLoginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SuspiciousLoginAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SuspiciousLoginSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuspiciousLoginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuspiciousLoginMaxAggregateInputType
  }

  export type GetSuspiciousLoginAggregateType<T extends SuspiciousLoginAggregateArgs> = {
        [P in keyof T & keyof AggregateSuspiciousLogin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuspiciousLogin[P]>
      : GetScalarType<T[P], AggregateSuspiciousLogin[P]>
  }




  export type SuspiciousLoginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuspiciousLoginWhereInput
    orderBy?: SuspiciousLoginOrderByWithAggregationInput | SuspiciousLoginOrderByWithAggregationInput[]
    by: SuspiciousLoginScalarFieldEnum[] | SuspiciousLoginScalarFieldEnum
    having?: SuspiciousLoginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuspiciousLoginCountAggregateInputType | true
    _avg?: SuspiciousLoginAvgAggregateInputType
    _sum?: SuspiciousLoginSumAggregateInputType
    _min?: SuspiciousLoginMinAggregateInputType
    _max?: SuspiciousLoginMaxAggregateInputType
  }

  export type SuspiciousLoginGroupByOutputType = {
    id: number
    user: string | null
    ip: string | null
    country: string | null
    city: string | null
    os: string | null
    device: string | null
    deviceType: string | null
    isTrusted: boolean | null
    unverifiedAttempts: number | null
    isBlocked: boolean | null
    _count: SuspiciousLoginCountAggregateOutputType | null
    _avg: SuspiciousLoginAvgAggregateOutputType | null
    _sum: SuspiciousLoginSumAggregateOutputType | null
    _min: SuspiciousLoginMinAggregateOutputType | null
    _max: SuspiciousLoginMaxAggregateOutputType | null
  }

  type GetSuspiciousLoginGroupByPayload<T extends SuspiciousLoginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuspiciousLoginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuspiciousLoginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuspiciousLoginGroupByOutputType[P]>
            : GetScalarType<T[P], SuspiciousLoginGroupByOutputType[P]>
        }
      >
    >


  export type SuspiciousLoginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user?: boolean
    ip?: boolean
    country?: boolean
    city?: boolean
    os?: boolean
    device?: boolean
    deviceType?: boolean
    isTrusted?: boolean
    unverifiedAttempts?: boolean
    isBlocked?: boolean
  }, ExtArgs["result"]["suspiciousLogin"]>

  export type SuspiciousLoginSelectScalar = {
    id?: boolean
    user?: boolean
    ip?: boolean
    country?: boolean
    city?: boolean
    os?: boolean
    device?: boolean
    deviceType?: boolean
    isTrusted?: boolean
    unverifiedAttempts?: boolean
    isBlocked?: boolean
  }


  export type $SuspiciousLoginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SuspiciousLogin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user: string | null
      ip: string | null
      country: string | null
      city: string | null
      os: string | null
      device: string | null
      deviceType: string | null
      isTrusted: boolean | null
      unverifiedAttempts: number | null
      isBlocked: boolean | null
    }, ExtArgs["result"]["suspiciousLogin"]>
    composites: {}
  }


  type SuspiciousLoginGetPayload<S extends boolean | null | undefined | SuspiciousLoginDefaultArgs> = $Result.GetResult<Prisma.$SuspiciousLoginPayload, S>

  type SuspiciousLoginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SuspiciousLoginFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: SuspiciousLoginCountAggregateInputType | true
    }

  export interface SuspiciousLoginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SuspiciousLogin'], meta: { name: 'SuspiciousLogin' } }
    /**
     * Find zero or one SuspiciousLogin that matches the filter.
     * @param {SuspiciousLoginFindUniqueArgs} args - Arguments to find a SuspiciousLogin
     * @example
     * // Get one SuspiciousLogin
     * const suspiciousLogin = await prisma.suspiciousLogin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SuspiciousLoginFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SuspiciousLoginFindUniqueArgs<ExtArgs>>
    ): Prisma__SuspiciousLoginClient<$Result.GetResult<Prisma.$SuspiciousLoginPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SuspiciousLogin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SuspiciousLoginFindUniqueOrThrowArgs} args - Arguments to find a SuspiciousLogin
     * @example
     * // Get one SuspiciousLogin
     * const suspiciousLogin = await prisma.suspiciousLogin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SuspiciousLoginFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SuspiciousLoginFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SuspiciousLoginClient<$Result.GetResult<Prisma.$SuspiciousLoginPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SuspiciousLogin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuspiciousLoginFindFirstArgs} args - Arguments to find a SuspiciousLogin
     * @example
     * // Get one SuspiciousLogin
     * const suspiciousLogin = await prisma.suspiciousLogin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SuspiciousLoginFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SuspiciousLoginFindFirstArgs<ExtArgs>>
    ): Prisma__SuspiciousLoginClient<$Result.GetResult<Prisma.$SuspiciousLoginPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SuspiciousLogin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuspiciousLoginFindFirstOrThrowArgs} args - Arguments to find a SuspiciousLogin
     * @example
     * // Get one SuspiciousLogin
     * const suspiciousLogin = await prisma.suspiciousLogin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SuspiciousLoginFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SuspiciousLoginFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SuspiciousLoginClient<$Result.GetResult<Prisma.$SuspiciousLoginPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SuspiciousLogins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuspiciousLoginFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuspiciousLogins
     * const suspiciousLogins = await prisma.suspiciousLogin.findMany()
     * 
     * // Get first 10 SuspiciousLogins
     * const suspiciousLogins = await prisma.suspiciousLogin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const suspiciousLoginWithIdOnly = await prisma.suspiciousLogin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SuspiciousLoginFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SuspiciousLoginFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuspiciousLoginPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SuspiciousLogin.
     * @param {SuspiciousLoginCreateArgs} args - Arguments to create a SuspiciousLogin.
     * @example
     * // Create one SuspiciousLogin
     * const SuspiciousLogin = await prisma.suspiciousLogin.create({
     *   data: {
     *     // ... data to create a SuspiciousLogin
     *   }
     * })
     * 
    **/
    create<T extends SuspiciousLoginCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SuspiciousLoginCreateArgs<ExtArgs>>
    ): Prisma__SuspiciousLoginClient<$Result.GetResult<Prisma.$SuspiciousLoginPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SuspiciousLogins.
     *     @param {SuspiciousLoginCreateManyArgs} args - Arguments to create many SuspiciousLogins.
     *     @example
     *     // Create many SuspiciousLogins
     *     const suspiciousLogin = await prisma.suspiciousLogin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SuspiciousLoginCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SuspiciousLoginCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SuspiciousLogin.
     * @param {SuspiciousLoginDeleteArgs} args - Arguments to delete one SuspiciousLogin.
     * @example
     * // Delete one SuspiciousLogin
     * const SuspiciousLogin = await prisma.suspiciousLogin.delete({
     *   where: {
     *     // ... filter to delete one SuspiciousLogin
     *   }
     * })
     * 
    **/
    delete<T extends SuspiciousLoginDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SuspiciousLoginDeleteArgs<ExtArgs>>
    ): Prisma__SuspiciousLoginClient<$Result.GetResult<Prisma.$SuspiciousLoginPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SuspiciousLogin.
     * @param {SuspiciousLoginUpdateArgs} args - Arguments to update one SuspiciousLogin.
     * @example
     * // Update one SuspiciousLogin
     * const suspiciousLogin = await prisma.suspiciousLogin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SuspiciousLoginUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SuspiciousLoginUpdateArgs<ExtArgs>>
    ): Prisma__SuspiciousLoginClient<$Result.GetResult<Prisma.$SuspiciousLoginPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SuspiciousLogins.
     * @param {SuspiciousLoginDeleteManyArgs} args - Arguments to filter SuspiciousLogins to delete.
     * @example
     * // Delete a few SuspiciousLogins
     * const { count } = await prisma.suspiciousLogin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SuspiciousLoginDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SuspiciousLoginDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuspiciousLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuspiciousLoginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuspiciousLogins
     * const suspiciousLogin = await prisma.suspiciousLogin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SuspiciousLoginUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SuspiciousLoginUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SuspiciousLogin.
     * @param {SuspiciousLoginUpsertArgs} args - Arguments to update or create a SuspiciousLogin.
     * @example
     * // Update or create a SuspiciousLogin
     * const suspiciousLogin = await prisma.suspiciousLogin.upsert({
     *   create: {
     *     // ... data to create a SuspiciousLogin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuspiciousLogin we want to update
     *   }
     * })
    **/
    upsert<T extends SuspiciousLoginUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SuspiciousLoginUpsertArgs<ExtArgs>>
    ): Prisma__SuspiciousLoginClient<$Result.GetResult<Prisma.$SuspiciousLoginPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SuspiciousLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuspiciousLoginCountArgs} args - Arguments to filter SuspiciousLogins to count.
     * @example
     * // Count the number of SuspiciousLogins
     * const count = await prisma.suspiciousLogin.count({
     *   where: {
     *     // ... the filter for the SuspiciousLogins we want to count
     *   }
     * })
    **/
    count<T extends SuspiciousLoginCountArgs>(
      args?: Subset<T, SuspiciousLoginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuspiciousLoginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuspiciousLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuspiciousLoginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuspiciousLoginAggregateArgs>(args: Subset<T, SuspiciousLoginAggregateArgs>): Prisma.PrismaPromise<GetSuspiciousLoginAggregateType<T>>

    /**
     * Group by SuspiciousLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuspiciousLoginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuspiciousLoginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuspiciousLoginGroupByArgs['orderBy'] }
        : { orderBy?: SuspiciousLoginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuspiciousLoginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuspiciousLoginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SuspiciousLogin model
   */
  readonly fields: SuspiciousLoginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SuspiciousLogin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuspiciousLoginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SuspiciousLogin model
   */ 
  interface SuspiciousLoginFieldRefs {
    readonly id: FieldRef<"SuspiciousLogin", 'Int'>
    readonly user: FieldRef<"SuspiciousLogin", 'String'>
    readonly ip: FieldRef<"SuspiciousLogin", 'String'>
    readonly country: FieldRef<"SuspiciousLogin", 'String'>
    readonly city: FieldRef<"SuspiciousLogin", 'String'>
    readonly os: FieldRef<"SuspiciousLogin", 'String'>
    readonly device: FieldRef<"SuspiciousLogin", 'String'>
    readonly deviceType: FieldRef<"SuspiciousLogin", 'String'>
    readonly isTrusted: FieldRef<"SuspiciousLogin", 'Boolean'>
    readonly unverifiedAttempts: FieldRef<"SuspiciousLogin", 'Int'>
    readonly isBlocked: FieldRef<"SuspiciousLogin", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * SuspiciousLogin findUnique
   */
  export type SuspiciousLoginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuspiciousLogin
     */
    select?: SuspiciousLoginSelect<ExtArgs> | null
    /**
     * Filter, which SuspiciousLogin to fetch.
     */
    where: SuspiciousLoginWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * SuspiciousLogin findUniqueOrThrow
   */
  export type SuspiciousLoginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuspiciousLogin
     */
    select?: SuspiciousLoginSelect<ExtArgs> | null
    /**
     * Filter, which SuspiciousLogin to fetch.
     */
    where: SuspiciousLoginWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * SuspiciousLogin findFirst
   */
  export type SuspiciousLoginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuspiciousLogin
     */
    select?: SuspiciousLoginSelect<ExtArgs> | null
    /**
     * Filter, which SuspiciousLogin to fetch.
     */
    where?: SuspiciousLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuspiciousLogins to fetch.
     */
    orderBy?: SuspiciousLoginOrderByWithRelationInput | SuspiciousLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuspiciousLogins.
     */
    cursor?: SuspiciousLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuspiciousLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuspiciousLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuspiciousLogins.
     */
    distinct?: SuspiciousLoginScalarFieldEnum | SuspiciousLoginScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * SuspiciousLogin findFirstOrThrow
   */
  export type SuspiciousLoginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuspiciousLogin
     */
    select?: SuspiciousLoginSelect<ExtArgs> | null
    /**
     * Filter, which SuspiciousLogin to fetch.
     */
    where?: SuspiciousLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuspiciousLogins to fetch.
     */
    orderBy?: SuspiciousLoginOrderByWithRelationInput | SuspiciousLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuspiciousLogins.
     */
    cursor?: SuspiciousLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuspiciousLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuspiciousLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuspiciousLogins.
     */
    distinct?: SuspiciousLoginScalarFieldEnum | SuspiciousLoginScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * SuspiciousLogin findMany
   */
  export type SuspiciousLoginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuspiciousLogin
     */
    select?: SuspiciousLoginSelect<ExtArgs> | null
    /**
     * Filter, which SuspiciousLogins to fetch.
     */
    where?: SuspiciousLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuspiciousLogins to fetch.
     */
    orderBy?: SuspiciousLoginOrderByWithRelationInput | SuspiciousLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuspiciousLogins.
     */
    cursor?: SuspiciousLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuspiciousLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuspiciousLogins.
     */
    skip?: number
    distinct?: SuspiciousLoginScalarFieldEnum | SuspiciousLoginScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * SuspiciousLogin create
   */
  export type SuspiciousLoginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuspiciousLogin
     */
    select?: SuspiciousLoginSelect<ExtArgs> | null
    /**
     * The data needed to create a SuspiciousLogin.
     */
    data?: XOR<SuspiciousLoginCreateInput, SuspiciousLoginUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * SuspiciousLogin createMany
   */
  export type SuspiciousLoginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SuspiciousLogins.
     */
    data: SuspiciousLoginCreateManyInput | SuspiciousLoginCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SuspiciousLogin update
   */
  export type SuspiciousLoginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuspiciousLogin
     */
    select?: SuspiciousLoginSelect<ExtArgs> | null
    /**
     * The data needed to update a SuspiciousLogin.
     */
    data: XOR<SuspiciousLoginUpdateInput, SuspiciousLoginUncheckedUpdateInput>
    /**
     * Choose, which SuspiciousLogin to update.
     */
    where: SuspiciousLoginWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * SuspiciousLogin updateMany
   */
  export type SuspiciousLoginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SuspiciousLogins.
     */
    data: XOR<SuspiciousLoginUpdateManyMutationInput, SuspiciousLoginUncheckedUpdateManyInput>
    /**
     * Filter which SuspiciousLogins to update
     */
    where?: SuspiciousLoginWhereInput
  }


  /**
   * SuspiciousLogin upsert
   */
  export type SuspiciousLoginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuspiciousLogin
     */
    select?: SuspiciousLoginSelect<ExtArgs> | null
    /**
     * The filter to search for the SuspiciousLogin to update in case it exists.
     */
    where: SuspiciousLoginWhereUniqueInput
    /**
     * In case the SuspiciousLogin found by the `where` argument doesn't exist, create a new SuspiciousLogin with this data.
     */
    create: XOR<SuspiciousLoginCreateInput, SuspiciousLoginUncheckedCreateInput>
    /**
     * In case the SuspiciousLogin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuspiciousLoginUpdateInput, SuspiciousLoginUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * SuspiciousLogin delete
   */
  export type SuspiciousLoginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuspiciousLogin
     */
    select?: SuspiciousLoginSelect<ExtArgs> | null
    /**
     * Filter which SuspiciousLogin to delete.
     */
    where: SuspiciousLoginWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * SuspiciousLogin deleteMany
   */
  export type SuspiciousLoginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuspiciousLogins to delete
     */
    where?: SuspiciousLoginWhereInput
  }


  /**
   * SuspiciousLogin without action
   */
  export type SuspiciousLoginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuspiciousLogin
     */
    select?: SuspiciousLoginSelect<ExtArgs> | null
  }



  /**
   * Model CommunityUser
   */

  export type AggregateCommunityUser = {
    _count: CommunityUserCountAggregateOutputType | null
    _avg: CommunityUserAvgAggregateOutputType | null
    _sum: CommunityUserSumAggregateOutputType | null
    _min: CommunityUserMinAggregateOutputType | null
    _max: CommunityUserMaxAggregateOutputType | null
  }

  export type CommunityUserAvgAggregateOutputType = {
    id: number | null
    community: number | null
    role: number | null
  }

  export type CommunityUserSumAggregateOutputType = {
    id: number | null
    community: number | null
    role: number | null
  }

  export type CommunityUserMinAggregateOutputType = {
    id: number | null
    community: number | null
    user: string | null
    role: number | null
    verifiedAt: Date | null
  }

  export type CommunityUserMaxAggregateOutputType = {
    id: number | null
    community: number | null
    user: string | null
    role: number | null
    verifiedAt: Date | null
  }

  export type CommunityUserCountAggregateOutputType = {
    id: number
    community: number
    user: number
    role: number
    verifiedAt: number
    _all: number
  }


  export type CommunityUserAvgAggregateInputType = {
    id?: true
    community?: true
    role?: true
  }

  export type CommunityUserSumAggregateInputType = {
    id?: true
    community?: true
    role?: true
  }

  export type CommunityUserMinAggregateInputType = {
    id?: true
    community?: true
    user?: true
    role?: true
    verifiedAt?: true
  }

  export type CommunityUserMaxAggregateInputType = {
    id?: true
    community?: true
    user?: true
    role?: true
    verifiedAt?: true
  }

  export type CommunityUserCountAggregateInputType = {
    id?: true
    community?: true
    user?: true
    role?: true
    verifiedAt?: true
    _all?: true
  }

  export type CommunityUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityUser to aggregate.
     */
    where?: CommunityUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityUsers to fetch.
     */
    orderBy?: CommunityUserOrderByWithRelationInput | CommunityUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityUsers
    **/
    _count?: true | CommunityUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityUserMaxAggregateInputType
  }

  export type GetCommunityUserAggregateType<T extends CommunityUserAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityUser[P]>
      : GetScalarType<T[P], AggregateCommunityUser[P]>
  }




  export type CommunityUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityUserWhereInput
    orderBy?: CommunityUserOrderByWithAggregationInput | CommunityUserOrderByWithAggregationInput[]
    by: CommunityUserScalarFieldEnum[] | CommunityUserScalarFieldEnum
    having?: CommunityUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityUserCountAggregateInputType | true
    _avg?: CommunityUserAvgAggregateInputType
    _sum?: CommunityUserSumAggregateInputType
    _min?: CommunityUserMinAggregateInputType
    _max?: CommunityUserMaxAggregateInputType
  }

  export type CommunityUserGroupByOutputType = {
    id: number
    community: number
    user: string
    role: number
    verifiedAt: Date | null
    _count: CommunityUserCountAggregateOutputType | null
    _avg: CommunityUserAvgAggregateOutputType | null
    _sum: CommunityUserSumAggregateOutputType | null
    _min: CommunityUserMinAggregateOutputType | null
    _max: CommunityUserMaxAggregateOutputType | null
  }

  type GetCommunityUserGroupByPayload<T extends CommunityUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityUserGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityUserGroupByOutputType[P]>
        }
      >
    >


  export type CommunityUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    community?: boolean
    user?: boolean
    role?: boolean
    verifiedAt?: boolean
    Community?: boolean | CommunityDefaultArgs<ExtArgs>
    UserRoles?: boolean | UserRolesDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityUser"]>

  export type CommunityUserSelectScalar = {
    id?: boolean
    community?: boolean
    user?: boolean
    role?: boolean
    verifiedAt?: boolean
  }

  export type CommunityUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Community?: boolean | CommunityDefaultArgs<ExtArgs>
    UserRoles?: boolean | UserRolesDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $CommunityUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityUser"
    objects: {
      Community: Prisma.$CommunityPayload<ExtArgs>
      UserRoles: Prisma.$UserRolesPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      community: number
      user: string
      role: number
      verifiedAt: Date | null
    }, ExtArgs["result"]["communityUser"]>
    composites: {}
  }


  type CommunityUserGetPayload<S extends boolean | null | undefined | CommunityUserDefaultArgs> = $Result.GetResult<Prisma.$CommunityUserPayload, S>

  type CommunityUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommunityUserFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: CommunityUserCountAggregateInputType | true
    }

  export interface CommunityUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityUser'], meta: { name: 'CommunityUser' } }
    /**
     * Find zero or one CommunityUser that matches the filter.
     * @param {CommunityUserFindUniqueArgs} args - Arguments to find a CommunityUser
     * @example
     * // Get one CommunityUser
     * const communityUser = await prisma.communityUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityUserFindUniqueArgs<ExtArgs>>
    ): Prisma__CommunityUserClient<$Result.GetResult<Prisma.$CommunityUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CommunityUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommunityUserFindUniqueOrThrowArgs} args - Arguments to find a CommunityUser
     * @example
     * // Get one CommunityUser
     * const communityUser = await prisma.communityUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommunityUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityUserClient<$Result.GetResult<Prisma.$CommunityUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CommunityUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityUserFindFirstArgs} args - Arguments to find a CommunityUser
     * @example
     * // Get one CommunityUser
     * const communityUser = await prisma.communityUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityUserFindFirstArgs<ExtArgs>>
    ): Prisma__CommunityUserClient<$Result.GetResult<Prisma.$CommunityUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CommunityUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityUserFindFirstOrThrowArgs} args - Arguments to find a CommunityUser
     * @example
     * // Get one CommunityUser
     * const communityUser = await prisma.communityUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommunityUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityUserClient<$Result.GetResult<Prisma.$CommunityUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CommunityUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityUsers
     * const communityUsers = await prisma.communityUser.findMany()
     * 
     * // Get first 10 CommunityUsers
     * const communityUsers = await prisma.communityUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityUserWithIdOnly = await prisma.communityUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunityUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CommunityUser.
     * @param {CommunityUserCreateArgs} args - Arguments to create a CommunityUser.
     * @example
     * // Create one CommunityUser
     * const CommunityUser = await prisma.communityUser.create({
     *   data: {
     *     // ... data to create a CommunityUser
     *   }
     * })
     * 
    **/
    create<T extends CommunityUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityUserCreateArgs<ExtArgs>>
    ): Prisma__CommunityUserClient<$Result.GetResult<Prisma.$CommunityUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CommunityUsers.
     *     @param {CommunityUserCreateManyArgs} args - Arguments to create many CommunityUsers.
     *     @example
     *     // Create many CommunityUsers
     *     const communityUser = await prisma.communityUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunityUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommunityUser.
     * @param {CommunityUserDeleteArgs} args - Arguments to delete one CommunityUser.
     * @example
     * // Delete one CommunityUser
     * const CommunityUser = await prisma.communityUser.delete({
     *   where: {
     *     // ... filter to delete one CommunityUser
     *   }
     * })
     * 
    **/
    delete<T extends CommunityUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityUserDeleteArgs<ExtArgs>>
    ): Prisma__CommunityUserClient<$Result.GetResult<Prisma.$CommunityUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CommunityUser.
     * @param {CommunityUserUpdateArgs} args - Arguments to update one CommunityUser.
     * @example
     * // Update one CommunityUser
     * const communityUser = await prisma.communityUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityUserUpdateArgs<ExtArgs>>
    ): Prisma__CommunityUserClient<$Result.GetResult<Prisma.$CommunityUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CommunityUsers.
     * @param {CommunityUserDeleteManyArgs} args - Arguments to filter CommunityUsers to delete.
     * @example
     * // Delete a few CommunityUsers
     * const { count } = await prisma.communityUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityUsers
     * const communityUser = await prisma.communityUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityUser.
     * @param {CommunityUserUpsertArgs} args - Arguments to update or create a CommunityUser.
     * @example
     * // Update or create a CommunityUser
     * const communityUser = await prisma.communityUser.upsert({
     *   create: {
     *     // ... data to create a CommunityUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityUser we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityUserUpsertArgs<ExtArgs>>
    ): Prisma__CommunityUserClient<$Result.GetResult<Prisma.$CommunityUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CommunityUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityUserCountArgs} args - Arguments to filter CommunityUsers to count.
     * @example
     * // Count the number of CommunityUsers
     * const count = await prisma.communityUser.count({
     *   where: {
     *     // ... the filter for the CommunityUsers we want to count
     *   }
     * })
    **/
    count<T extends CommunityUserCountArgs>(
      args?: Subset<T, CommunityUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityUserAggregateArgs>(args: Subset<T, CommunityUserAggregateArgs>): Prisma.PrismaPromise<GetCommunityUserAggregateType<T>>

    /**
     * Group by CommunityUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityUserGroupByArgs['orderBy'] }
        : { orderBy?: CommunityUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityUser model
   */
  readonly fields: CommunityUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Community<T extends CommunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityDefaultArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    UserRoles<T extends UserRolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserRolesDefaultArgs<ExtArgs>>): Prisma__UserRolesClient<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CommunityUser model
   */ 
  interface CommunityUserFieldRefs {
    readonly id: FieldRef<"CommunityUser", 'Int'>
    readonly community: FieldRef<"CommunityUser", 'Int'>
    readonly user: FieldRef<"CommunityUser", 'String'>
    readonly role: FieldRef<"CommunityUser", 'Int'>
    readonly verifiedAt: FieldRef<"CommunityUser", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CommunityUser findUnique
   */
  export type CommunityUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityUser
     */
    select?: CommunityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityUserInclude<ExtArgs> | null
    /**
     * Filter, which CommunityUser to fetch.
     */
    where: CommunityUserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * CommunityUser findUniqueOrThrow
   */
  export type CommunityUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityUser
     */
    select?: CommunityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityUserInclude<ExtArgs> | null
    /**
     * Filter, which CommunityUser to fetch.
     */
    where: CommunityUserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * CommunityUser findFirst
   */
  export type CommunityUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityUser
     */
    select?: CommunityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityUserInclude<ExtArgs> | null
    /**
     * Filter, which CommunityUser to fetch.
     */
    where?: CommunityUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityUsers to fetch.
     */
    orderBy?: CommunityUserOrderByWithRelationInput | CommunityUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityUsers.
     */
    cursor?: CommunityUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityUsers.
     */
    distinct?: CommunityUserScalarFieldEnum | CommunityUserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * CommunityUser findFirstOrThrow
   */
  export type CommunityUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityUser
     */
    select?: CommunityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityUserInclude<ExtArgs> | null
    /**
     * Filter, which CommunityUser to fetch.
     */
    where?: CommunityUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityUsers to fetch.
     */
    orderBy?: CommunityUserOrderByWithRelationInput | CommunityUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityUsers.
     */
    cursor?: CommunityUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityUsers.
     */
    distinct?: CommunityUserScalarFieldEnum | CommunityUserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * CommunityUser findMany
   */
  export type CommunityUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityUser
     */
    select?: CommunityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityUserInclude<ExtArgs> | null
    /**
     * Filter, which CommunityUsers to fetch.
     */
    where?: CommunityUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityUsers to fetch.
     */
    orderBy?: CommunityUserOrderByWithRelationInput | CommunityUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityUsers.
     */
    cursor?: CommunityUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityUsers.
     */
    skip?: number
    distinct?: CommunityUserScalarFieldEnum | CommunityUserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * CommunityUser create
   */
  export type CommunityUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityUser
     */
    select?: CommunityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityUserInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityUser.
     */
    data: XOR<CommunityUserCreateInput, CommunityUserUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * CommunityUser createMany
   */
  export type CommunityUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityUsers.
     */
    data: CommunityUserCreateManyInput | CommunityUserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CommunityUser update
   */
  export type CommunityUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityUser
     */
    select?: CommunityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityUserInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityUser.
     */
    data: XOR<CommunityUserUpdateInput, CommunityUserUncheckedUpdateInput>
    /**
     * Choose, which CommunityUser to update.
     */
    where: CommunityUserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * CommunityUser updateMany
   */
  export type CommunityUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityUsers.
     */
    data: XOR<CommunityUserUpdateManyMutationInput, CommunityUserUncheckedUpdateManyInput>
    /**
     * Filter which CommunityUsers to update
     */
    where?: CommunityUserWhereInput
  }


  /**
   * CommunityUser upsert
   */
  export type CommunityUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityUser
     */
    select?: CommunityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityUserInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityUser to update in case it exists.
     */
    where: CommunityUserWhereUniqueInput
    /**
     * In case the CommunityUser found by the `where` argument doesn't exist, create a new CommunityUser with this data.
     */
    create: XOR<CommunityUserCreateInput, CommunityUserUncheckedCreateInput>
    /**
     * In case the CommunityUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityUserUpdateInput, CommunityUserUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * CommunityUser delete
   */
  export type CommunityUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityUser
     */
    select?: CommunityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityUserInclude<ExtArgs> | null
    /**
     * Filter which CommunityUser to delete.
     */
    where: CommunityUserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }


  /**
   * CommunityUser deleteMany
   */
  export type CommunityUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityUsers to delete
     */
    where?: CommunityUserWhereInput
  }


  /**
   * CommunityUser without action
   */
  export type CommunityUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityUser
     */
    select?: CommunityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityUserInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const RelationLoadStrategy: {
    query: 'query',
    join: 'join'
  };

  export type RelationLoadStrategy = (typeof RelationLoadStrategy)[keyof typeof RelationLoadStrategy]


  export const AdminTokenScalarFieldEnum: {
    id: 'id',
    user: 'user',
    accessToken: 'accessToken'
  };

  export type AdminTokenScalarFieldEnum = (typeof AdminTokenScalarFieldEnum)[keyof typeof AdminTokenScalarFieldEnum]


  export const BannedUsersScalarFieldEnum: {
    id: 'id',
    community: 'community',
    user: 'user',
    reasonId: 'reasonId'
  };

  export type BannedUsersScalarFieldEnum = (typeof BannedUsersScalarFieldEnum)[keyof typeof BannedUsersScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    body: 'body',
    user: 'user',
    post: 'post'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const CommunityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type CommunityScalarFieldEnum = (typeof CommunityScalarFieldEnum)[keyof typeof CommunityScalarFieldEnum]


  export const CommunityRequestScalarFieldEnum: {
    id: 'id',
    user: 'user',
    community: 'community',
    requestedAt: 'requestedAt',
    message: 'message'
  };

  export type CommunityRequestScalarFieldEnum = (typeof CommunityRequestScalarFieldEnum)[keyof typeof CommunityRequestScalarFieldEnum]


  export const ContextScalarFieldEnum: {
    id: 'id',
    user: 'user',
    ip: 'ip',
    country: 'country',
    city: 'city',
    os: 'os',
    device: 'device',
    deviceType: 'deviceType',
    isTrusted: 'isTrusted'
  };

  export type ContextScalarFieldEnum = (typeof ContextScalarFieldEnum)[keyof typeof ContextScalarFieldEnum]


  export const LikeScalarFieldEnum: {
    id: 'id',
    user: 'user',
    post: 'post'
  };

  export type LikeScalarFieldEnum = (typeof LikeScalarFieldEnum)[keyof typeof LikeScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    user: 'user',
    context: 'context',
    message: 'message',
    type: 'type',
    level: 'level',
    timestamp: 'timestamp'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const PendingPostScalarFieldEnum: {
    id: 'id',
    Content: 'Content',
    fileUrl: 'fileUrl',
    community: 'community',
    user: 'user',
    caption: 'caption',
    status: 'status',
    confirmationToken: 'confirmationToken'
  };

  export type PendingPostScalarFieldEnum = (typeof PendingPostScalarFieldEnum)[keyof typeof PendingPostScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    Content: 'Content',
    fileUrl: 'fileUrl',
    community: 'community',
    user: 'user',
    caption: 'caption'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const PreferencesScalarFieldEnum: {
    id: 'id',
    user: 'user',
    enableContextBasedAuth: 'enableContextBasedAuth'
  };

  export type PreferencesScalarFieldEnum = (typeof PreferencesScalarFieldEnum)[keyof typeof PreferencesScalarFieldEnum]


  export const RelationshipScalarFieldEnum: {
    id: 'id',
    follower: 'follower',
    following: 'following'
  };

  export type RelationshipScalarFieldEnum = (typeof RelationshipScalarFieldEnum)[keyof typeof RelationshipScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    reportedBy: 'reportedBy',
    post: 'post',
    community: 'community',
    reportReason: 'reportReason',
    reportDate: 'reportDate'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const TokenScalarFieldEnum: {
    id: 'id',
    user: 'user',
    refreshToken: 'refreshToken',
    accessToken: 'accessToken',
    createdAt: 'createdAt'
  };

  export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    password: 'password',
    avatarUrl: 'avatarUrl',
    bio: 'bio',
    createdAt: 'createdAt',
    isEmailVerified: 'isEmailVerified',
    height: 'height',
    weight: 'weight',
    age: 'age'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserRolesScalarFieldEnum: {
    id: 'id',
    role: 'role'
  };

  export type UserRolesScalarFieldEnum = (typeof UserRolesScalarFieldEnum)[keyof typeof UserRolesScalarFieldEnum]


  export const EmailScalarFieldEnum: {
    id: 'id',
    email: 'email',
    verificationCode: 'verificationCode',
    messageId: 'messageId',
    for: 'for',
    createdAt: 'createdAt'
  };

  export type EmailScalarFieldEnum = (typeof EmailScalarFieldEnum)[keyof typeof EmailScalarFieldEnum]


  export const EmailForScalarFieldEnum: {
    id: 'id',
    for: 'for'
  };

  export type EmailForScalarFieldEnum = (typeof EmailForScalarFieldEnum)[keyof typeof EmailForScalarFieldEnum]


  export const LeaderboardScalarFieldEnum: {
    id: 'id',
    community: 'community'
  };

  export type LeaderboardScalarFieldEnum = (typeof LeaderboardScalarFieldEnum)[keyof typeof LeaderboardScalarFieldEnum]


  export const LeaderboardSubmissionScalarFieldEnum: {
    id: 'id',
    user: 'user',
    community: 'community',
    entryUrl: 'entryUrl',
    verifiedBy: 'verifiedBy',
    weight: 'weight',
    type: 'type',
    verifiedAt: 'verifiedAt',
    rank: 'rank',
    leaderboardId: 'leaderboardId'
  };

  export type LeaderboardSubmissionScalarFieldEnum = (typeof LeaderboardSubmissionScalarFieldEnum)[keyof typeof LeaderboardSubmissionScalarFieldEnum]


  export const LeaderboardSubmissionTypeScalarFieldEnum: {
    id: 'id',
    type: 'type',
    leaderboardSubmissionId: 'leaderboardSubmissionId'
  };

  export type LeaderboardSubmissionTypeScalarFieldEnum = (typeof LeaderboardSubmissionTypeScalarFieldEnum)[keyof typeof LeaderboardSubmissionTypeScalarFieldEnum]


  export const PendingPostStatusScalarFieldEnum: {
    id: 'id',
    status: 'status'
  };

  export type PendingPostStatusScalarFieldEnum = (typeof PendingPostStatusScalarFieldEnum)[keyof typeof PendingPostStatusScalarFieldEnum]


  export const LogLevelScalarFieldEnum: {
    id: 'id',
    level: 'level'
  };

  export type LogLevelScalarFieldEnum = (typeof LogLevelScalarFieldEnum)[keyof typeof LogLevelScalarFieldEnum]


  export const LogTypeScalarFieldEnum: {
    id: 'id',
    type: 'type'
  };

  export type LogTypeScalarFieldEnum = (typeof LogTypeScalarFieldEnum)[keyof typeof LogTypeScalarFieldEnum]


  export const SuspiciousLoginScalarFieldEnum: {
    id: 'id',
    user: 'user',
    ip: 'ip',
    country: 'country',
    city: 'city',
    os: 'os',
    device: 'device',
    deviceType: 'deviceType',
    isTrusted: 'isTrusted',
    unverifiedAttempts: 'unverifiedAttempts',
    isBlocked: 'isBlocked'
  };

  export type SuspiciousLoginScalarFieldEnum = (typeof SuspiciousLoginScalarFieldEnum)[keyof typeof SuspiciousLoginScalarFieldEnum]


  export const CommunityUserScalarFieldEnum: {
    id: 'id',
    community: 'community',
    user: 'user',
    role: 'role',
    verifiedAt: 'verifiedAt'
  };

  export type CommunityUserScalarFieldEnum = (typeof CommunityUserScalarFieldEnum)[keyof typeof CommunityUserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    username?: StringNullableFilter<"Admin"> | string | null
    password?: StringNullableFilter<"Admin"> | string | null
    AdminToken?: XOR<AdminTokenNullableRelationFilter, AdminTokenWhereInput> | null
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    AdminToken?: AdminTokenOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    password?: StringNullableFilter<"Admin"> | string | null
    AdminToken?: XOR<AdminTokenNullableRelationFilter, AdminTokenWhereInput> | null
  }, "id" | "username">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    username?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    password?: StringNullableWithAggregatesFilter<"Admin"> | string | null
  }

  export type AdminTokenWhereInput = {
    AND?: AdminTokenWhereInput | AdminTokenWhereInput[]
    OR?: AdminTokenWhereInput[]
    NOT?: AdminTokenWhereInput | AdminTokenWhereInput[]
    id?: IntFilter<"AdminToken"> | number
    user?: StringFilter<"AdminToken"> | string
    accessToken?: StringNullableFilter<"AdminToken"> | string | null
    Admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
  }

  export type AdminTokenOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    Admin?: AdminOrderByWithRelationInput
  }

  export type AdminTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user?: string
    AND?: AdminTokenWhereInput | AdminTokenWhereInput[]
    OR?: AdminTokenWhereInput[]
    NOT?: AdminTokenWhereInput | AdminTokenWhereInput[]
    accessToken?: StringNullableFilter<"AdminToken"> | string | null
    Admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
  }, "id" | "user">

  export type AdminTokenOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    _count?: AdminTokenCountOrderByAggregateInput
    _avg?: AdminTokenAvgOrderByAggregateInput
    _max?: AdminTokenMaxOrderByAggregateInput
    _min?: AdminTokenMinOrderByAggregateInput
    _sum?: AdminTokenSumOrderByAggregateInput
  }

  export type AdminTokenScalarWhereWithAggregatesInput = {
    AND?: AdminTokenScalarWhereWithAggregatesInput | AdminTokenScalarWhereWithAggregatesInput[]
    OR?: AdminTokenScalarWhereWithAggregatesInput[]
    NOT?: AdminTokenScalarWhereWithAggregatesInput | AdminTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AdminToken"> | number
    user?: StringWithAggregatesFilter<"AdminToken"> | string
    accessToken?: StringNullableWithAggregatesFilter<"AdminToken"> | string | null
  }

  export type BannedUsersWhereInput = {
    AND?: BannedUsersWhereInput | BannedUsersWhereInput[]
    OR?: BannedUsersWhereInput[]
    NOT?: BannedUsersWhereInput | BannedUsersWhereInput[]
    id?: IntFilter<"BannedUsers"> | number
    community?: IntFilter<"BannedUsers"> | number
    user?: StringFilter<"BannedUsers"> | string
    reasonId?: IntNullableFilter<"BannedUsers"> | number | null
    Community?: XOR<CommunityNullableRelationFilter, CommunityWhereInput> | null
  }

  export type BannedUsersOrderByWithRelationInput = {
    id?: SortOrder
    community?: SortOrder
    user?: SortOrder
    reasonId?: SortOrderInput | SortOrder
    Community?: CommunityOrderByWithRelationInput
  }

  export type BannedUsersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BannedUsersWhereInput | BannedUsersWhereInput[]
    OR?: BannedUsersWhereInput[]
    NOT?: BannedUsersWhereInput | BannedUsersWhereInput[]
    community?: IntFilter<"BannedUsers"> | number
    user?: StringFilter<"BannedUsers"> | string
    reasonId?: IntNullableFilter<"BannedUsers"> | number | null
    Community?: XOR<CommunityNullableRelationFilter, CommunityWhereInput> | null
  }, "id">

  export type BannedUsersOrderByWithAggregationInput = {
    id?: SortOrder
    community?: SortOrder
    user?: SortOrder
    reasonId?: SortOrderInput | SortOrder
    _count?: BannedUsersCountOrderByAggregateInput
    _avg?: BannedUsersAvgOrderByAggregateInput
    _max?: BannedUsersMaxOrderByAggregateInput
    _min?: BannedUsersMinOrderByAggregateInput
    _sum?: BannedUsersSumOrderByAggregateInput
  }

  export type BannedUsersScalarWhereWithAggregatesInput = {
    AND?: BannedUsersScalarWhereWithAggregatesInput | BannedUsersScalarWhereWithAggregatesInput[]
    OR?: BannedUsersScalarWhereWithAggregatesInput[]
    NOT?: BannedUsersScalarWhereWithAggregatesInput | BannedUsersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BannedUsers"> | number
    community?: IntWithAggregatesFilter<"BannedUsers"> | number
    user?: StringWithAggregatesFilter<"BannedUsers"> | string
    reasonId?: IntNullableWithAggregatesFilter<"BannedUsers"> | number | null
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    body?: StringNullableFilter<"Comment"> | string | null
    user?: StringFilter<"Comment"> | string
    post?: IntFilter<"Comment"> | number
    Post?: XOR<PostNullableRelationFilter, PostWhereInput> | null
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    body?: SortOrderInput | SortOrder
    user?: SortOrder
    post?: SortOrder
    Post?: PostOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    body?: StringNullableFilter<"Comment"> | string | null
    user?: StringFilter<"Comment"> | string
    post?: IntFilter<"Comment"> | number
    Post?: XOR<PostNullableRelationFilter, PostWhereInput> | null
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    body?: SortOrderInput | SortOrder
    user?: SortOrder
    post?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    body?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    user?: StringWithAggregatesFilter<"Comment"> | string
    post?: IntWithAggregatesFilter<"Comment"> | number
  }

  export type CommunityWhereInput = {
    AND?: CommunityWhereInput | CommunityWhereInput[]
    OR?: CommunityWhereInput[]
    NOT?: CommunityWhereInput | CommunityWhereInput[]
    id?: IntFilter<"Community"> | number
    name?: StringNullableFilter<"Community"> | string | null
    description?: StringNullableFilter<"Community"> | string | null
    CommunityUser?: CommunityUserListRelationFilter
    CommunityRequest?: CommunityRequestListRelationFilter
    BannedUsers?: BannedUsersListRelationFilter
  }

  export type CommunityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    CommunityUser?: CommunityUserOrderByRelationAggregateInput
    CommunityRequest?: CommunityRequestOrderByRelationAggregateInput
    BannedUsers?: BannedUsersOrderByRelationAggregateInput
  }

  export type CommunityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommunityWhereInput | CommunityWhereInput[]
    OR?: CommunityWhereInput[]
    NOT?: CommunityWhereInput | CommunityWhereInput[]
    name?: StringNullableFilter<"Community"> | string | null
    description?: StringNullableFilter<"Community"> | string | null
    CommunityUser?: CommunityUserListRelationFilter
    CommunityRequest?: CommunityRequestListRelationFilter
    BannedUsers?: BannedUsersListRelationFilter
  }, "id">

  export type CommunityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: CommunityCountOrderByAggregateInput
    _avg?: CommunityAvgOrderByAggregateInput
    _max?: CommunityMaxOrderByAggregateInput
    _min?: CommunityMinOrderByAggregateInput
    _sum?: CommunitySumOrderByAggregateInput
  }

  export type CommunityScalarWhereWithAggregatesInput = {
    AND?: CommunityScalarWhereWithAggregatesInput | CommunityScalarWhereWithAggregatesInput[]
    OR?: CommunityScalarWhereWithAggregatesInput[]
    NOT?: CommunityScalarWhereWithAggregatesInput | CommunityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Community"> | number
    name?: StringNullableWithAggregatesFilter<"Community"> | string | null
    description?: StringNullableWithAggregatesFilter<"Community"> | string | null
  }

  export type CommunityRequestWhereInput = {
    AND?: CommunityRequestWhereInput | CommunityRequestWhereInput[]
    OR?: CommunityRequestWhereInput[]
    NOT?: CommunityRequestWhereInput | CommunityRequestWhereInput[]
    id?: IntFilter<"CommunityRequest"> | number
    user?: StringNullableFilter<"CommunityRequest"> | string | null
    community?: IntNullableFilter<"CommunityRequest"> | number | null
    requestedAt?: DateTimeNullableFilter<"CommunityRequest"> | Date | string | null
    message?: StringNullableFilter<"CommunityRequest"> | string | null
    Community?: XOR<CommunityNullableRelationFilter, CommunityWhereInput> | null
  }

  export type CommunityRequestOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    community?: SortOrderInput | SortOrder
    requestedAt?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    Community?: CommunityOrderByWithRelationInput
  }

  export type CommunityRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommunityRequestWhereInput | CommunityRequestWhereInput[]
    OR?: CommunityRequestWhereInput[]
    NOT?: CommunityRequestWhereInput | CommunityRequestWhereInput[]
    user?: StringNullableFilter<"CommunityRequest"> | string | null
    community?: IntNullableFilter<"CommunityRequest"> | number | null
    requestedAt?: DateTimeNullableFilter<"CommunityRequest"> | Date | string | null
    message?: StringNullableFilter<"CommunityRequest"> | string | null
    Community?: XOR<CommunityNullableRelationFilter, CommunityWhereInput> | null
  }, "id">

  export type CommunityRequestOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    community?: SortOrderInput | SortOrder
    requestedAt?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    _count?: CommunityRequestCountOrderByAggregateInput
    _avg?: CommunityRequestAvgOrderByAggregateInput
    _max?: CommunityRequestMaxOrderByAggregateInput
    _min?: CommunityRequestMinOrderByAggregateInput
    _sum?: CommunityRequestSumOrderByAggregateInput
  }

  export type CommunityRequestScalarWhereWithAggregatesInput = {
    AND?: CommunityRequestScalarWhereWithAggregatesInput | CommunityRequestScalarWhereWithAggregatesInput[]
    OR?: CommunityRequestScalarWhereWithAggregatesInput[]
    NOT?: CommunityRequestScalarWhereWithAggregatesInput | CommunityRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CommunityRequest"> | number
    user?: StringNullableWithAggregatesFilter<"CommunityRequest"> | string | null
    community?: IntNullableWithAggregatesFilter<"CommunityRequest"> | number | null
    requestedAt?: DateTimeNullableWithAggregatesFilter<"CommunityRequest"> | Date | string | null
    message?: StringNullableWithAggregatesFilter<"CommunityRequest"> | string | null
  }

  export type ContextWhereInput = {
    AND?: ContextWhereInput | ContextWhereInput[]
    OR?: ContextWhereInput[]
    NOT?: ContextWhereInput | ContextWhereInput[]
    id?: IntFilter<"Context"> | number
    user?: StringNullableFilter<"Context"> | string | null
    ip?: StringNullableFilter<"Context"> | string | null
    country?: StringNullableFilter<"Context"> | string | null
    city?: StringNullableFilter<"Context"> | string | null
    os?: StringNullableFilter<"Context"> | string | null
    device?: StringNullableFilter<"Context"> | string | null
    deviceType?: StringNullableFilter<"Context"> | string | null
    isTrusted?: BoolNullableFilter<"Context"> | boolean | null
  }

  export type ContextOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    isTrusted?: SortOrderInput | SortOrder
  }

  export type ContextWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContextWhereInput | ContextWhereInput[]
    OR?: ContextWhereInput[]
    NOT?: ContextWhereInput | ContextWhereInput[]
    user?: StringNullableFilter<"Context"> | string | null
    ip?: StringNullableFilter<"Context"> | string | null
    country?: StringNullableFilter<"Context"> | string | null
    city?: StringNullableFilter<"Context"> | string | null
    os?: StringNullableFilter<"Context"> | string | null
    device?: StringNullableFilter<"Context"> | string | null
    deviceType?: StringNullableFilter<"Context"> | string | null
    isTrusted?: BoolNullableFilter<"Context"> | boolean | null
  }, "id">

  export type ContextOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    isTrusted?: SortOrderInput | SortOrder
    _count?: ContextCountOrderByAggregateInput
    _avg?: ContextAvgOrderByAggregateInput
    _max?: ContextMaxOrderByAggregateInput
    _min?: ContextMinOrderByAggregateInput
    _sum?: ContextSumOrderByAggregateInput
  }

  export type ContextScalarWhereWithAggregatesInput = {
    AND?: ContextScalarWhereWithAggregatesInput | ContextScalarWhereWithAggregatesInput[]
    OR?: ContextScalarWhereWithAggregatesInput[]
    NOT?: ContextScalarWhereWithAggregatesInput | ContextScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Context"> | number
    user?: StringNullableWithAggregatesFilter<"Context"> | string | null
    ip?: StringNullableWithAggregatesFilter<"Context"> | string | null
    country?: StringNullableWithAggregatesFilter<"Context"> | string | null
    city?: StringNullableWithAggregatesFilter<"Context"> | string | null
    os?: StringNullableWithAggregatesFilter<"Context"> | string | null
    device?: StringNullableWithAggregatesFilter<"Context"> | string | null
    deviceType?: StringNullableWithAggregatesFilter<"Context"> | string | null
    isTrusted?: BoolNullableWithAggregatesFilter<"Context"> | boolean | null
  }

  export type LikeWhereInput = {
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    id?: IntFilter<"Like"> | number
    user?: StringFilter<"Like"> | string
    post?: IntFilter<"Like"> | number
    Post?: XOR<PostNullableRelationFilter, PostWhereInput> | null
  }

  export type LikeOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrder
    post?: SortOrder
    Post?: PostOrderByWithRelationInput
  }

  export type LikeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    user?: StringFilter<"Like"> | string
    post?: IntFilter<"Like"> | number
    Post?: XOR<PostNullableRelationFilter, PostWhereInput> | null
  }, "id">

  export type LikeOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrder
    post?: SortOrder
    _count?: LikeCountOrderByAggregateInput
    _avg?: LikeAvgOrderByAggregateInput
    _max?: LikeMaxOrderByAggregateInput
    _min?: LikeMinOrderByAggregateInput
    _sum?: LikeSumOrderByAggregateInput
  }

  export type LikeScalarWhereWithAggregatesInput = {
    AND?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    OR?: LikeScalarWhereWithAggregatesInput[]
    NOT?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Like"> | number
    user?: StringWithAggregatesFilter<"Like"> | string
    post?: IntWithAggregatesFilter<"Like"> | number
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    id?: IntFilter<"Log"> | number
    user?: StringNullableFilter<"Log"> | string | null
    context?: IntNullableFilter<"Log"> | number | null
    message?: StringNullableFilter<"Log"> | string | null
    type?: IntNullableFilter<"Log"> | number | null
    level?: IntNullableFilter<"Log"> | number | null
    timestamp?: DateTimeNullableFilter<"Log"> | Date | string | null
    LogLevel?: XOR<LogLevelNullableRelationFilter, LogLevelWhereInput> | null
    LogType?: XOR<LogTypeNullableRelationFilter, LogTypeWhereInput> | null
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    context?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    LogLevel?: LogLevelOrderByWithRelationInput
    LogType?: LogTypeOrderByWithRelationInput
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    user?: StringNullableFilter<"Log"> | string | null
    context?: IntNullableFilter<"Log"> | number | null
    message?: StringNullableFilter<"Log"> | string | null
    type?: IntNullableFilter<"Log"> | number | null
    level?: IntNullableFilter<"Log"> | number | null
    timestamp?: DateTimeNullableFilter<"Log"> | Date | string | null
    LogLevel?: XOR<LogLevelNullableRelationFilter, LogLevelWhereInput> | null
    LogType?: XOR<LogTypeNullableRelationFilter, LogTypeWhereInput> | null
  }, "id">

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    context?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    _count?: LogCountOrderByAggregateInput
    _avg?: LogAvgOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
    _sum?: LogSumOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Log"> | number
    user?: StringNullableWithAggregatesFilter<"Log"> | string | null
    context?: IntNullableWithAggregatesFilter<"Log"> | number | null
    message?: StringNullableWithAggregatesFilter<"Log"> | string | null
    type?: IntNullableWithAggregatesFilter<"Log"> | number | null
    level?: IntNullableWithAggregatesFilter<"Log"> | number | null
    timestamp?: DateTimeNullableWithAggregatesFilter<"Log"> | Date | string | null
  }

  export type PendingPostWhereInput = {
    AND?: PendingPostWhereInput | PendingPostWhereInput[]
    OR?: PendingPostWhereInput[]
    NOT?: PendingPostWhereInput | PendingPostWhereInput[]
    id?: IntFilter<"PendingPost"> | number
    Content?: StringNullableFilter<"PendingPost"> | string | null
    fileUrl?: StringFilter<"PendingPost"> | string
    community?: IntFilter<"PendingPost"> | number
    user?: StringFilter<"PendingPost"> | string
    caption?: StringNullableFilter<"PendingPost"> | string | null
    status?: IntNullableFilter<"PendingPost"> | number | null
    confirmationToken?: StringNullableFilter<"PendingPost"> | string | null
    PendingPostStatus?: PendingPostStatusListRelationFilter
  }

  export type PendingPostOrderByWithRelationInput = {
    id?: SortOrder
    Content?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    community?: SortOrder
    user?: SortOrder
    caption?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    confirmationToken?: SortOrderInput | SortOrder
    PendingPostStatus?: PendingPostStatusOrderByRelationAggregateInput
  }

  export type PendingPostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PendingPostWhereInput | PendingPostWhereInput[]
    OR?: PendingPostWhereInput[]
    NOT?: PendingPostWhereInput | PendingPostWhereInput[]
    Content?: StringNullableFilter<"PendingPost"> | string | null
    fileUrl?: StringFilter<"PendingPost"> | string
    community?: IntFilter<"PendingPost"> | number
    user?: StringFilter<"PendingPost"> | string
    caption?: StringNullableFilter<"PendingPost"> | string | null
    status?: IntNullableFilter<"PendingPost"> | number | null
    confirmationToken?: StringNullableFilter<"PendingPost"> | string | null
    PendingPostStatus?: PendingPostStatusListRelationFilter
  }, "id">

  export type PendingPostOrderByWithAggregationInput = {
    id?: SortOrder
    Content?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    community?: SortOrder
    user?: SortOrder
    caption?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    confirmationToken?: SortOrderInput | SortOrder
    _count?: PendingPostCountOrderByAggregateInput
    _avg?: PendingPostAvgOrderByAggregateInput
    _max?: PendingPostMaxOrderByAggregateInput
    _min?: PendingPostMinOrderByAggregateInput
    _sum?: PendingPostSumOrderByAggregateInput
  }

  export type PendingPostScalarWhereWithAggregatesInput = {
    AND?: PendingPostScalarWhereWithAggregatesInput | PendingPostScalarWhereWithAggregatesInput[]
    OR?: PendingPostScalarWhereWithAggregatesInput[]
    NOT?: PendingPostScalarWhereWithAggregatesInput | PendingPostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PendingPost"> | number
    Content?: StringNullableWithAggregatesFilter<"PendingPost"> | string | null
    fileUrl?: StringWithAggregatesFilter<"PendingPost"> | string
    community?: IntWithAggregatesFilter<"PendingPost"> | number
    user?: StringWithAggregatesFilter<"PendingPost"> | string
    caption?: StringNullableWithAggregatesFilter<"PendingPost"> | string | null
    status?: IntNullableWithAggregatesFilter<"PendingPost"> | number | null
    confirmationToken?: StringNullableWithAggregatesFilter<"PendingPost"> | string | null
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: IntFilter<"Post"> | number
    Content?: StringNullableFilter<"Post"> | string | null
    fileUrl?: StringFilter<"Post"> | string
    community?: IntFilter<"Post"> | number
    user?: StringFilter<"Post"> | string
    caption?: StringNullableFilter<"Post"> | string | null
    Comment?: CommentListRelationFilter
    Like?: LikeListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    Content?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    community?: SortOrder
    user?: SortOrder
    caption?: SortOrderInput | SortOrder
    Comment?: CommentOrderByRelationAggregateInput
    Like?: LikeOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    Content?: StringNullableFilter<"Post"> | string | null
    fileUrl?: StringFilter<"Post"> | string
    community?: IntFilter<"Post"> | number
    user?: StringFilter<"Post"> | string
    caption?: StringNullableFilter<"Post"> | string | null
    Comment?: CommentListRelationFilter
    Like?: LikeListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    Content?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    community?: SortOrder
    user?: SortOrder
    caption?: SortOrderInput | SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Post"> | number
    Content?: StringNullableWithAggregatesFilter<"Post"> | string | null
    fileUrl?: StringWithAggregatesFilter<"Post"> | string
    community?: IntWithAggregatesFilter<"Post"> | number
    user?: StringWithAggregatesFilter<"Post"> | string
    caption?: StringNullableWithAggregatesFilter<"Post"> | string | null
  }

  export type PreferencesWhereInput = {
    AND?: PreferencesWhereInput | PreferencesWhereInput[]
    OR?: PreferencesWhereInput[]
    NOT?: PreferencesWhereInput | PreferencesWhereInput[]
    id?: IntFilter<"Preferences"> | number
    user?: StringNullableFilter<"Preferences"> | string | null
    enableContextBasedAuth?: BoolNullableFilter<"Preferences"> | boolean | null
  }

  export type PreferencesOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    enableContextBasedAuth?: SortOrderInput | SortOrder
  }

  export type PreferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PreferencesWhereInput | PreferencesWhereInput[]
    OR?: PreferencesWhereInput[]
    NOT?: PreferencesWhereInput | PreferencesWhereInput[]
    user?: StringNullableFilter<"Preferences"> | string | null
    enableContextBasedAuth?: BoolNullableFilter<"Preferences"> | boolean | null
  }, "id">

  export type PreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    enableContextBasedAuth?: SortOrderInput | SortOrder
    _count?: PreferencesCountOrderByAggregateInput
    _avg?: PreferencesAvgOrderByAggregateInput
    _max?: PreferencesMaxOrderByAggregateInput
    _min?: PreferencesMinOrderByAggregateInput
    _sum?: PreferencesSumOrderByAggregateInput
  }

  export type PreferencesScalarWhereWithAggregatesInput = {
    AND?: PreferencesScalarWhereWithAggregatesInput | PreferencesScalarWhereWithAggregatesInput[]
    OR?: PreferencesScalarWhereWithAggregatesInput[]
    NOT?: PreferencesScalarWhereWithAggregatesInput | PreferencesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Preferences"> | number
    user?: StringNullableWithAggregatesFilter<"Preferences"> | string | null
    enableContextBasedAuth?: BoolNullableWithAggregatesFilter<"Preferences"> | boolean | null
  }

  export type RelationshipWhereInput = {
    AND?: RelationshipWhereInput | RelationshipWhereInput[]
    OR?: RelationshipWhereInput[]
    NOT?: RelationshipWhereInput | RelationshipWhereInput[]
    id?: IntFilter<"Relationship"> | number
    follower?: StringFilter<"Relationship"> | string
    following?: StringFilter<"Relationship"> | string
  }

  export type RelationshipOrderByWithRelationInput = {
    id?: SortOrder
    follower?: SortOrder
    following?: SortOrder
  }

  export type RelationshipWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RelationshipWhereInput | RelationshipWhereInput[]
    OR?: RelationshipWhereInput[]
    NOT?: RelationshipWhereInput | RelationshipWhereInput[]
    follower?: StringFilter<"Relationship"> | string
    following?: StringFilter<"Relationship"> | string
  }, "id">

  export type RelationshipOrderByWithAggregationInput = {
    id?: SortOrder
    follower?: SortOrder
    following?: SortOrder
    _count?: RelationshipCountOrderByAggregateInput
    _avg?: RelationshipAvgOrderByAggregateInput
    _max?: RelationshipMaxOrderByAggregateInput
    _min?: RelationshipMinOrderByAggregateInput
    _sum?: RelationshipSumOrderByAggregateInput
  }

  export type RelationshipScalarWhereWithAggregatesInput = {
    AND?: RelationshipScalarWhereWithAggregatesInput | RelationshipScalarWhereWithAggregatesInput[]
    OR?: RelationshipScalarWhereWithAggregatesInput[]
    NOT?: RelationshipScalarWhereWithAggregatesInput | RelationshipScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Relationship"> | number
    follower?: StringWithAggregatesFilter<"Relationship"> | string
    following?: StringWithAggregatesFilter<"Relationship"> | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: IntFilter<"Report"> | number
    reportedBy?: StringFilter<"Report"> | string
    post?: IntFilter<"Report"> | number
    community?: IntFilter<"Report"> | number
    reportReason?: StringNullableFilter<"Report"> | string | null
    reportDate?: DateTimeNullableFilter<"Report"> | Date | string | null
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    reportedBy?: SortOrder
    post?: SortOrder
    community?: SortOrder
    reportReason?: SortOrderInput | SortOrder
    reportDate?: SortOrderInput | SortOrder
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    reportedBy?: StringFilter<"Report"> | string
    post?: IntFilter<"Report"> | number
    community?: IntFilter<"Report"> | number
    reportReason?: StringNullableFilter<"Report"> | string | null
    reportDate?: DateTimeNullableFilter<"Report"> | Date | string | null
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    reportedBy?: SortOrder
    post?: SortOrder
    community?: SortOrder
    reportReason?: SortOrderInput | SortOrder
    reportDate?: SortOrderInput | SortOrder
    _count?: ReportCountOrderByAggregateInput
    _avg?: ReportAvgOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
    _sum?: ReportSumOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Report"> | number
    reportedBy?: StringWithAggregatesFilter<"Report"> | string
    post?: IntWithAggregatesFilter<"Report"> | number
    community?: IntWithAggregatesFilter<"Report"> | number
    reportReason?: StringNullableWithAggregatesFilter<"Report"> | string | null
    reportDate?: DateTimeNullableWithAggregatesFilter<"Report"> | Date | string | null
  }

  export type TokenWhereInput = {
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    id?: IntFilter<"Token"> | number
    user?: StringFilter<"Token"> | string
    refreshToken?: StringNullableFilter<"Token"> | string | null
    accessToken?: StringNullableFilter<"Token"> | string | null
    createdAt?: DateTimeNullableFilter<"Token"> | Date | string | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type TokenOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type TokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    user?: StringFilter<"Token"> | string
    refreshToken?: StringNullableFilter<"Token"> | string | null
    accessToken?: StringNullableFilter<"Token"> | string | null
    createdAt?: DateTimeNullableFilter<"Token"> | Date | string | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type TokenOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: TokenCountOrderByAggregateInput
    _avg?: TokenAvgOrderByAggregateInput
    _max?: TokenMaxOrderByAggregateInput
    _min?: TokenMinOrderByAggregateInput
    _sum?: TokenSumOrderByAggregateInput
  }

  export type TokenScalarWhereWithAggregatesInput = {
    AND?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    OR?: TokenScalarWhereWithAggregatesInput[]
    NOT?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Token"> | number
    user?: StringWithAggregatesFilter<"Token"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"Token"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"Token"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Token"> | Date | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isEmailVerified?: BoolNullableFilter<"User"> | boolean | null
    height?: FloatNullableFilter<"User"> | number | null
    weight?: FloatNullableFilter<"User"> | number | null
    age?: IntNullableFilter<"User"> | number | null
    CommunityUser?: CommunityUserListRelationFilter
    Token?: TokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    isEmailVerified?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    CommunityUser?: CommunityUserOrderByRelationAggregateInput
    Token?: TokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isEmailVerified?: BoolNullableFilter<"User"> | boolean | null
    height?: FloatNullableFilter<"User"> | number | null
    weight?: FloatNullableFilter<"User"> | number | null
    age?: IntNullableFilter<"User"> | number | null
    CommunityUser?: CommunityUserListRelationFilter
    Token?: TokenListRelationFilter
  }, "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    isEmailVerified?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isEmailVerified?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    height?: FloatNullableWithAggregatesFilter<"User"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"User"> | number | null
    age?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type UserRolesWhereInput = {
    AND?: UserRolesWhereInput | UserRolesWhereInput[]
    OR?: UserRolesWhereInput[]
    NOT?: UserRolesWhereInput | UserRolesWhereInput[]
    id?: IntFilter<"UserRoles"> | number
    role?: StringNullableFilter<"UserRoles"> | string | null
    CommunityUser?: CommunityUserListRelationFilter
  }

  export type UserRolesOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrderInput | SortOrder
    CommunityUser?: CommunityUserOrderByRelationAggregateInput
  }

  export type UserRolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    role?: string
    AND?: UserRolesWhereInput | UserRolesWhereInput[]
    OR?: UserRolesWhereInput[]
    NOT?: UserRolesWhereInput | UserRolesWhereInput[]
    CommunityUser?: CommunityUserListRelationFilter
  }, "id" | "role">

  export type UserRolesOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrderInput | SortOrder
    _count?: UserRolesCountOrderByAggregateInput
    _avg?: UserRolesAvgOrderByAggregateInput
    _max?: UserRolesMaxOrderByAggregateInput
    _min?: UserRolesMinOrderByAggregateInput
    _sum?: UserRolesSumOrderByAggregateInput
  }

  export type UserRolesScalarWhereWithAggregatesInput = {
    AND?: UserRolesScalarWhereWithAggregatesInput | UserRolesScalarWhereWithAggregatesInput[]
    OR?: UserRolesScalarWhereWithAggregatesInput[]
    NOT?: UserRolesScalarWhereWithAggregatesInput | UserRolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserRoles"> | number
    role?: StringNullableWithAggregatesFilter<"UserRoles"> | string | null
  }

  export type EmailWhereInput = {
    AND?: EmailWhereInput | EmailWhereInput[]
    OR?: EmailWhereInput[]
    NOT?: EmailWhereInput | EmailWhereInput[]
    id?: IntFilter<"Email"> | number
    email?: StringNullableFilter<"Email"> | string | null
    verificationCode?: StringNullableFilter<"Email"> | string | null
    messageId?: StringNullableFilter<"Email"> | string | null
    for?: IntNullableFilter<"Email"> | number | null
    createdAt?: DateTimeNullableFilter<"Email"> | Date | string | null
    EmailFor?: XOR<EmailForNullableRelationFilter, EmailForWhereInput> | null
  }

  export type EmailOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    verificationCode?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    for?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    EmailFor?: EmailForOrderByWithRelationInput
  }

  export type EmailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmailWhereInput | EmailWhereInput[]
    OR?: EmailWhereInput[]
    NOT?: EmailWhereInput | EmailWhereInput[]
    email?: StringNullableFilter<"Email"> | string | null
    verificationCode?: StringNullableFilter<"Email"> | string | null
    messageId?: StringNullableFilter<"Email"> | string | null
    for?: IntNullableFilter<"Email"> | number | null
    createdAt?: DateTimeNullableFilter<"Email"> | Date | string | null
    EmailFor?: XOR<EmailForNullableRelationFilter, EmailForWhereInput> | null
  }, "id">

  export type EmailOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    verificationCode?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    for?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: EmailCountOrderByAggregateInput
    _avg?: EmailAvgOrderByAggregateInput
    _max?: EmailMaxOrderByAggregateInput
    _min?: EmailMinOrderByAggregateInput
    _sum?: EmailSumOrderByAggregateInput
  }

  export type EmailScalarWhereWithAggregatesInput = {
    AND?: EmailScalarWhereWithAggregatesInput | EmailScalarWhereWithAggregatesInput[]
    OR?: EmailScalarWhereWithAggregatesInput[]
    NOT?: EmailScalarWhereWithAggregatesInput | EmailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Email"> | number
    email?: StringNullableWithAggregatesFilter<"Email"> | string | null
    verificationCode?: StringNullableWithAggregatesFilter<"Email"> | string | null
    messageId?: StringNullableWithAggregatesFilter<"Email"> | string | null
    for?: IntNullableWithAggregatesFilter<"Email"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Email"> | Date | string | null
  }

  export type EmailForWhereInput = {
    AND?: EmailForWhereInput | EmailForWhereInput[]
    OR?: EmailForWhereInput[]
    NOT?: EmailForWhereInput | EmailForWhereInput[]
    id?: IntFilter<"EmailFor"> | number
    for?: StringNullableFilter<"EmailFor"> | string | null
    Email?: EmailListRelationFilter
  }

  export type EmailForOrderByWithRelationInput = {
    id?: SortOrder
    for?: SortOrderInput | SortOrder
    Email?: EmailOrderByRelationAggregateInput
  }

  export type EmailForWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmailForWhereInput | EmailForWhereInput[]
    OR?: EmailForWhereInput[]
    NOT?: EmailForWhereInput | EmailForWhereInput[]
    for?: StringNullableFilter<"EmailFor"> | string | null
    Email?: EmailListRelationFilter
  }, "id">

  export type EmailForOrderByWithAggregationInput = {
    id?: SortOrder
    for?: SortOrderInput | SortOrder
    _count?: EmailForCountOrderByAggregateInput
    _avg?: EmailForAvgOrderByAggregateInput
    _max?: EmailForMaxOrderByAggregateInput
    _min?: EmailForMinOrderByAggregateInput
    _sum?: EmailForSumOrderByAggregateInput
  }

  export type EmailForScalarWhereWithAggregatesInput = {
    AND?: EmailForScalarWhereWithAggregatesInput | EmailForScalarWhereWithAggregatesInput[]
    OR?: EmailForScalarWhereWithAggregatesInput[]
    NOT?: EmailForScalarWhereWithAggregatesInput | EmailForScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmailFor"> | number
    for?: StringNullableWithAggregatesFilter<"EmailFor"> | string | null
  }

  export type LeaderboardWhereInput = {
    AND?: LeaderboardWhereInput | LeaderboardWhereInput[]
    OR?: LeaderboardWhereInput[]
    NOT?: LeaderboardWhereInput | LeaderboardWhereInput[]
    id?: IntFilter<"Leaderboard"> | number
    community?: IntFilter<"Leaderboard"> | number
    LeaderboardSubmission?: LeaderboardSubmissionListRelationFilter
  }

  export type LeaderboardOrderByWithRelationInput = {
    id?: SortOrder
    community?: SortOrder
    LeaderboardSubmission?: LeaderboardSubmissionOrderByRelationAggregateInput
  }

  export type LeaderboardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LeaderboardWhereInput | LeaderboardWhereInput[]
    OR?: LeaderboardWhereInput[]
    NOT?: LeaderboardWhereInput | LeaderboardWhereInput[]
    community?: IntFilter<"Leaderboard"> | number
    LeaderboardSubmission?: LeaderboardSubmissionListRelationFilter
  }, "id">

  export type LeaderboardOrderByWithAggregationInput = {
    id?: SortOrder
    community?: SortOrder
    _count?: LeaderboardCountOrderByAggregateInput
    _avg?: LeaderboardAvgOrderByAggregateInput
    _max?: LeaderboardMaxOrderByAggregateInput
    _min?: LeaderboardMinOrderByAggregateInput
    _sum?: LeaderboardSumOrderByAggregateInput
  }

  export type LeaderboardScalarWhereWithAggregatesInput = {
    AND?: LeaderboardScalarWhereWithAggregatesInput | LeaderboardScalarWhereWithAggregatesInput[]
    OR?: LeaderboardScalarWhereWithAggregatesInput[]
    NOT?: LeaderboardScalarWhereWithAggregatesInput | LeaderboardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Leaderboard"> | number
    community?: IntWithAggregatesFilter<"Leaderboard"> | number
  }

  export type LeaderboardSubmissionWhereInput = {
    AND?: LeaderboardSubmissionWhereInput | LeaderboardSubmissionWhereInput[]
    OR?: LeaderboardSubmissionWhereInput[]
    NOT?: LeaderboardSubmissionWhereInput | LeaderboardSubmissionWhereInput[]
    id?: IntFilter<"LeaderboardSubmission"> | number
    user?: StringNullableFilter<"LeaderboardSubmission"> | string | null
    community?: IntNullableFilter<"LeaderboardSubmission"> | number | null
    entryUrl?: StringNullableFilter<"LeaderboardSubmission"> | string | null
    verifiedBy?: IntNullableFilter<"LeaderboardSubmission"> | number | null
    weight?: StringNullableFilter<"LeaderboardSubmission"> | string | null
    type?: IntNullableFilter<"LeaderboardSubmission"> | number | null
    verifiedAt?: DateTimeNullableFilter<"LeaderboardSubmission"> | Date | string | null
    rank?: IntNullableFilter<"LeaderboardSubmission"> | number | null
    leaderboardId?: IntNullableFilter<"LeaderboardSubmission"> | number | null
    LeaderboardSubmissionType?: LeaderboardSubmissionTypeListRelationFilter
    Leaderboard?: XOR<LeaderboardNullableRelationFilter, LeaderboardWhereInput> | null
  }

  export type LeaderboardSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    community?: SortOrderInput | SortOrder
    entryUrl?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    leaderboardId?: SortOrderInput | SortOrder
    LeaderboardSubmissionType?: LeaderboardSubmissionTypeOrderByRelationAggregateInput
    Leaderboard?: LeaderboardOrderByWithRelationInput
  }

  export type LeaderboardSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LeaderboardSubmissionWhereInput | LeaderboardSubmissionWhereInput[]
    OR?: LeaderboardSubmissionWhereInput[]
    NOT?: LeaderboardSubmissionWhereInput | LeaderboardSubmissionWhereInput[]
    user?: StringNullableFilter<"LeaderboardSubmission"> | string | null
    community?: IntNullableFilter<"LeaderboardSubmission"> | number | null
    entryUrl?: StringNullableFilter<"LeaderboardSubmission"> | string | null
    verifiedBy?: IntNullableFilter<"LeaderboardSubmission"> | number | null
    weight?: StringNullableFilter<"LeaderboardSubmission"> | string | null
    type?: IntNullableFilter<"LeaderboardSubmission"> | number | null
    verifiedAt?: DateTimeNullableFilter<"LeaderboardSubmission"> | Date | string | null
    rank?: IntNullableFilter<"LeaderboardSubmission"> | number | null
    leaderboardId?: IntNullableFilter<"LeaderboardSubmission"> | number | null
    LeaderboardSubmissionType?: LeaderboardSubmissionTypeListRelationFilter
    Leaderboard?: XOR<LeaderboardNullableRelationFilter, LeaderboardWhereInput> | null
  }, "id">

  export type LeaderboardSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    community?: SortOrderInput | SortOrder
    entryUrl?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    leaderboardId?: SortOrderInput | SortOrder
    _count?: LeaderboardSubmissionCountOrderByAggregateInput
    _avg?: LeaderboardSubmissionAvgOrderByAggregateInput
    _max?: LeaderboardSubmissionMaxOrderByAggregateInput
    _min?: LeaderboardSubmissionMinOrderByAggregateInput
    _sum?: LeaderboardSubmissionSumOrderByAggregateInput
  }

  export type LeaderboardSubmissionScalarWhereWithAggregatesInput = {
    AND?: LeaderboardSubmissionScalarWhereWithAggregatesInput | LeaderboardSubmissionScalarWhereWithAggregatesInput[]
    OR?: LeaderboardSubmissionScalarWhereWithAggregatesInput[]
    NOT?: LeaderboardSubmissionScalarWhereWithAggregatesInput | LeaderboardSubmissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LeaderboardSubmission"> | number
    user?: StringNullableWithAggregatesFilter<"LeaderboardSubmission"> | string | null
    community?: IntNullableWithAggregatesFilter<"LeaderboardSubmission"> | number | null
    entryUrl?: StringNullableWithAggregatesFilter<"LeaderboardSubmission"> | string | null
    verifiedBy?: IntNullableWithAggregatesFilter<"LeaderboardSubmission"> | number | null
    weight?: StringNullableWithAggregatesFilter<"LeaderboardSubmission"> | string | null
    type?: IntNullableWithAggregatesFilter<"LeaderboardSubmission"> | number | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"LeaderboardSubmission"> | Date | string | null
    rank?: IntNullableWithAggregatesFilter<"LeaderboardSubmission"> | number | null
    leaderboardId?: IntNullableWithAggregatesFilter<"LeaderboardSubmission"> | number | null
  }

  export type LeaderboardSubmissionTypeWhereInput = {
    AND?: LeaderboardSubmissionTypeWhereInput | LeaderboardSubmissionTypeWhereInput[]
    OR?: LeaderboardSubmissionTypeWhereInput[]
    NOT?: LeaderboardSubmissionTypeWhereInput | LeaderboardSubmissionTypeWhereInput[]
    id?: IntFilter<"LeaderboardSubmissionType"> | number
    type?: StringNullableFilter<"LeaderboardSubmissionType"> | string | null
    leaderboardSubmissionId?: IntNullableFilter<"LeaderboardSubmissionType"> | number | null
    LeaderboardSubmission?: XOR<LeaderboardSubmissionNullableRelationFilter, LeaderboardSubmissionWhereInput> | null
  }

  export type LeaderboardSubmissionTypeOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    leaderboardSubmissionId?: SortOrderInput | SortOrder
    LeaderboardSubmission?: LeaderboardSubmissionOrderByWithRelationInput
  }

  export type LeaderboardSubmissionTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LeaderboardSubmissionTypeWhereInput | LeaderboardSubmissionTypeWhereInput[]
    OR?: LeaderboardSubmissionTypeWhereInput[]
    NOT?: LeaderboardSubmissionTypeWhereInput | LeaderboardSubmissionTypeWhereInput[]
    type?: StringNullableFilter<"LeaderboardSubmissionType"> | string | null
    leaderboardSubmissionId?: IntNullableFilter<"LeaderboardSubmissionType"> | number | null
    LeaderboardSubmission?: XOR<LeaderboardSubmissionNullableRelationFilter, LeaderboardSubmissionWhereInput> | null
  }, "id">

  export type LeaderboardSubmissionTypeOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    leaderboardSubmissionId?: SortOrderInput | SortOrder
    _count?: LeaderboardSubmissionTypeCountOrderByAggregateInput
    _avg?: LeaderboardSubmissionTypeAvgOrderByAggregateInput
    _max?: LeaderboardSubmissionTypeMaxOrderByAggregateInput
    _min?: LeaderboardSubmissionTypeMinOrderByAggregateInput
    _sum?: LeaderboardSubmissionTypeSumOrderByAggregateInput
  }

  export type LeaderboardSubmissionTypeScalarWhereWithAggregatesInput = {
    AND?: LeaderboardSubmissionTypeScalarWhereWithAggregatesInput | LeaderboardSubmissionTypeScalarWhereWithAggregatesInput[]
    OR?: LeaderboardSubmissionTypeScalarWhereWithAggregatesInput[]
    NOT?: LeaderboardSubmissionTypeScalarWhereWithAggregatesInput | LeaderboardSubmissionTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LeaderboardSubmissionType"> | number
    type?: StringNullableWithAggregatesFilter<"LeaderboardSubmissionType"> | string | null
    leaderboardSubmissionId?: IntNullableWithAggregatesFilter<"LeaderboardSubmissionType"> | number | null
  }

  export type PendingPostStatusWhereInput = {
    AND?: PendingPostStatusWhereInput | PendingPostStatusWhereInput[]
    OR?: PendingPostStatusWhereInput[]
    NOT?: PendingPostStatusWhereInput | PendingPostStatusWhereInput[]
    id?: IntFilter<"PendingPostStatus"> | number
    status?: StringNullableFilter<"PendingPostStatus"> | string | null
    PendingPost?: PendingPostListRelationFilter
  }

  export type PendingPostStatusOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrderInput | SortOrder
    PendingPost?: PendingPostOrderByRelationAggregateInput
  }

  export type PendingPostStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PendingPostStatusWhereInput | PendingPostStatusWhereInput[]
    OR?: PendingPostStatusWhereInput[]
    NOT?: PendingPostStatusWhereInput | PendingPostStatusWhereInput[]
    status?: StringNullableFilter<"PendingPostStatus"> | string | null
    PendingPost?: PendingPostListRelationFilter
  }, "id">

  export type PendingPostStatusOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrderInput | SortOrder
    _count?: PendingPostStatusCountOrderByAggregateInput
    _avg?: PendingPostStatusAvgOrderByAggregateInput
    _max?: PendingPostStatusMaxOrderByAggregateInput
    _min?: PendingPostStatusMinOrderByAggregateInput
    _sum?: PendingPostStatusSumOrderByAggregateInput
  }

  export type PendingPostStatusScalarWhereWithAggregatesInput = {
    AND?: PendingPostStatusScalarWhereWithAggregatesInput | PendingPostStatusScalarWhereWithAggregatesInput[]
    OR?: PendingPostStatusScalarWhereWithAggregatesInput[]
    NOT?: PendingPostStatusScalarWhereWithAggregatesInput | PendingPostStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PendingPostStatus"> | number
    status?: StringNullableWithAggregatesFilter<"PendingPostStatus"> | string | null
  }

  export type LogLevelWhereInput = {
    AND?: LogLevelWhereInput | LogLevelWhereInput[]
    OR?: LogLevelWhereInput[]
    NOT?: LogLevelWhereInput | LogLevelWhereInput[]
    id?: IntFilter<"LogLevel"> | number
    level?: StringNullableFilter<"LogLevel"> | string | null
    Log?: LogListRelationFilter
  }

  export type LogLevelOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrderInput | SortOrder
    Log?: LogOrderByRelationAggregateInput
  }

  export type LogLevelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogLevelWhereInput | LogLevelWhereInput[]
    OR?: LogLevelWhereInput[]
    NOT?: LogLevelWhereInput | LogLevelWhereInput[]
    level?: StringNullableFilter<"LogLevel"> | string | null
    Log?: LogListRelationFilter
  }, "id">

  export type LogLevelOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrderInput | SortOrder
    _count?: LogLevelCountOrderByAggregateInput
    _avg?: LogLevelAvgOrderByAggregateInput
    _max?: LogLevelMaxOrderByAggregateInput
    _min?: LogLevelMinOrderByAggregateInput
    _sum?: LogLevelSumOrderByAggregateInput
  }

  export type LogLevelScalarWhereWithAggregatesInput = {
    AND?: LogLevelScalarWhereWithAggregatesInput | LogLevelScalarWhereWithAggregatesInput[]
    OR?: LogLevelScalarWhereWithAggregatesInput[]
    NOT?: LogLevelScalarWhereWithAggregatesInput | LogLevelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogLevel"> | number
    level?: StringNullableWithAggregatesFilter<"LogLevel"> | string | null
  }

  export type LogTypeWhereInput = {
    AND?: LogTypeWhereInput | LogTypeWhereInput[]
    OR?: LogTypeWhereInput[]
    NOT?: LogTypeWhereInput | LogTypeWhereInput[]
    id?: IntFilter<"LogType"> | number
    type?: StringNullableFilter<"LogType"> | string | null
    Log?: LogListRelationFilter
  }

  export type LogTypeOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    Log?: LogOrderByRelationAggregateInput
  }

  export type LogTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogTypeWhereInput | LogTypeWhereInput[]
    OR?: LogTypeWhereInput[]
    NOT?: LogTypeWhereInput | LogTypeWhereInput[]
    type?: StringNullableFilter<"LogType"> | string | null
    Log?: LogListRelationFilter
  }, "id">

  export type LogTypeOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    _count?: LogTypeCountOrderByAggregateInput
    _avg?: LogTypeAvgOrderByAggregateInput
    _max?: LogTypeMaxOrderByAggregateInput
    _min?: LogTypeMinOrderByAggregateInput
    _sum?: LogTypeSumOrderByAggregateInput
  }

  export type LogTypeScalarWhereWithAggregatesInput = {
    AND?: LogTypeScalarWhereWithAggregatesInput | LogTypeScalarWhereWithAggregatesInput[]
    OR?: LogTypeScalarWhereWithAggregatesInput[]
    NOT?: LogTypeScalarWhereWithAggregatesInput | LogTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogType"> | number
    type?: StringNullableWithAggregatesFilter<"LogType"> | string | null
  }

  export type SuspiciousLoginWhereInput = {
    AND?: SuspiciousLoginWhereInput | SuspiciousLoginWhereInput[]
    OR?: SuspiciousLoginWhereInput[]
    NOT?: SuspiciousLoginWhereInput | SuspiciousLoginWhereInput[]
    id?: IntFilter<"SuspiciousLogin"> | number
    user?: StringNullableFilter<"SuspiciousLogin"> | string | null
    ip?: StringNullableFilter<"SuspiciousLogin"> | string | null
    country?: StringNullableFilter<"SuspiciousLogin"> | string | null
    city?: StringNullableFilter<"SuspiciousLogin"> | string | null
    os?: StringNullableFilter<"SuspiciousLogin"> | string | null
    device?: StringNullableFilter<"SuspiciousLogin"> | string | null
    deviceType?: StringNullableFilter<"SuspiciousLogin"> | string | null
    isTrusted?: BoolNullableFilter<"SuspiciousLogin"> | boolean | null
    unverifiedAttempts?: IntNullableFilter<"SuspiciousLogin"> | number | null
    isBlocked?: BoolNullableFilter<"SuspiciousLogin"> | boolean | null
  }

  export type SuspiciousLoginOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    isTrusted?: SortOrderInput | SortOrder
    unverifiedAttempts?: SortOrderInput | SortOrder
    isBlocked?: SortOrderInput | SortOrder
  }

  export type SuspiciousLoginWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SuspiciousLoginWhereInput | SuspiciousLoginWhereInput[]
    OR?: SuspiciousLoginWhereInput[]
    NOT?: SuspiciousLoginWhereInput | SuspiciousLoginWhereInput[]
    user?: StringNullableFilter<"SuspiciousLogin"> | string | null
    ip?: StringNullableFilter<"SuspiciousLogin"> | string | null
    country?: StringNullableFilter<"SuspiciousLogin"> | string | null
    city?: StringNullableFilter<"SuspiciousLogin"> | string | null
    os?: StringNullableFilter<"SuspiciousLogin"> | string | null
    device?: StringNullableFilter<"SuspiciousLogin"> | string | null
    deviceType?: StringNullableFilter<"SuspiciousLogin"> | string | null
    isTrusted?: BoolNullableFilter<"SuspiciousLogin"> | boolean | null
    unverifiedAttempts?: IntNullableFilter<"SuspiciousLogin"> | number | null
    isBlocked?: BoolNullableFilter<"SuspiciousLogin"> | boolean | null
  }, "id">

  export type SuspiciousLoginOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    isTrusted?: SortOrderInput | SortOrder
    unverifiedAttempts?: SortOrderInput | SortOrder
    isBlocked?: SortOrderInput | SortOrder
    _count?: SuspiciousLoginCountOrderByAggregateInput
    _avg?: SuspiciousLoginAvgOrderByAggregateInput
    _max?: SuspiciousLoginMaxOrderByAggregateInput
    _min?: SuspiciousLoginMinOrderByAggregateInput
    _sum?: SuspiciousLoginSumOrderByAggregateInput
  }

  export type SuspiciousLoginScalarWhereWithAggregatesInput = {
    AND?: SuspiciousLoginScalarWhereWithAggregatesInput | SuspiciousLoginScalarWhereWithAggregatesInput[]
    OR?: SuspiciousLoginScalarWhereWithAggregatesInput[]
    NOT?: SuspiciousLoginScalarWhereWithAggregatesInput | SuspiciousLoginScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SuspiciousLogin"> | number
    user?: StringNullableWithAggregatesFilter<"SuspiciousLogin"> | string | null
    ip?: StringNullableWithAggregatesFilter<"SuspiciousLogin"> | string | null
    country?: StringNullableWithAggregatesFilter<"SuspiciousLogin"> | string | null
    city?: StringNullableWithAggregatesFilter<"SuspiciousLogin"> | string | null
    os?: StringNullableWithAggregatesFilter<"SuspiciousLogin"> | string | null
    device?: StringNullableWithAggregatesFilter<"SuspiciousLogin"> | string | null
    deviceType?: StringNullableWithAggregatesFilter<"SuspiciousLogin"> | string | null
    isTrusted?: BoolNullableWithAggregatesFilter<"SuspiciousLogin"> | boolean | null
    unverifiedAttempts?: IntNullableWithAggregatesFilter<"SuspiciousLogin"> | number | null
    isBlocked?: BoolNullableWithAggregatesFilter<"SuspiciousLogin"> | boolean | null
  }

  export type CommunityUserWhereInput = {
    AND?: CommunityUserWhereInput | CommunityUserWhereInput[]
    OR?: CommunityUserWhereInput[]
    NOT?: CommunityUserWhereInput | CommunityUserWhereInput[]
    id?: IntFilter<"CommunityUser"> | number
    community?: IntFilter<"CommunityUser"> | number
    user?: StringFilter<"CommunityUser"> | string
    role?: IntFilter<"CommunityUser"> | number
    verifiedAt?: DateTimeNullableFilter<"CommunityUser"> | Date | string | null
    Community?: XOR<CommunityRelationFilter, CommunityWhereInput>
    UserRoles?: XOR<UserRolesRelationFilter, UserRolesWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommunityUserOrderByWithRelationInput = {
    id?: SortOrder
    community?: SortOrder
    user?: SortOrder
    role?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    Community?: CommunityOrderByWithRelationInput
    UserRoles?: UserRolesOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type CommunityUserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommunityUserWhereInput | CommunityUserWhereInput[]
    OR?: CommunityUserWhereInput[]
    NOT?: CommunityUserWhereInput | CommunityUserWhereInput[]
    community?: IntFilter<"CommunityUser"> | number
    user?: StringFilter<"CommunityUser"> | string
    role?: IntFilter<"CommunityUser"> | number
    verifiedAt?: DateTimeNullableFilter<"CommunityUser"> | Date | string | null
    Community?: XOR<CommunityRelationFilter, CommunityWhereInput>
    UserRoles?: XOR<UserRolesRelationFilter, UserRolesWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CommunityUserOrderByWithAggregationInput = {
    id?: SortOrder
    community?: SortOrder
    user?: SortOrder
    role?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    _count?: CommunityUserCountOrderByAggregateInput
    _avg?: CommunityUserAvgOrderByAggregateInput
    _max?: CommunityUserMaxOrderByAggregateInput
    _min?: CommunityUserMinOrderByAggregateInput
    _sum?: CommunityUserSumOrderByAggregateInput
  }

  export type CommunityUserScalarWhereWithAggregatesInput = {
    AND?: CommunityUserScalarWhereWithAggregatesInput | CommunityUserScalarWhereWithAggregatesInput[]
    OR?: CommunityUserScalarWhereWithAggregatesInput[]
    NOT?: CommunityUserScalarWhereWithAggregatesInput | CommunityUserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CommunityUser"> | number
    community?: IntWithAggregatesFilter<"CommunityUser"> | number
    user?: StringWithAggregatesFilter<"CommunityUser"> | string
    role?: IntWithAggregatesFilter<"CommunityUser"> | number
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"CommunityUser"> | Date | string | null
  }

  export type AdminCreateInput = {
    username?: string | null
    password?: string | null
    AdminToken?: AdminTokenCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    username?: string | null
    password?: string | null
    AdminToken?: AdminTokenUncheckedCreateNestedOneWithoutAdminInput
  }

  export type AdminUpdateInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    AdminToken?: AdminTokenUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    AdminToken?: AdminTokenUncheckedUpdateOneWithoutAdminNestedInput
  }

  export type AdminCreateManyInput = {
    id?: number
    username?: string | null
    password?: string | null
  }

  export type AdminUpdateManyMutationInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminTokenCreateInput = {
    accessToken?: string | null
    Admin?: AdminCreateNestedOneWithoutAdminTokenInput
  }

  export type AdminTokenUncheckedCreateInput = {
    id?: number
    user: string
    accessToken?: string | null
  }

  export type AdminTokenUpdateInput = {
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    Admin?: AdminUpdateOneWithoutAdminTokenNestedInput
  }

  export type AdminTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminTokenCreateManyInput = {
    id?: number
    user: string
    accessToken?: string | null
  }

  export type AdminTokenUpdateManyMutationInput = {
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BannedUsersCreateInput = {
    user: string
    reasonId?: number | null
    Community?: CommunityCreateNestedOneWithoutBannedUsersInput
  }

  export type BannedUsersUncheckedCreateInput = {
    id?: number
    community: number
    user: string
    reasonId?: number | null
  }

  export type BannedUsersUpdateInput = {
    user?: StringFieldUpdateOperationsInput | string
    reasonId?: NullableIntFieldUpdateOperationsInput | number | null
    Community?: CommunityUpdateOneWithoutBannedUsersNestedInput
  }

  export type BannedUsersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    reasonId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BannedUsersCreateManyInput = {
    id?: number
    community: number
    user: string
    reasonId?: number | null
  }

  export type BannedUsersUpdateManyMutationInput = {
    user?: StringFieldUpdateOperationsInput | string
    reasonId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BannedUsersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    reasonId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommentCreateInput = {
    body?: string | null
    user: string
    Post?: PostCreateNestedOneWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    body?: string | null
    user: string
    post: number
  }

  export type CommentUpdateInput = {
    body?: NullableStringFieldUpdateOperationsInput | string | null
    user?: StringFieldUpdateOperationsInput | string
    Post?: PostUpdateOneWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: NullableStringFieldUpdateOperationsInput | string | null
    user?: StringFieldUpdateOperationsInput | string
    post?: IntFieldUpdateOperationsInput | number
  }

  export type CommentCreateManyInput = {
    id?: number
    body?: string | null
    user: string
    post: number
  }

  export type CommentUpdateManyMutationInput = {
    body?: NullableStringFieldUpdateOperationsInput | string | null
    user?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: NullableStringFieldUpdateOperationsInput | string | null
    user?: StringFieldUpdateOperationsInput | string
    post?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityCreateInput = {
    name?: string | null
    description?: string | null
    CommunityUser?: CommunityUserCreateNestedManyWithoutCommunityInput
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutCommunityInput
    BannedUsers?: BannedUsersCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateInput = {
    id?: number
    name?: string | null
    description?: string | null
    CommunityUser?: CommunityUserUncheckedCreateNestedManyWithoutCommunityInput
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutCommunityInput
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    CommunityUser?: CommunityUserUpdateManyWithoutCommunityNestedInput
    CommunityRequest?: CommunityRequestUpdateManyWithoutCommunityNestedInput
    BannedUsers?: BannedUsersUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    CommunityUser?: CommunityUserUncheckedUpdateManyWithoutCommunityNestedInput
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutCommunityNestedInput
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityCreateManyInput = {
    id?: number
    name?: string | null
    description?: string | null
  }

  export type CommunityUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunityRequestCreateInput = {
    user?: string | null
    requestedAt?: Date | string | null
    message?: string | null
    Community?: CommunityCreateNestedOneWithoutCommunityRequestInput
  }

  export type CommunityRequestUncheckedCreateInput = {
    id?: number
    user?: string | null
    community?: number | null
    requestedAt?: Date | string | null
    message?: string | null
  }

  export type CommunityRequestUpdateInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    Community?: CommunityUpdateOneWithoutCommunityRequestNestedInput
  }

  export type CommunityRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunityRequestCreateManyInput = {
    id?: number
    user?: string | null
    community?: number | null
    requestedAt?: Date | string | null
    message?: string | null
  }

  export type CommunityRequestUpdateManyMutationInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunityRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContextCreateInput = {
    user?: string | null
    ip?: string | null
    country?: string | null
    city?: string | null
    os?: string | null
    device?: string | null
    deviceType?: string | null
    isTrusted?: boolean | null
  }

  export type ContextUncheckedCreateInput = {
    id?: number
    user?: string | null
    ip?: string | null
    country?: string | null
    city?: string | null
    os?: string | null
    device?: string | null
    deviceType?: string | null
    isTrusted?: boolean | null
  }

  export type ContextUpdateInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ContextUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ContextCreateManyInput = {
    id?: number
    user?: string | null
    ip?: string | null
    country?: string | null
    city?: string | null
    os?: string | null
    device?: string | null
    deviceType?: string | null
    isTrusted?: boolean | null
  }

  export type ContextUpdateManyMutationInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ContextUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type LikeCreateInput = {
    user: string
    Post?: PostCreateNestedOneWithoutLikeInput
  }

  export type LikeUncheckedCreateInput = {
    id?: number
    user: string
    post: number
  }

  export type LikeUpdateInput = {
    user?: StringFieldUpdateOperationsInput | string
    Post?: PostUpdateOneWithoutLikeNestedInput
  }

  export type LikeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    post?: IntFieldUpdateOperationsInput | number
  }

  export type LikeCreateManyInput = {
    id?: number
    user: string
    post: number
  }

  export type LikeUpdateManyMutationInput = {
    user?: StringFieldUpdateOperationsInput | string
  }

  export type LikeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    post?: IntFieldUpdateOperationsInput | number
  }

  export type LogCreateInput = {
    user?: string | null
    context?: number | null
    message?: string | null
    timestamp?: Date | string | null
    LogLevel?: LogLevelCreateNestedOneWithoutLogInput
    LogType?: LogTypeCreateNestedOneWithoutLogInput
  }

  export type LogUncheckedCreateInput = {
    id?: number
    user?: string | null
    context?: number | null
    message?: string | null
    type?: number | null
    level?: number | null
    timestamp?: Date | string | null
  }

  export type LogUpdateInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LogLevel?: LogLevelUpdateOneWithoutLogNestedInput
    LogType?: LogTypeUpdateOneWithoutLogNestedInput
  }

  export type LogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogCreateManyInput = {
    id?: number
    user?: string | null
    context?: number | null
    message?: string | null
    type?: number | null
    level?: number | null
    timestamp?: Date | string | null
  }

  export type LogUpdateManyMutationInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PendingPostCreateInput = {
    Content?: string | null
    fileUrl: string
    community: number
    user: string
    caption?: string | null
    status?: number | null
    confirmationToken?: string | null
    PendingPostStatus?: PendingPostStatusCreateNestedManyWithoutPendingPostInput
  }

  export type PendingPostUncheckedCreateInput = {
    id?: number
    Content?: string | null
    fileUrl: string
    community: number
    user: string
    caption?: string | null
    status?: number | null
    confirmationToken?: string | null
    PendingPostStatus?: PendingPostStatusUncheckedCreateNestedManyWithoutPendingPostInput
  }

  export type PendingPostUpdateInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    confirmationToken?: NullableStringFieldUpdateOperationsInput | string | null
    PendingPostStatus?: PendingPostStatusUpdateManyWithoutPendingPostNestedInput
  }

  export type PendingPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    confirmationToken?: NullableStringFieldUpdateOperationsInput | string | null
    PendingPostStatus?: PendingPostStatusUncheckedUpdateManyWithoutPendingPostNestedInput
  }

  export type PendingPostCreateManyInput = {
    id?: number
    Content?: string | null
    fileUrl: string
    community: number
    user: string
    caption?: string | null
    status?: number | null
    confirmationToken?: string | null
  }

  export type PendingPostUpdateManyMutationInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    confirmationToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PendingPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    confirmationToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostCreateInput = {
    Content?: string | null
    fileUrl: string
    community: number
    user: string
    caption?: string | null
    Comment?: CommentCreateNestedManyWithoutPostInput
    Like?: LikeCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: number
    Content?: string | null
    fileUrl: string
    community: number
    user: string
    caption?: string | null
    Comment?: CommentUncheckedCreateNestedManyWithoutPostInput
    Like?: LikeUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: CommentUpdateManyWithoutPostNestedInput
    Like?: LikeUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: CommentUncheckedUpdateManyWithoutPostNestedInput
    Like?: LikeUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: number
    Content?: string | null
    fileUrl: string
    community: number
    user: string
    caption?: string | null
  }

  export type PostUpdateManyMutationInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PreferencesCreateInput = {
    user?: string | null
    enableContextBasedAuth?: boolean | null
  }

  export type PreferencesUncheckedCreateInput = {
    id?: number
    user?: string | null
    enableContextBasedAuth?: boolean | null
  }

  export type PreferencesUpdateInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    enableContextBasedAuth?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PreferencesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    enableContextBasedAuth?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PreferencesCreateManyInput = {
    id?: number
    user?: string | null
    enableContextBasedAuth?: boolean | null
  }

  export type PreferencesUpdateManyMutationInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    enableContextBasedAuth?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PreferencesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    enableContextBasedAuth?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type RelationshipCreateInput = {
    follower: string
    following: string
  }

  export type RelationshipUncheckedCreateInput = {
    id?: number
    follower: string
    following: string
  }

  export type RelationshipUpdateInput = {
    follower?: StringFieldUpdateOperationsInput | string
    following?: StringFieldUpdateOperationsInput | string
  }

  export type RelationshipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    follower?: StringFieldUpdateOperationsInput | string
    following?: StringFieldUpdateOperationsInput | string
  }

  export type RelationshipCreateManyInput = {
    id?: number
    follower: string
    following: string
  }

  export type RelationshipUpdateManyMutationInput = {
    follower?: StringFieldUpdateOperationsInput | string
    following?: StringFieldUpdateOperationsInput | string
  }

  export type RelationshipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    follower?: StringFieldUpdateOperationsInput | string
    following?: StringFieldUpdateOperationsInput | string
  }

  export type ReportCreateInput = {
    reportedBy: string
    post: number
    community: number
    reportReason?: string | null
    reportDate?: Date | string | null
  }

  export type ReportUncheckedCreateInput = {
    id?: number
    reportedBy: string
    post: number
    community: number
    reportReason?: string | null
    reportDate?: Date | string | null
  }

  export type ReportUpdateInput = {
    reportedBy?: StringFieldUpdateOperationsInput | string
    post?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
    reportReason?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedBy?: StringFieldUpdateOperationsInput | string
    post?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
    reportReason?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportCreateManyInput = {
    id?: number
    reportedBy: string
    post: number
    community: number
    reportReason?: string | null
    reportDate?: Date | string | null
  }

  export type ReportUpdateManyMutationInput = {
    reportedBy?: StringFieldUpdateOperationsInput | string
    post?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
    reportReason?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedBy?: StringFieldUpdateOperationsInput | string
    post?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
    reportReason?: NullableStringFieldUpdateOperationsInput | string | null
    reportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TokenCreateInput = {
    refreshToken?: string | null
    accessToken?: string | null
    createdAt?: Date | string | null
    User?: UserCreateNestedOneWithoutTokenInput
  }

  export type TokenUncheckedCreateInput = {
    id?: number
    user: string
    refreshToken?: string | null
    accessToken?: string | null
    createdAt?: Date | string | null
  }

  export type TokenUpdateInput = {
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TokenCreateManyInput = {
    id?: number
    user: string
    refreshToken?: string | null
    accessToken?: string | null
    createdAt?: Date | string | null
  }

  export type TokenUpdateManyMutationInput = {
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateInput = {
    id?: number
    username: string
    firstName: string
    lastName: string
    email: string
    password: string
    avatarUrl?: string | null
    bio?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    age?: number | null
    CommunityUser?: CommunityUserCreateNestedManyWithoutUserInput
    Token?: TokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    firstName: string
    lastName: string
    email: string
    password: string
    avatarUrl?: string | null
    bio?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    age?: number | null
    CommunityUser?: CommunityUserUncheckedCreateNestedManyWithoutUserInput
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    CommunityUser?: CommunityUserUpdateManyWithoutUserNestedInput
    Token?: TokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    CommunityUser?: CommunityUserUncheckedUpdateManyWithoutUserNestedInput
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    firstName: string
    lastName: string
    email: string
    password: string
    avatarUrl?: string | null
    bio?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    age?: number | null
  }

  export type UserUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserRolesCreateInput = {
    id: number
    role?: string | null
    CommunityUser?: CommunityUserCreateNestedManyWithoutUserRolesInput
  }

  export type UserRolesUncheckedCreateInput = {
    id: number
    role?: string | null
    CommunityUser?: CommunityUserUncheckedCreateNestedManyWithoutUserRolesInput
  }

  export type UserRolesUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    CommunityUser?: CommunityUserUpdateManyWithoutUserRolesNestedInput
  }

  export type UserRolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    CommunityUser?: CommunityUserUncheckedUpdateManyWithoutUserRolesNestedInput
  }

  export type UserRolesCreateManyInput = {
    id: number
    role?: string | null
  }

  export type UserRolesUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailCreateInput = {
    email?: string | null
    verificationCode?: string | null
    messageId?: string | null
    createdAt?: Date | string | null
    EmailFor?: EmailForCreateNestedOneWithoutEmailInput
  }

  export type EmailUncheckedCreateInput = {
    id?: number
    email?: string | null
    verificationCode?: string | null
    messageId?: string | null
    for?: number | null
    createdAt?: Date | string | null
  }

  export type EmailUpdateInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EmailFor?: EmailForUpdateOneWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    for?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailCreateManyInput = {
    id?: number
    email?: string | null
    verificationCode?: string | null
    messageId?: string | null
    for?: number | null
    createdAt?: Date | string | null
  }

  export type EmailUpdateManyMutationInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    for?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailForCreateInput = {
    id: number
    for?: string | null
    Email?: EmailCreateNestedManyWithoutEmailForInput
  }

  export type EmailForUncheckedCreateInput = {
    id: number
    for?: string | null
    Email?: EmailUncheckedCreateNestedManyWithoutEmailForInput
  }

  export type EmailForUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    for?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: EmailUpdateManyWithoutEmailForNestedInput
  }

  export type EmailForUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    for?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: EmailUncheckedUpdateManyWithoutEmailForNestedInput
  }

  export type EmailForCreateManyInput = {
    id: number
    for?: string | null
  }

  export type EmailForUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    for?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailForUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    for?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeaderboardCreateInput = {
    community: number
    LeaderboardSubmission?: LeaderboardSubmissionCreateNestedManyWithoutLeaderboardInput
  }

  export type LeaderboardUncheckedCreateInput = {
    id?: number
    community: number
    LeaderboardSubmission?: LeaderboardSubmissionUncheckedCreateNestedManyWithoutLeaderboardInput
  }

  export type LeaderboardUpdateInput = {
    community?: IntFieldUpdateOperationsInput | number
    LeaderboardSubmission?: LeaderboardSubmissionUpdateManyWithoutLeaderboardNestedInput
  }

  export type LeaderboardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
    LeaderboardSubmission?: LeaderboardSubmissionUncheckedUpdateManyWithoutLeaderboardNestedInput
  }

  export type LeaderboardCreateManyInput = {
    id?: number
    community: number
  }

  export type LeaderboardUpdateManyMutationInput = {
    community?: IntFieldUpdateOperationsInput | number
  }

  export type LeaderboardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
  }

  export type LeaderboardSubmissionCreateInput = {
    user?: string | null
    community?: number | null
    entryUrl?: string | null
    verifiedBy?: number | null
    weight?: string | null
    type?: number | null
    verifiedAt?: Date | string | null
    rank?: number | null
    LeaderboardSubmissionType?: LeaderboardSubmissionTypeCreateNestedManyWithoutLeaderboardSubmissionInput
    Leaderboard?: LeaderboardCreateNestedOneWithoutLeaderboardSubmissionInput
  }

  export type LeaderboardSubmissionUncheckedCreateInput = {
    id?: number
    user?: string | null
    community?: number | null
    entryUrl?: string | null
    verifiedBy?: number | null
    weight?: string | null
    type?: number | null
    verifiedAt?: Date | string | null
    rank?: number | null
    leaderboardId?: number | null
    LeaderboardSubmissionType?: LeaderboardSubmissionTypeUncheckedCreateNestedManyWithoutLeaderboardSubmissionInput
  }

  export type LeaderboardSubmissionUpdateInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    LeaderboardSubmissionType?: LeaderboardSubmissionTypeUpdateManyWithoutLeaderboardSubmissionNestedInput
    Leaderboard?: LeaderboardUpdateOneWithoutLeaderboardSubmissionNestedInput
  }

  export type LeaderboardSubmissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    leaderboardId?: NullableIntFieldUpdateOperationsInput | number | null
    LeaderboardSubmissionType?: LeaderboardSubmissionTypeUncheckedUpdateManyWithoutLeaderboardSubmissionNestedInput
  }

  export type LeaderboardSubmissionCreateManyInput = {
    id?: number
    user?: string | null
    community?: number | null
    entryUrl?: string | null
    verifiedBy?: number | null
    weight?: string | null
    type?: number | null
    verifiedAt?: Date | string | null
    rank?: number | null
    leaderboardId?: number | null
  }

  export type LeaderboardSubmissionUpdateManyMutationInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LeaderboardSubmissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    leaderboardId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LeaderboardSubmissionTypeCreateInput = {
    id: number
    type?: string | null
    LeaderboardSubmission?: LeaderboardSubmissionCreateNestedOneWithoutLeaderboardSubmissionTypeInput
  }

  export type LeaderboardSubmissionTypeUncheckedCreateInput = {
    id: number
    type?: string | null
    leaderboardSubmissionId?: number | null
  }

  export type LeaderboardSubmissionTypeUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    LeaderboardSubmission?: LeaderboardSubmissionUpdateOneWithoutLeaderboardSubmissionTypeNestedInput
  }

  export type LeaderboardSubmissionTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    leaderboardSubmissionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LeaderboardSubmissionTypeCreateManyInput = {
    id: number
    type?: string | null
    leaderboardSubmissionId?: number | null
  }

  export type LeaderboardSubmissionTypeUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeaderboardSubmissionTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    leaderboardSubmissionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PendingPostStatusCreateInput = {
    id: number
    status?: string | null
    PendingPost?: PendingPostCreateNestedManyWithoutPendingPostStatusInput
  }

  export type PendingPostStatusUncheckedCreateInput = {
    id: number
    status?: string | null
    PendingPost?: PendingPostUncheckedCreateNestedManyWithoutPendingPostStatusInput
  }

  export type PendingPostStatusUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    PendingPost?: PendingPostUpdateManyWithoutPendingPostStatusNestedInput
  }

  export type PendingPostStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    PendingPost?: PendingPostUncheckedUpdateManyWithoutPendingPostStatusNestedInput
  }

  export type PendingPostStatusCreateManyInput = {
    id: number
    status?: string | null
  }

  export type PendingPostStatusUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PendingPostStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogLevelCreateInput = {
    id: number
    level?: string | null
    Log?: LogCreateNestedManyWithoutLogLevelInput
  }

  export type LogLevelUncheckedCreateInput = {
    id: number
    level?: string | null
    Log?: LogUncheckedCreateNestedManyWithoutLogLevelInput
  }

  export type LogLevelUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: NullableStringFieldUpdateOperationsInput | string | null
    Log?: LogUpdateManyWithoutLogLevelNestedInput
  }

  export type LogLevelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: NullableStringFieldUpdateOperationsInput | string | null
    Log?: LogUncheckedUpdateManyWithoutLogLevelNestedInput
  }

  export type LogLevelCreateManyInput = {
    id: number
    level?: string | null
  }

  export type LogLevelUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogLevelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogTypeCreateInput = {
    id: number
    type?: string | null
    Log?: LogCreateNestedManyWithoutLogTypeInput
  }

  export type LogTypeUncheckedCreateInput = {
    id: number
    type?: string | null
    Log?: LogUncheckedCreateNestedManyWithoutLogTypeInput
  }

  export type LogTypeUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Log?: LogUpdateManyWithoutLogTypeNestedInput
  }

  export type LogTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Log?: LogUncheckedUpdateManyWithoutLogTypeNestedInput
  }

  export type LogTypeCreateManyInput = {
    id: number
    type?: string | null
  }

  export type LogTypeUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SuspiciousLoginCreateInput = {
    user?: string | null
    ip?: string | null
    country?: string | null
    city?: string | null
    os?: string | null
    device?: string | null
    deviceType?: string | null
    isTrusted?: boolean | null
    unverifiedAttempts?: number | null
    isBlocked?: boolean | null
  }

  export type SuspiciousLoginUncheckedCreateInput = {
    id?: number
    user?: string | null
    ip?: string | null
    country?: string | null
    city?: string | null
    os?: string | null
    device?: string | null
    deviceType?: string | null
    isTrusted?: boolean | null
    unverifiedAttempts?: number | null
    isBlocked?: boolean | null
  }

  export type SuspiciousLoginUpdateInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    unverifiedAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SuspiciousLoginUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    unverifiedAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SuspiciousLoginCreateManyInput = {
    id?: number
    user?: string | null
    ip?: string | null
    country?: string | null
    city?: string | null
    os?: string | null
    device?: string | null
    deviceType?: string | null
    isTrusted?: boolean | null
    unverifiedAttempts?: number | null
    isBlocked?: boolean | null
  }

  export type SuspiciousLoginUpdateManyMutationInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    unverifiedAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SuspiciousLoginUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    unverifiedAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CommunityUserCreateInput = {
    verifiedAt?: Date | string | null
    Community: CommunityCreateNestedOneWithoutCommunityUserInput
    UserRoles: UserRolesCreateNestedOneWithoutCommunityUserInput
    User: UserCreateNestedOneWithoutCommunityUserInput
  }

  export type CommunityUserUncheckedCreateInput = {
    id?: number
    community: number
    user: string
    role: number
    verifiedAt?: Date | string | null
  }

  export type CommunityUserUpdateInput = {
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Community?: CommunityUpdateOneRequiredWithoutCommunityUserNestedInput
    UserRoles?: UserRolesUpdateOneRequiredWithoutCommunityUserNestedInput
    User?: UserUpdateOneRequiredWithoutCommunityUserNestedInput
  }

  export type CommunityUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    role?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommunityUserCreateManyInput = {
    id?: number
    community: number
    user: string
    role: number
    verifiedAt?: Date | string | null
  }

  export type CommunityUserUpdateManyMutationInput = {
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommunityUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    role?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type AdminTokenNullableRelationFilter = {
    is?: AdminTokenWhereInput | null
    isNot?: AdminTokenWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type AdminNullableRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type AdminTokenCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    accessToken?: SortOrder
  }

  export type AdminTokenAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    accessToken?: SortOrder
  }

  export type AdminTokenMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    accessToken?: SortOrder
  }

  export type AdminTokenSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CommunityNullableRelationFilter = {
    is?: CommunityWhereInput | null
    isNot?: CommunityWhereInput | null
  }

  export type BannedUsersCountOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    user?: SortOrder
    reasonId?: SortOrder
  }

  export type BannedUsersAvgOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    reasonId?: SortOrder
  }

  export type BannedUsersMaxOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    user?: SortOrder
    reasonId?: SortOrder
  }

  export type BannedUsersMinOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    user?: SortOrder
    reasonId?: SortOrder
  }

  export type BannedUsersSumOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    reasonId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PostNullableRelationFilter = {
    is?: PostWhereInput | null
    isNot?: PostWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    user?: SortOrder
    post?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    post?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    user?: SortOrder
    post?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    user?: SortOrder
    post?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    post?: SortOrder
  }

  export type CommunityUserListRelationFilter = {
    every?: CommunityUserWhereInput
    some?: CommunityUserWhereInput
    none?: CommunityUserWhereInput
  }

  export type CommunityRequestListRelationFilter = {
    every?: CommunityRequestWhereInput
    some?: CommunityRequestWhereInput
    none?: CommunityRequestWhereInput
  }

  export type BannedUsersListRelationFilter = {
    every?: BannedUsersWhereInput
    some?: BannedUsersWhereInput
    none?: BannedUsersWhereInput
  }

  export type CommunityUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BannedUsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CommunityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CommunityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CommunityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CommunitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CommunityRequestCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    community?: SortOrder
    requestedAt?: SortOrder
    message?: SortOrder
  }

  export type CommunityRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type CommunityRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    community?: SortOrder
    requestedAt?: SortOrder
    message?: SortOrder
  }

  export type CommunityRequestMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    community?: SortOrder
    requestedAt?: SortOrder
    message?: SortOrder
  }

  export type CommunityRequestSumOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ContextCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    ip?: SortOrder
    country?: SortOrder
    city?: SortOrder
    os?: SortOrder
    device?: SortOrder
    deviceType?: SortOrder
    isTrusted?: SortOrder
  }

  export type ContextAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContextMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    ip?: SortOrder
    country?: SortOrder
    city?: SortOrder
    os?: SortOrder
    device?: SortOrder
    deviceType?: SortOrder
    isTrusted?: SortOrder
  }

  export type ContextMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    ip?: SortOrder
    country?: SortOrder
    city?: SortOrder
    os?: SortOrder
    device?: SortOrder
    deviceType?: SortOrder
    isTrusted?: SortOrder
  }

  export type ContextSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type LikeCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    post?: SortOrder
  }

  export type LikeAvgOrderByAggregateInput = {
    id?: SortOrder
    post?: SortOrder
  }

  export type LikeMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    post?: SortOrder
  }

  export type LikeMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    post?: SortOrder
  }

  export type LikeSumOrderByAggregateInput = {
    id?: SortOrder
    post?: SortOrder
  }

  export type LogLevelNullableRelationFilter = {
    is?: LogLevelWhereInput | null
    isNot?: LogLevelWhereInput | null
  }

  export type LogTypeNullableRelationFilter = {
    is?: LogTypeWhereInput | null
    isNot?: LogTypeWhereInput | null
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    context?: SortOrder
    message?: SortOrder
    type?: SortOrder
    level?: SortOrder
    timestamp?: SortOrder
  }

  export type LogAvgOrderByAggregateInput = {
    id?: SortOrder
    context?: SortOrder
    type?: SortOrder
    level?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    context?: SortOrder
    message?: SortOrder
    type?: SortOrder
    level?: SortOrder
    timestamp?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    context?: SortOrder
    message?: SortOrder
    type?: SortOrder
    level?: SortOrder
    timestamp?: SortOrder
  }

  export type LogSumOrderByAggregateInput = {
    id?: SortOrder
    context?: SortOrder
    type?: SortOrder
    level?: SortOrder
  }

  export type PendingPostStatusListRelationFilter = {
    every?: PendingPostStatusWhereInput
    some?: PendingPostStatusWhereInput
    none?: PendingPostStatusWhereInput
  }

  export type PendingPostStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PendingPostCountOrderByAggregateInput = {
    id?: SortOrder
    Content?: SortOrder
    fileUrl?: SortOrder
    community?: SortOrder
    user?: SortOrder
    caption?: SortOrder
    status?: SortOrder
    confirmationToken?: SortOrder
  }

  export type PendingPostAvgOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    status?: SortOrder
  }

  export type PendingPostMaxOrderByAggregateInput = {
    id?: SortOrder
    Content?: SortOrder
    fileUrl?: SortOrder
    community?: SortOrder
    user?: SortOrder
    caption?: SortOrder
    status?: SortOrder
    confirmationToken?: SortOrder
  }

  export type PendingPostMinOrderByAggregateInput = {
    id?: SortOrder
    Content?: SortOrder
    fileUrl?: SortOrder
    community?: SortOrder
    user?: SortOrder
    caption?: SortOrder
    status?: SortOrder
    confirmationToken?: SortOrder
  }

  export type PendingPostSumOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    status?: SortOrder
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type LikeListRelationFilter = {
    every?: LikeWhereInput
    some?: LikeWhereInput
    none?: LikeWhereInput
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    Content?: SortOrder
    fileUrl?: SortOrder
    community?: SortOrder
    user?: SortOrder
    caption?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    Content?: SortOrder
    fileUrl?: SortOrder
    community?: SortOrder
    user?: SortOrder
    caption?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    Content?: SortOrder
    fileUrl?: SortOrder
    community?: SortOrder
    user?: SortOrder
    caption?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type PreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    enableContextBasedAuth?: SortOrder
  }

  export type PreferencesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    enableContextBasedAuth?: SortOrder
  }

  export type PreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    enableContextBasedAuth?: SortOrder
  }

  export type PreferencesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RelationshipCountOrderByAggregateInput = {
    id?: SortOrder
    follower?: SortOrder
    following?: SortOrder
  }

  export type RelationshipAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RelationshipMaxOrderByAggregateInput = {
    id?: SortOrder
    follower?: SortOrder
    following?: SortOrder
  }

  export type RelationshipMinOrderByAggregateInput = {
    id?: SortOrder
    follower?: SortOrder
    following?: SortOrder
  }

  export type RelationshipSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    reportedBy?: SortOrder
    post?: SortOrder
    community?: SortOrder
    reportReason?: SortOrder
    reportDate?: SortOrder
  }

  export type ReportAvgOrderByAggregateInput = {
    id?: SortOrder
    post?: SortOrder
    community?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reportedBy?: SortOrder
    post?: SortOrder
    community?: SortOrder
    reportReason?: SortOrder
    reportDate?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    reportedBy?: SortOrder
    post?: SortOrder
    community?: SortOrder
    reportReason?: SortOrder
    reportDate?: SortOrder
  }

  export type ReportSumOrderByAggregateInput = {
    id?: SortOrder
    post?: SortOrder
    community?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TokenCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
  }

  export type TokenAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TokenMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
  }

  export type TokenMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
  }

  export type TokenSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type TokenListRelationFilter = {
    every?: TokenWhereInput
    some?: TokenWhereInput
    none?: TokenWhereInput
  }

  export type TokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    isEmailVerified?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    age?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    age?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    isEmailVerified?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    age?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    isEmailVerified?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    age?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    age?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UserRolesCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
  }

  export type UserRolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserRolesMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
  }

  export type UserRolesMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
  }

  export type UserRolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmailForNullableRelationFilter = {
    is?: EmailForWhereInput | null
    isNot?: EmailForWhereInput | null
  }

  export type EmailCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    verificationCode?: SortOrder
    messageId?: SortOrder
    for?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailAvgOrderByAggregateInput = {
    id?: SortOrder
    for?: SortOrder
  }

  export type EmailMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    verificationCode?: SortOrder
    messageId?: SortOrder
    for?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    verificationCode?: SortOrder
    messageId?: SortOrder
    for?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailSumOrderByAggregateInput = {
    id?: SortOrder
    for?: SortOrder
  }

  export type EmailListRelationFilter = {
    every?: EmailWhereInput
    some?: EmailWhereInput
    none?: EmailWhereInput
  }

  export type EmailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailForCountOrderByAggregateInput = {
    id?: SortOrder
    for?: SortOrder
  }

  export type EmailForAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmailForMaxOrderByAggregateInput = {
    id?: SortOrder
    for?: SortOrder
  }

  export type EmailForMinOrderByAggregateInput = {
    id?: SortOrder
    for?: SortOrder
  }

  export type EmailForSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LeaderboardSubmissionListRelationFilter = {
    every?: LeaderboardSubmissionWhereInput
    some?: LeaderboardSubmissionWhereInput
    none?: LeaderboardSubmissionWhereInput
  }

  export type LeaderboardSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaderboardCountOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type LeaderboardAvgOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type LeaderboardMaxOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type LeaderboardMinOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type LeaderboardSumOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
  }

  export type LeaderboardSubmissionTypeListRelationFilter = {
    every?: LeaderboardSubmissionTypeWhereInput
    some?: LeaderboardSubmissionTypeWhereInput
    none?: LeaderboardSubmissionTypeWhereInput
  }

  export type LeaderboardNullableRelationFilter = {
    is?: LeaderboardWhereInput | null
    isNot?: LeaderboardWhereInput | null
  }

  export type LeaderboardSubmissionTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaderboardSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    community?: SortOrder
    entryUrl?: SortOrder
    verifiedBy?: SortOrder
    weight?: SortOrder
    type?: SortOrder
    verifiedAt?: SortOrder
    rank?: SortOrder
    leaderboardId?: SortOrder
  }

  export type LeaderboardSubmissionAvgOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    verifiedBy?: SortOrder
    type?: SortOrder
    rank?: SortOrder
    leaderboardId?: SortOrder
  }

  export type LeaderboardSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    community?: SortOrder
    entryUrl?: SortOrder
    verifiedBy?: SortOrder
    weight?: SortOrder
    type?: SortOrder
    verifiedAt?: SortOrder
    rank?: SortOrder
    leaderboardId?: SortOrder
  }

  export type LeaderboardSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    community?: SortOrder
    entryUrl?: SortOrder
    verifiedBy?: SortOrder
    weight?: SortOrder
    type?: SortOrder
    verifiedAt?: SortOrder
    rank?: SortOrder
    leaderboardId?: SortOrder
  }

  export type LeaderboardSubmissionSumOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    verifiedBy?: SortOrder
    type?: SortOrder
    rank?: SortOrder
    leaderboardId?: SortOrder
  }

  export type LeaderboardSubmissionNullableRelationFilter = {
    is?: LeaderboardSubmissionWhereInput | null
    isNot?: LeaderboardSubmissionWhereInput | null
  }

  export type LeaderboardSubmissionTypeCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    leaderboardSubmissionId?: SortOrder
  }

  export type LeaderboardSubmissionTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    leaderboardSubmissionId?: SortOrder
  }

  export type LeaderboardSubmissionTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    leaderboardSubmissionId?: SortOrder
  }

  export type LeaderboardSubmissionTypeMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    leaderboardSubmissionId?: SortOrder
  }

  export type LeaderboardSubmissionTypeSumOrderByAggregateInput = {
    id?: SortOrder
    leaderboardSubmissionId?: SortOrder
  }

  export type PendingPostListRelationFilter = {
    every?: PendingPostWhereInput
    some?: PendingPostWhereInput
    none?: PendingPostWhereInput
  }

  export type PendingPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PendingPostStatusCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type PendingPostStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PendingPostStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type PendingPostStatusMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type PendingPostStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LogListRelationFilter = {
    every?: LogWhereInput
    some?: LogWhereInput
    none?: LogWhereInput
  }

  export type LogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogLevelCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
  }

  export type LogLevelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LogLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
  }

  export type LogLevelMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
  }

  export type LogLevelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LogTypeCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type LogTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LogTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type LogTypeMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type LogTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SuspiciousLoginCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    ip?: SortOrder
    country?: SortOrder
    city?: SortOrder
    os?: SortOrder
    device?: SortOrder
    deviceType?: SortOrder
    isTrusted?: SortOrder
    unverifiedAttempts?: SortOrder
    isBlocked?: SortOrder
  }

  export type SuspiciousLoginAvgOrderByAggregateInput = {
    id?: SortOrder
    unverifiedAttempts?: SortOrder
  }

  export type SuspiciousLoginMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    ip?: SortOrder
    country?: SortOrder
    city?: SortOrder
    os?: SortOrder
    device?: SortOrder
    deviceType?: SortOrder
    isTrusted?: SortOrder
    unverifiedAttempts?: SortOrder
    isBlocked?: SortOrder
  }

  export type SuspiciousLoginMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    ip?: SortOrder
    country?: SortOrder
    city?: SortOrder
    os?: SortOrder
    device?: SortOrder
    deviceType?: SortOrder
    isTrusted?: SortOrder
    unverifiedAttempts?: SortOrder
    isBlocked?: SortOrder
  }

  export type SuspiciousLoginSumOrderByAggregateInput = {
    id?: SortOrder
    unverifiedAttempts?: SortOrder
  }

  export type CommunityRelationFilter = {
    is?: CommunityWhereInput
    isNot?: CommunityWhereInput
  }

  export type UserRolesRelationFilter = {
    is?: UserRolesWhereInput
    isNot?: UserRolesWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CommunityUserCountOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    user?: SortOrder
    role?: SortOrder
    verifiedAt?: SortOrder
  }

  export type CommunityUserAvgOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    role?: SortOrder
  }

  export type CommunityUserMaxOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    user?: SortOrder
    role?: SortOrder
    verifiedAt?: SortOrder
  }

  export type CommunityUserMinOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    user?: SortOrder
    role?: SortOrder
    verifiedAt?: SortOrder
  }

  export type CommunityUserSumOrderByAggregateInput = {
    id?: SortOrder
    community?: SortOrder
    role?: SortOrder
  }

  export type AdminTokenCreateNestedOneWithoutAdminInput = {
    create?: XOR<AdminTokenCreateWithoutAdminInput, AdminTokenUncheckedCreateWithoutAdminInput>
    connectOrCreate?: AdminTokenCreateOrConnectWithoutAdminInput
    connect?: AdminTokenWhereUniqueInput
  }

  export type AdminTokenUncheckedCreateNestedOneWithoutAdminInput = {
    create?: XOR<AdminTokenCreateWithoutAdminInput, AdminTokenUncheckedCreateWithoutAdminInput>
    connectOrCreate?: AdminTokenCreateOrConnectWithoutAdminInput
    connect?: AdminTokenWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AdminTokenUpdateOneWithoutAdminNestedInput = {
    create?: XOR<AdminTokenCreateWithoutAdminInput, AdminTokenUncheckedCreateWithoutAdminInput>
    connectOrCreate?: AdminTokenCreateOrConnectWithoutAdminInput
    upsert?: AdminTokenUpsertWithoutAdminInput
    disconnect?: AdminTokenWhereInput | boolean
    delete?: AdminTokenWhereInput | boolean
    connect?: AdminTokenWhereUniqueInput
    update?: XOR<XOR<AdminTokenUpdateToOneWithWhereWithoutAdminInput, AdminTokenUpdateWithoutAdminInput>, AdminTokenUncheckedUpdateWithoutAdminInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AdminTokenUncheckedUpdateOneWithoutAdminNestedInput = {
    create?: XOR<AdminTokenCreateWithoutAdminInput, AdminTokenUncheckedCreateWithoutAdminInput>
    connectOrCreate?: AdminTokenCreateOrConnectWithoutAdminInput
    upsert?: AdminTokenUpsertWithoutAdminInput
    disconnect?: AdminTokenWhereInput | boolean
    delete?: AdminTokenWhereInput | boolean
    connect?: AdminTokenWhereUniqueInput
    update?: XOR<XOR<AdminTokenUpdateToOneWithWhereWithoutAdminInput, AdminTokenUpdateWithoutAdminInput>, AdminTokenUncheckedUpdateWithoutAdminInput>
  }

  export type AdminCreateNestedOneWithoutAdminTokenInput = {
    create?: XOR<AdminCreateWithoutAdminTokenInput, AdminUncheckedCreateWithoutAdminTokenInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAdminTokenInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminUpdateOneWithoutAdminTokenNestedInput = {
    create?: XOR<AdminCreateWithoutAdminTokenInput, AdminUncheckedCreateWithoutAdminTokenInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAdminTokenInput
    upsert?: AdminUpsertWithoutAdminTokenInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAdminTokenInput, AdminUpdateWithoutAdminTokenInput>, AdminUncheckedUpdateWithoutAdminTokenInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type CommunityCreateNestedOneWithoutBannedUsersInput = {
    create?: XOR<CommunityCreateWithoutBannedUsersInput, CommunityUncheckedCreateWithoutBannedUsersInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutBannedUsersInput
    connect?: CommunityWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CommunityUpdateOneWithoutBannedUsersNestedInput = {
    create?: XOR<CommunityCreateWithoutBannedUsersInput, CommunityUncheckedCreateWithoutBannedUsersInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutBannedUsersInput
    upsert?: CommunityUpsertWithoutBannedUsersInput
    disconnect?: CommunityWhereInput | boolean
    delete?: CommunityWhereInput | boolean
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutBannedUsersInput, CommunityUpdateWithoutBannedUsersInput>, CommunityUncheckedUpdateWithoutBannedUsersInput>
  }

  export type PostCreateNestedOneWithoutCommentInput = {
    create?: XOR<PostCreateWithoutCommentInput, PostUncheckedCreateWithoutCommentInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentInput
    connect?: PostWhereUniqueInput
  }

  export type PostUpdateOneWithoutCommentNestedInput = {
    create?: XOR<PostCreateWithoutCommentInput, PostUncheckedCreateWithoutCommentInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentInput
    upsert?: PostUpsertWithoutCommentInput
    disconnect?: PostWhereInput | boolean
    delete?: PostWhereInput | boolean
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentInput, PostUpdateWithoutCommentInput>, PostUncheckedUpdateWithoutCommentInput>
  }

  export type CommunityUserCreateNestedManyWithoutCommunityInput = {
    create?: XOR<CommunityUserCreateWithoutCommunityInput, CommunityUserUncheckedCreateWithoutCommunityInput> | CommunityUserCreateWithoutCommunityInput[] | CommunityUserUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityUserCreateOrConnectWithoutCommunityInput | CommunityUserCreateOrConnectWithoutCommunityInput[]
    createMany?: CommunityUserCreateManyCommunityInputEnvelope
    connect?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
  }

  export type CommunityRequestCreateNestedManyWithoutCommunityInput = {
    create?: XOR<CommunityRequestCreateWithoutCommunityInput, CommunityRequestUncheckedCreateWithoutCommunityInput> | CommunityRequestCreateWithoutCommunityInput[] | CommunityRequestUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityRequestCreateOrConnectWithoutCommunityInput | CommunityRequestCreateOrConnectWithoutCommunityInput[]
    createMany?: CommunityRequestCreateManyCommunityInputEnvelope
    connect?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
  }

  export type BannedUsersCreateNestedManyWithoutCommunityInput = {
    create?: XOR<BannedUsersCreateWithoutCommunityInput, BannedUsersUncheckedCreateWithoutCommunityInput> | BannedUsersCreateWithoutCommunityInput[] | BannedUsersUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: BannedUsersCreateOrConnectWithoutCommunityInput | BannedUsersCreateOrConnectWithoutCommunityInput[]
    createMany?: BannedUsersCreateManyCommunityInputEnvelope
    connect?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
  }

  export type CommunityUserUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<CommunityUserCreateWithoutCommunityInput, CommunityUserUncheckedCreateWithoutCommunityInput> | CommunityUserCreateWithoutCommunityInput[] | CommunityUserUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityUserCreateOrConnectWithoutCommunityInput | CommunityUserCreateOrConnectWithoutCommunityInput[]
    createMany?: CommunityUserCreateManyCommunityInputEnvelope
    connect?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
  }

  export type CommunityRequestUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<CommunityRequestCreateWithoutCommunityInput, CommunityRequestUncheckedCreateWithoutCommunityInput> | CommunityRequestCreateWithoutCommunityInput[] | CommunityRequestUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityRequestCreateOrConnectWithoutCommunityInput | CommunityRequestCreateOrConnectWithoutCommunityInput[]
    createMany?: CommunityRequestCreateManyCommunityInputEnvelope
    connect?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
  }

  export type BannedUsersUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<BannedUsersCreateWithoutCommunityInput, BannedUsersUncheckedCreateWithoutCommunityInput> | BannedUsersCreateWithoutCommunityInput[] | BannedUsersUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: BannedUsersCreateOrConnectWithoutCommunityInput | BannedUsersCreateOrConnectWithoutCommunityInput[]
    createMany?: BannedUsersCreateManyCommunityInputEnvelope
    connect?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
  }

  export type CommunityUserUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<CommunityUserCreateWithoutCommunityInput, CommunityUserUncheckedCreateWithoutCommunityInput> | CommunityUserCreateWithoutCommunityInput[] | CommunityUserUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityUserCreateOrConnectWithoutCommunityInput | CommunityUserCreateOrConnectWithoutCommunityInput[]
    upsert?: CommunityUserUpsertWithWhereUniqueWithoutCommunityInput | CommunityUserUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: CommunityUserCreateManyCommunityInputEnvelope
    set?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    disconnect?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    delete?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    connect?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    update?: CommunityUserUpdateWithWhereUniqueWithoutCommunityInput | CommunityUserUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: CommunityUserUpdateManyWithWhereWithoutCommunityInput | CommunityUserUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: CommunityUserScalarWhereInput | CommunityUserScalarWhereInput[]
  }

  export type CommunityRequestUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<CommunityRequestCreateWithoutCommunityInput, CommunityRequestUncheckedCreateWithoutCommunityInput> | CommunityRequestCreateWithoutCommunityInput[] | CommunityRequestUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityRequestCreateOrConnectWithoutCommunityInput | CommunityRequestCreateOrConnectWithoutCommunityInput[]
    upsert?: CommunityRequestUpsertWithWhereUniqueWithoutCommunityInput | CommunityRequestUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: CommunityRequestCreateManyCommunityInputEnvelope
    set?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    disconnect?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    delete?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    connect?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    update?: CommunityRequestUpdateWithWhereUniqueWithoutCommunityInput | CommunityRequestUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: CommunityRequestUpdateManyWithWhereWithoutCommunityInput | CommunityRequestUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: CommunityRequestScalarWhereInput | CommunityRequestScalarWhereInput[]
  }

  export type BannedUsersUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<BannedUsersCreateWithoutCommunityInput, BannedUsersUncheckedCreateWithoutCommunityInput> | BannedUsersCreateWithoutCommunityInput[] | BannedUsersUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: BannedUsersCreateOrConnectWithoutCommunityInput | BannedUsersCreateOrConnectWithoutCommunityInput[]
    upsert?: BannedUsersUpsertWithWhereUniqueWithoutCommunityInput | BannedUsersUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: BannedUsersCreateManyCommunityInputEnvelope
    set?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    disconnect?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    delete?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    connect?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    update?: BannedUsersUpdateWithWhereUniqueWithoutCommunityInput | BannedUsersUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: BannedUsersUpdateManyWithWhereWithoutCommunityInput | BannedUsersUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: BannedUsersScalarWhereInput | BannedUsersScalarWhereInput[]
  }

  export type CommunityUserUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<CommunityUserCreateWithoutCommunityInput, CommunityUserUncheckedCreateWithoutCommunityInput> | CommunityUserCreateWithoutCommunityInput[] | CommunityUserUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityUserCreateOrConnectWithoutCommunityInput | CommunityUserCreateOrConnectWithoutCommunityInput[]
    upsert?: CommunityUserUpsertWithWhereUniqueWithoutCommunityInput | CommunityUserUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: CommunityUserCreateManyCommunityInputEnvelope
    set?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    disconnect?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    delete?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    connect?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    update?: CommunityUserUpdateWithWhereUniqueWithoutCommunityInput | CommunityUserUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: CommunityUserUpdateManyWithWhereWithoutCommunityInput | CommunityUserUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: CommunityUserScalarWhereInput | CommunityUserScalarWhereInput[]
  }

  export type CommunityRequestUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<CommunityRequestCreateWithoutCommunityInput, CommunityRequestUncheckedCreateWithoutCommunityInput> | CommunityRequestCreateWithoutCommunityInput[] | CommunityRequestUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityRequestCreateOrConnectWithoutCommunityInput | CommunityRequestCreateOrConnectWithoutCommunityInput[]
    upsert?: CommunityRequestUpsertWithWhereUniqueWithoutCommunityInput | CommunityRequestUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: CommunityRequestCreateManyCommunityInputEnvelope
    set?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    disconnect?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    delete?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    connect?: CommunityRequestWhereUniqueInput | CommunityRequestWhereUniqueInput[]
    update?: CommunityRequestUpdateWithWhereUniqueWithoutCommunityInput | CommunityRequestUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: CommunityRequestUpdateManyWithWhereWithoutCommunityInput | CommunityRequestUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: CommunityRequestScalarWhereInput | CommunityRequestScalarWhereInput[]
  }

  export type BannedUsersUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<BannedUsersCreateWithoutCommunityInput, BannedUsersUncheckedCreateWithoutCommunityInput> | BannedUsersCreateWithoutCommunityInput[] | BannedUsersUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: BannedUsersCreateOrConnectWithoutCommunityInput | BannedUsersCreateOrConnectWithoutCommunityInput[]
    upsert?: BannedUsersUpsertWithWhereUniqueWithoutCommunityInput | BannedUsersUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: BannedUsersCreateManyCommunityInputEnvelope
    set?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    disconnect?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    delete?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    connect?: BannedUsersWhereUniqueInput | BannedUsersWhereUniqueInput[]
    update?: BannedUsersUpdateWithWhereUniqueWithoutCommunityInput | BannedUsersUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: BannedUsersUpdateManyWithWhereWithoutCommunityInput | BannedUsersUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: BannedUsersScalarWhereInput | BannedUsersScalarWhereInput[]
  }

  export type CommunityCreateNestedOneWithoutCommunityRequestInput = {
    create?: XOR<CommunityCreateWithoutCommunityRequestInput, CommunityUncheckedCreateWithoutCommunityRequestInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutCommunityRequestInput
    connect?: CommunityWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CommunityUpdateOneWithoutCommunityRequestNestedInput = {
    create?: XOR<CommunityCreateWithoutCommunityRequestInput, CommunityUncheckedCreateWithoutCommunityRequestInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutCommunityRequestInput
    upsert?: CommunityUpsertWithoutCommunityRequestInput
    disconnect?: CommunityWhereInput | boolean
    delete?: CommunityWhereInput | boolean
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutCommunityRequestInput, CommunityUpdateWithoutCommunityRequestInput>, CommunityUncheckedUpdateWithoutCommunityRequestInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type PostCreateNestedOneWithoutLikeInput = {
    create?: XOR<PostCreateWithoutLikeInput, PostUncheckedCreateWithoutLikeInput>
    connectOrCreate?: PostCreateOrConnectWithoutLikeInput
    connect?: PostWhereUniqueInput
  }

  export type PostUpdateOneWithoutLikeNestedInput = {
    create?: XOR<PostCreateWithoutLikeInput, PostUncheckedCreateWithoutLikeInput>
    connectOrCreate?: PostCreateOrConnectWithoutLikeInput
    upsert?: PostUpsertWithoutLikeInput
    disconnect?: PostWhereInput | boolean
    delete?: PostWhereInput | boolean
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutLikeInput, PostUpdateWithoutLikeInput>, PostUncheckedUpdateWithoutLikeInput>
  }

  export type LogLevelCreateNestedOneWithoutLogInput = {
    create?: XOR<LogLevelCreateWithoutLogInput, LogLevelUncheckedCreateWithoutLogInput>
    connectOrCreate?: LogLevelCreateOrConnectWithoutLogInput
    connect?: LogLevelWhereUniqueInput
  }

  export type LogTypeCreateNestedOneWithoutLogInput = {
    create?: XOR<LogTypeCreateWithoutLogInput, LogTypeUncheckedCreateWithoutLogInput>
    connectOrCreate?: LogTypeCreateOrConnectWithoutLogInput
    connect?: LogTypeWhereUniqueInput
  }

  export type LogLevelUpdateOneWithoutLogNestedInput = {
    create?: XOR<LogLevelCreateWithoutLogInput, LogLevelUncheckedCreateWithoutLogInput>
    connectOrCreate?: LogLevelCreateOrConnectWithoutLogInput
    upsert?: LogLevelUpsertWithoutLogInput
    disconnect?: LogLevelWhereInput | boolean
    delete?: LogLevelWhereInput | boolean
    connect?: LogLevelWhereUniqueInput
    update?: XOR<XOR<LogLevelUpdateToOneWithWhereWithoutLogInput, LogLevelUpdateWithoutLogInput>, LogLevelUncheckedUpdateWithoutLogInput>
  }

  export type LogTypeUpdateOneWithoutLogNestedInput = {
    create?: XOR<LogTypeCreateWithoutLogInput, LogTypeUncheckedCreateWithoutLogInput>
    connectOrCreate?: LogTypeCreateOrConnectWithoutLogInput
    upsert?: LogTypeUpsertWithoutLogInput
    disconnect?: LogTypeWhereInput | boolean
    delete?: LogTypeWhereInput | boolean
    connect?: LogTypeWhereUniqueInput
    update?: XOR<XOR<LogTypeUpdateToOneWithWhereWithoutLogInput, LogTypeUpdateWithoutLogInput>, LogTypeUncheckedUpdateWithoutLogInput>
  }

  export type PendingPostStatusCreateNestedManyWithoutPendingPostInput = {
    create?: XOR<PendingPostStatusCreateWithoutPendingPostInput, PendingPostStatusUncheckedCreateWithoutPendingPostInput> | PendingPostStatusCreateWithoutPendingPostInput[] | PendingPostStatusUncheckedCreateWithoutPendingPostInput[]
    connectOrCreate?: PendingPostStatusCreateOrConnectWithoutPendingPostInput | PendingPostStatusCreateOrConnectWithoutPendingPostInput[]
    connect?: PendingPostStatusWhereUniqueInput | PendingPostStatusWhereUniqueInput[]
  }

  export type PendingPostStatusUncheckedCreateNestedManyWithoutPendingPostInput = {
    create?: XOR<PendingPostStatusCreateWithoutPendingPostInput, PendingPostStatusUncheckedCreateWithoutPendingPostInput> | PendingPostStatusCreateWithoutPendingPostInput[] | PendingPostStatusUncheckedCreateWithoutPendingPostInput[]
    connectOrCreate?: PendingPostStatusCreateOrConnectWithoutPendingPostInput | PendingPostStatusCreateOrConnectWithoutPendingPostInput[]
    connect?: PendingPostStatusWhereUniqueInput | PendingPostStatusWhereUniqueInput[]
  }

  export type PendingPostStatusUpdateManyWithoutPendingPostNestedInput = {
    create?: XOR<PendingPostStatusCreateWithoutPendingPostInput, PendingPostStatusUncheckedCreateWithoutPendingPostInput> | PendingPostStatusCreateWithoutPendingPostInput[] | PendingPostStatusUncheckedCreateWithoutPendingPostInput[]
    connectOrCreate?: PendingPostStatusCreateOrConnectWithoutPendingPostInput | PendingPostStatusCreateOrConnectWithoutPendingPostInput[]
    upsert?: PendingPostStatusUpsertWithWhereUniqueWithoutPendingPostInput | PendingPostStatusUpsertWithWhereUniqueWithoutPendingPostInput[]
    set?: PendingPostStatusWhereUniqueInput | PendingPostStatusWhereUniqueInput[]
    disconnect?: PendingPostStatusWhereUniqueInput | PendingPostStatusWhereUniqueInput[]
    delete?: PendingPostStatusWhereUniqueInput | PendingPostStatusWhereUniqueInput[]
    connect?: PendingPostStatusWhereUniqueInput | PendingPostStatusWhereUniqueInput[]
    update?: PendingPostStatusUpdateWithWhereUniqueWithoutPendingPostInput | PendingPostStatusUpdateWithWhereUniqueWithoutPendingPostInput[]
    updateMany?: PendingPostStatusUpdateManyWithWhereWithoutPendingPostInput | PendingPostStatusUpdateManyWithWhereWithoutPendingPostInput[]
    deleteMany?: PendingPostStatusScalarWhereInput | PendingPostStatusScalarWhereInput[]
  }

  export type PendingPostStatusUncheckedUpdateManyWithoutPendingPostNestedInput = {
    create?: XOR<PendingPostStatusCreateWithoutPendingPostInput, PendingPostStatusUncheckedCreateWithoutPendingPostInput> | PendingPostStatusCreateWithoutPendingPostInput[] | PendingPostStatusUncheckedCreateWithoutPendingPostInput[]
    connectOrCreate?: PendingPostStatusCreateOrConnectWithoutPendingPostInput | PendingPostStatusCreateOrConnectWithoutPendingPostInput[]
    upsert?: PendingPostStatusUpsertWithWhereUniqueWithoutPendingPostInput | PendingPostStatusUpsertWithWhereUniqueWithoutPendingPostInput[]
    set?: PendingPostStatusWhereUniqueInput | PendingPostStatusWhereUniqueInput[]
    disconnect?: PendingPostStatusWhereUniqueInput | PendingPostStatusWhereUniqueInput[]
    delete?: PendingPostStatusWhereUniqueInput | PendingPostStatusWhereUniqueInput[]
    connect?: PendingPostStatusWhereUniqueInput | PendingPostStatusWhereUniqueInput[]
    update?: PendingPostStatusUpdateWithWhereUniqueWithoutPendingPostInput | PendingPostStatusUpdateWithWhereUniqueWithoutPendingPostInput[]
    updateMany?: PendingPostStatusUpdateManyWithWhereWithoutPendingPostInput | PendingPostStatusUpdateManyWithWhereWithoutPendingPostInput[]
    deleteMany?: PendingPostStatusScalarWhereInput | PendingPostStatusScalarWhereInput[]
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutPostInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutPostNestedInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPostInput | LikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPostInput | LikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPostInput | LikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPostInput | LikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPostInput | LikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPostInput | LikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTokenInput = {
    create?: XOR<UserCreateWithoutTokenInput, UserUncheckedCreateWithoutTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutTokenNestedInput = {
    create?: XOR<UserCreateWithoutTokenInput, UserUncheckedCreateWithoutTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokenInput
    upsert?: UserUpsertWithoutTokenInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTokenInput, UserUpdateWithoutTokenInput>, UserUncheckedUpdateWithoutTokenInput>
  }

  export type CommunityUserCreateNestedManyWithoutUserInput = {
    create?: XOR<CommunityUserCreateWithoutUserInput, CommunityUserUncheckedCreateWithoutUserInput> | CommunityUserCreateWithoutUserInput[] | CommunityUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityUserCreateOrConnectWithoutUserInput | CommunityUserCreateOrConnectWithoutUserInput[]
    createMany?: CommunityUserCreateManyUserInputEnvelope
    connect?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
  }

  export type TokenCreateNestedManyWithoutUserInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type CommunityUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommunityUserCreateWithoutUserInput, CommunityUserUncheckedCreateWithoutUserInput> | CommunityUserCreateWithoutUserInput[] | CommunityUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityUserCreateOrConnectWithoutUserInput | CommunityUserCreateOrConnectWithoutUserInput[]
    createMany?: CommunityUserCreateManyUserInputEnvelope
    connect?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
  }

  export type TokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CommunityUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommunityUserCreateWithoutUserInput, CommunityUserUncheckedCreateWithoutUserInput> | CommunityUserCreateWithoutUserInput[] | CommunityUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityUserCreateOrConnectWithoutUserInput | CommunityUserCreateOrConnectWithoutUserInput[]
    upsert?: CommunityUserUpsertWithWhereUniqueWithoutUserInput | CommunityUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommunityUserCreateManyUserInputEnvelope
    set?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    disconnect?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    delete?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    connect?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    update?: CommunityUserUpdateWithWhereUniqueWithoutUserInput | CommunityUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommunityUserUpdateManyWithWhereWithoutUserInput | CommunityUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommunityUserScalarWhereInput | CommunityUserScalarWhereInput[]
  }

  export type TokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutUserInput | TokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutUserInput | TokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutUserInput | TokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type CommunityUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommunityUserCreateWithoutUserInput, CommunityUserUncheckedCreateWithoutUserInput> | CommunityUserCreateWithoutUserInput[] | CommunityUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityUserCreateOrConnectWithoutUserInput | CommunityUserCreateOrConnectWithoutUserInput[]
    upsert?: CommunityUserUpsertWithWhereUniqueWithoutUserInput | CommunityUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommunityUserCreateManyUserInputEnvelope
    set?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    disconnect?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    delete?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    connect?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    update?: CommunityUserUpdateWithWhereUniqueWithoutUserInput | CommunityUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommunityUserUpdateManyWithWhereWithoutUserInput | CommunityUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommunityUserScalarWhereInput | CommunityUserScalarWhereInput[]
  }

  export type TokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutUserInput | TokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutUserInput | TokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutUserInput | TokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type CommunityUserCreateNestedManyWithoutUserRolesInput = {
    create?: XOR<CommunityUserCreateWithoutUserRolesInput, CommunityUserUncheckedCreateWithoutUserRolesInput> | CommunityUserCreateWithoutUserRolesInput[] | CommunityUserUncheckedCreateWithoutUserRolesInput[]
    connectOrCreate?: CommunityUserCreateOrConnectWithoutUserRolesInput | CommunityUserCreateOrConnectWithoutUserRolesInput[]
    createMany?: CommunityUserCreateManyUserRolesInputEnvelope
    connect?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
  }

  export type CommunityUserUncheckedCreateNestedManyWithoutUserRolesInput = {
    create?: XOR<CommunityUserCreateWithoutUserRolesInput, CommunityUserUncheckedCreateWithoutUserRolesInput> | CommunityUserCreateWithoutUserRolesInput[] | CommunityUserUncheckedCreateWithoutUserRolesInput[]
    connectOrCreate?: CommunityUserCreateOrConnectWithoutUserRolesInput | CommunityUserCreateOrConnectWithoutUserRolesInput[]
    createMany?: CommunityUserCreateManyUserRolesInputEnvelope
    connect?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
  }

  export type CommunityUserUpdateManyWithoutUserRolesNestedInput = {
    create?: XOR<CommunityUserCreateWithoutUserRolesInput, CommunityUserUncheckedCreateWithoutUserRolesInput> | CommunityUserCreateWithoutUserRolesInput[] | CommunityUserUncheckedCreateWithoutUserRolesInput[]
    connectOrCreate?: CommunityUserCreateOrConnectWithoutUserRolesInput | CommunityUserCreateOrConnectWithoutUserRolesInput[]
    upsert?: CommunityUserUpsertWithWhereUniqueWithoutUserRolesInput | CommunityUserUpsertWithWhereUniqueWithoutUserRolesInput[]
    createMany?: CommunityUserCreateManyUserRolesInputEnvelope
    set?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    disconnect?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    delete?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    connect?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    update?: CommunityUserUpdateWithWhereUniqueWithoutUserRolesInput | CommunityUserUpdateWithWhereUniqueWithoutUserRolesInput[]
    updateMany?: CommunityUserUpdateManyWithWhereWithoutUserRolesInput | CommunityUserUpdateManyWithWhereWithoutUserRolesInput[]
    deleteMany?: CommunityUserScalarWhereInput | CommunityUserScalarWhereInput[]
  }

  export type CommunityUserUncheckedUpdateManyWithoutUserRolesNestedInput = {
    create?: XOR<CommunityUserCreateWithoutUserRolesInput, CommunityUserUncheckedCreateWithoutUserRolesInput> | CommunityUserCreateWithoutUserRolesInput[] | CommunityUserUncheckedCreateWithoutUserRolesInput[]
    connectOrCreate?: CommunityUserCreateOrConnectWithoutUserRolesInput | CommunityUserCreateOrConnectWithoutUserRolesInput[]
    upsert?: CommunityUserUpsertWithWhereUniqueWithoutUserRolesInput | CommunityUserUpsertWithWhereUniqueWithoutUserRolesInput[]
    createMany?: CommunityUserCreateManyUserRolesInputEnvelope
    set?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    disconnect?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    delete?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    connect?: CommunityUserWhereUniqueInput | CommunityUserWhereUniqueInput[]
    update?: CommunityUserUpdateWithWhereUniqueWithoutUserRolesInput | CommunityUserUpdateWithWhereUniqueWithoutUserRolesInput[]
    updateMany?: CommunityUserUpdateManyWithWhereWithoutUserRolesInput | CommunityUserUpdateManyWithWhereWithoutUserRolesInput[]
    deleteMany?: CommunityUserScalarWhereInput | CommunityUserScalarWhereInput[]
  }

  export type EmailForCreateNestedOneWithoutEmailInput = {
    create?: XOR<EmailForCreateWithoutEmailInput, EmailForUncheckedCreateWithoutEmailInput>
    connectOrCreate?: EmailForCreateOrConnectWithoutEmailInput
    connect?: EmailForWhereUniqueInput
  }

  export type EmailForUpdateOneWithoutEmailNestedInput = {
    create?: XOR<EmailForCreateWithoutEmailInput, EmailForUncheckedCreateWithoutEmailInput>
    connectOrCreate?: EmailForCreateOrConnectWithoutEmailInput
    upsert?: EmailForUpsertWithoutEmailInput
    disconnect?: EmailForWhereInput | boolean
    delete?: EmailForWhereInput | boolean
    connect?: EmailForWhereUniqueInput
    update?: XOR<XOR<EmailForUpdateToOneWithWhereWithoutEmailInput, EmailForUpdateWithoutEmailInput>, EmailForUncheckedUpdateWithoutEmailInput>
  }

  export type EmailCreateNestedManyWithoutEmailForInput = {
    create?: XOR<EmailCreateWithoutEmailForInput, EmailUncheckedCreateWithoutEmailForInput> | EmailCreateWithoutEmailForInput[] | EmailUncheckedCreateWithoutEmailForInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutEmailForInput | EmailCreateOrConnectWithoutEmailForInput[]
    createMany?: EmailCreateManyEmailForInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type EmailUncheckedCreateNestedManyWithoutEmailForInput = {
    create?: XOR<EmailCreateWithoutEmailForInput, EmailUncheckedCreateWithoutEmailForInput> | EmailCreateWithoutEmailForInput[] | EmailUncheckedCreateWithoutEmailForInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutEmailForInput | EmailCreateOrConnectWithoutEmailForInput[]
    createMany?: EmailCreateManyEmailForInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type EmailUpdateManyWithoutEmailForNestedInput = {
    create?: XOR<EmailCreateWithoutEmailForInput, EmailUncheckedCreateWithoutEmailForInput> | EmailCreateWithoutEmailForInput[] | EmailUncheckedCreateWithoutEmailForInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutEmailForInput | EmailCreateOrConnectWithoutEmailForInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutEmailForInput | EmailUpsertWithWhereUniqueWithoutEmailForInput[]
    createMany?: EmailCreateManyEmailForInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutEmailForInput | EmailUpdateWithWhereUniqueWithoutEmailForInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutEmailForInput | EmailUpdateManyWithWhereWithoutEmailForInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type EmailUncheckedUpdateManyWithoutEmailForNestedInput = {
    create?: XOR<EmailCreateWithoutEmailForInput, EmailUncheckedCreateWithoutEmailForInput> | EmailCreateWithoutEmailForInput[] | EmailUncheckedCreateWithoutEmailForInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutEmailForInput | EmailCreateOrConnectWithoutEmailForInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutEmailForInput | EmailUpsertWithWhereUniqueWithoutEmailForInput[]
    createMany?: EmailCreateManyEmailForInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutEmailForInput | EmailUpdateWithWhereUniqueWithoutEmailForInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutEmailForInput | EmailUpdateManyWithWhereWithoutEmailForInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type LeaderboardSubmissionCreateNestedManyWithoutLeaderboardInput = {
    create?: XOR<LeaderboardSubmissionCreateWithoutLeaderboardInput, LeaderboardSubmissionUncheckedCreateWithoutLeaderboardInput> | LeaderboardSubmissionCreateWithoutLeaderboardInput[] | LeaderboardSubmissionUncheckedCreateWithoutLeaderboardInput[]
    connectOrCreate?: LeaderboardSubmissionCreateOrConnectWithoutLeaderboardInput | LeaderboardSubmissionCreateOrConnectWithoutLeaderboardInput[]
    createMany?: LeaderboardSubmissionCreateManyLeaderboardInputEnvelope
    connect?: LeaderboardSubmissionWhereUniqueInput | LeaderboardSubmissionWhereUniqueInput[]
  }

  export type LeaderboardSubmissionUncheckedCreateNestedManyWithoutLeaderboardInput = {
    create?: XOR<LeaderboardSubmissionCreateWithoutLeaderboardInput, LeaderboardSubmissionUncheckedCreateWithoutLeaderboardInput> | LeaderboardSubmissionCreateWithoutLeaderboardInput[] | LeaderboardSubmissionUncheckedCreateWithoutLeaderboardInput[]
    connectOrCreate?: LeaderboardSubmissionCreateOrConnectWithoutLeaderboardInput | LeaderboardSubmissionCreateOrConnectWithoutLeaderboardInput[]
    createMany?: LeaderboardSubmissionCreateManyLeaderboardInputEnvelope
    connect?: LeaderboardSubmissionWhereUniqueInput | LeaderboardSubmissionWhereUniqueInput[]
  }

  export type LeaderboardSubmissionUpdateManyWithoutLeaderboardNestedInput = {
    create?: XOR<LeaderboardSubmissionCreateWithoutLeaderboardInput, LeaderboardSubmissionUncheckedCreateWithoutLeaderboardInput> | LeaderboardSubmissionCreateWithoutLeaderboardInput[] | LeaderboardSubmissionUncheckedCreateWithoutLeaderboardInput[]
    connectOrCreate?: LeaderboardSubmissionCreateOrConnectWithoutLeaderboardInput | LeaderboardSubmissionCreateOrConnectWithoutLeaderboardInput[]
    upsert?: LeaderboardSubmissionUpsertWithWhereUniqueWithoutLeaderboardInput | LeaderboardSubmissionUpsertWithWhereUniqueWithoutLeaderboardInput[]
    createMany?: LeaderboardSubmissionCreateManyLeaderboardInputEnvelope
    set?: LeaderboardSubmissionWhereUniqueInput | LeaderboardSubmissionWhereUniqueInput[]
    disconnect?: LeaderboardSubmissionWhereUniqueInput | LeaderboardSubmissionWhereUniqueInput[]
    delete?: LeaderboardSubmissionWhereUniqueInput | LeaderboardSubmissionWhereUniqueInput[]
    connect?: LeaderboardSubmissionWhereUniqueInput | LeaderboardSubmissionWhereUniqueInput[]
    update?: LeaderboardSubmissionUpdateWithWhereUniqueWithoutLeaderboardInput | LeaderboardSubmissionUpdateWithWhereUniqueWithoutLeaderboardInput[]
    updateMany?: LeaderboardSubmissionUpdateManyWithWhereWithoutLeaderboardInput | LeaderboardSubmissionUpdateManyWithWhereWithoutLeaderboardInput[]
    deleteMany?: LeaderboardSubmissionScalarWhereInput | LeaderboardSubmissionScalarWhereInput[]
  }

  export type LeaderboardSubmissionUncheckedUpdateManyWithoutLeaderboardNestedInput = {
    create?: XOR<LeaderboardSubmissionCreateWithoutLeaderboardInput, LeaderboardSubmissionUncheckedCreateWithoutLeaderboardInput> | LeaderboardSubmissionCreateWithoutLeaderboardInput[] | LeaderboardSubmissionUncheckedCreateWithoutLeaderboardInput[]
    connectOrCreate?: LeaderboardSubmissionCreateOrConnectWithoutLeaderboardInput | LeaderboardSubmissionCreateOrConnectWithoutLeaderboardInput[]
    upsert?: LeaderboardSubmissionUpsertWithWhereUniqueWithoutLeaderboardInput | LeaderboardSubmissionUpsertWithWhereUniqueWithoutLeaderboardInput[]
    createMany?: LeaderboardSubmissionCreateManyLeaderboardInputEnvelope
    set?: LeaderboardSubmissionWhereUniqueInput | LeaderboardSubmissionWhereUniqueInput[]
    disconnect?: LeaderboardSubmissionWhereUniqueInput | LeaderboardSubmissionWhereUniqueInput[]
    delete?: LeaderboardSubmissionWhereUniqueInput | LeaderboardSubmissionWhereUniqueInput[]
    connect?: LeaderboardSubmissionWhereUniqueInput | LeaderboardSubmissionWhereUniqueInput[]
    update?: LeaderboardSubmissionUpdateWithWhereUniqueWithoutLeaderboardInput | LeaderboardSubmissionUpdateWithWhereUniqueWithoutLeaderboardInput[]
    updateMany?: LeaderboardSubmissionUpdateManyWithWhereWithoutLeaderboardInput | LeaderboardSubmissionUpdateManyWithWhereWithoutLeaderboardInput[]
    deleteMany?: LeaderboardSubmissionScalarWhereInput | LeaderboardSubmissionScalarWhereInput[]
  }

  export type LeaderboardSubmissionTypeCreateNestedManyWithoutLeaderboardSubmissionInput = {
    create?: XOR<LeaderboardSubmissionTypeCreateWithoutLeaderboardSubmissionInput, LeaderboardSubmissionTypeUncheckedCreateWithoutLeaderboardSubmissionInput> | LeaderboardSubmissionTypeCreateWithoutLeaderboardSubmissionInput[] | LeaderboardSubmissionTypeUncheckedCreateWithoutLeaderboardSubmissionInput[]
    connectOrCreate?: LeaderboardSubmissionTypeCreateOrConnectWithoutLeaderboardSubmissionInput | LeaderboardSubmissionTypeCreateOrConnectWithoutLeaderboardSubmissionInput[]
    createMany?: LeaderboardSubmissionTypeCreateManyLeaderboardSubmissionInputEnvelope
    connect?: LeaderboardSubmissionTypeWhereUniqueInput | LeaderboardSubmissionTypeWhereUniqueInput[]
  }

  export type LeaderboardCreateNestedOneWithoutLeaderboardSubmissionInput = {
    create?: XOR<LeaderboardCreateWithoutLeaderboardSubmissionInput, LeaderboardUncheckedCreateWithoutLeaderboardSubmissionInput>
    connectOrCreate?: LeaderboardCreateOrConnectWithoutLeaderboardSubmissionInput
    connect?: LeaderboardWhereUniqueInput
  }

  export type LeaderboardSubmissionTypeUncheckedCreateNestedManyWithoutLeaderboardSubmissionInput = {
    create?: XOR<LeaderboardSubmissionTypeCreateWithoutLeaderboardSubmissionInput, LeaderboardSubmissionTypeUncheckedCreateWithoutLeaderboardSubmissionInput> | LeaderboardSubmissionTypeCreateWithoutLeaderboardSubmissionInput[] | LeaderboardSubmissionTypeUncheckedCreateWithoutLeaderboardSubmissionInput[]
    connectOrCreate?: LeaderboardSubmissionTypeCreateOrConnectWithoutLeaderboardSubmissionInput | LeaderboardSubmissionTypeCreateOrConnectWithoutLeaderboardSubmissionInput[]
    createMany?: LeaderboardSubmissionTypeCreateManyLeaderboardSubmissionInputEnvelope
    connect?: LeaderboardSubmissionTypeWhereUniqueInput | LeaderboardSubmissionTypeWhereUniqueInput[]
  }

  export type LeaderboardSubmissionTypeUpdateManyWithoutLeaderboardSubmissionNestedInput = {
    create?: XOR<LeaderboardSubmissionTypeCreateWithoutLeaderboardSubmissionInput, LeaderboardSubmissionTypeUncheckedCreateWithoutLeaderboardSubmissionInput> | LeaderboardSubmissionTypeCreateWithoutLeaderboardSubmissionInput[] | LeaderboardSubmissionTypeUncheckedCreateWithoutLeaderboardSubmissionInput[]
    connectOrCreate?: LeaderboardSubmissionTypeCreateOrConnectWithoutLeaderboardSubmissionInput | LeaderboardSubmissionTypeCreateOrConnectWithoutLeaderboardSubmissionInput[]
    upsert?: LeaderboardSubmissionTypeUpsertWithWhereUniqueWithoutLeaderboardSubmissionInput | LeaderboardSubmissionTypeUpsertWithWhereUniqueWithoutLeaderboardSubmissionInput[]
    createMany?: LeaderboardSubmissionTypeCreateManyLeaderboardSubmissionInputEnvelope
    set?: LeaderboardSubmissionTypeWhereUniqueInput | LeaderboardSubmissionTypeWhereUniqueInput[]
    disconnect?: LeaderboardSubmissionTypeWhereUniqueInput | LeaderboardSubmissionTypeWhereUniqueInput[]
    delete?: LeaderboardSubmissionTypeWhereUniqueInput | LeaderboardSubmissionTypeWhereUniqueInput[]
    connect?: LeaderboardSubmissionTypeWhereUniqueInput | LeaderboardSubmissionTypeWhereUniqueInput[]
    update?: LeaderboardSubmissionTypeUpdateWithWhereUniqueWithoutLeaderboardSubmissionInput | LeaderboardSubmissionTypeUpdateWithWhereUniqueWithoutLeaderboardSubmissionInput[]
    updateMany?: LeaderboardSubmissionTypeUpdateManyWithWhereWithoutLeaderboardSubmissionInput | LeaderboardSubmissionTypeUpdateManyWithWhereWithoutLeaderboardSubmissionInput[]
    deleteMany?: LeaderboardSubmissionTypeScalarWhereInput | LeaderboardSubmissionTypeScalarWhereInput[]
  }

  export type LeaderboardUpdateOneWithoutLeaderboardSubmissionNestedInput = {
    create?: XOR<LeaderboardCreateWithoutLeaderboardSubmissionInput, LeaderboardUncheckedCreateWithoutLeaderboardSubmissionInput>
    connectOrCreate?: LeaderboardCreateOrConnectWithoutLeaderboardSubmissionInput
    upsert?: LeaderboardUpsertWithoutLeaderboardSubmissionInput
    disconnect?: LeaderboardWhereInput | boolean
    delete?: LeaderboardWhereInput | boolean
    connect?: LeaderboardWhereUniqueInput
    update?: XOR<XOR<LeaderboardUpdateToOneWithWhereWithoutLeaderboardSubmissionInput, LeaderboardUpdateWithoutLeaderboardSubmissionInput>, LeaderboardUncheckedUpdateWithoutLeaderboardSubmissionInput>
  }

  export type LeaderboardSubmissionTypeUncheckedUpdateManyWithoutLeaderboardSubmissionNestedInput = {
    create?: XOR<LeaderboardSubmissionTypeCreateWithoutLeaderboardSubmissionInput, LeaderboardSubmissionTypeUncheckedCreateWithoutLeaderboardSubmissionInput> | LeaderboardSubmissionTypeCreateWithoutLeaderboardSubmissionInput[] | LeaderboardSubmissionTypeUncheckedCreateWithoutLeaderboardSubmissionInput[]
    connectOrCreate?: LeaderboardSubmissionTypeCreateOrConnectWithoutLeaderboardSubmissionInput | LeaderboardSubmissionTypeCreateOrConnectWithoutLeaderboardSubmissionInput[]
    upsert?: LeaderboardSubmissionTypeUpsertWithWhereUniqueWithoutLeaderboardSubmissionInput | LeaderboardSubmissionTypeUpsertWithWhereUniqueWithoutLeaderboardSubmissionInput[]
    createMany?: LeaderboardSubmissionTypeCreateManyLeaderboardSubmissionInputEnvelope
    set?: LeaderboardSubmissionTypeWhereUniqueInput | LeaderboardSubmissionTypeWhereUniqueInput[]
    disconnect?: LeaderboardSubmissionTypeWhereUniqueInput | LeaderboardSubmissionTypeWhereUniqueInput[]
    delete?: LeaderboardSubmissionTypeWhereUniqueInput | LeaderboardSubmissionTypeWhereUniqueInput[]
    connect?: LeaderboardSubmissionTypeWhereUniqueInput | LeaderboardSubmissionTypeWhereUniqueInput[]
    update?: LeaderboardSubmissionTypeUpdateWithWhereUniqueWithoutLeaderboardSubmissionInput | LeaderboardSubmissionTypeUpdateWithWhereUniqueWithoutLeaderboardSubmissionInput[]
    updateMany?: LeaderboardSubmissionTypeUpdateManyWithWhereWithoutLeaderboardSubmissionInput | LeaderboardSubmissionTypeUpdateManyWithWhereWithoutLeaderboardSubmissionInput[]
    deleteMany?: LeaderboardSubmissionTypeScalarWhereInput | LeaderboardSubmissionTypeScalarWhereInput[]
  }

  export type LeaderboardSubmissionCreateNestedOneWithoutLeaderboardSubmissionTypeInput = {
    create?: XOR<LeaderboardSubmissionCreateWithoutLeaderboardSubmissionTypeInput, LeaderboardSubmissionUncheckedCreateWithoutLeaderboardSubmissionTypeInput>
    connectOrCreate?: LeaderboardSubmissionCreateOrConnectWithoutLeaderboardSubmissionTypeInput
    connect?: LeaderboardSubmissionWhereUniqueInput
  }

  export type LeaderboardSubmissionUpdateOneWithoutLeaderboardSubmissionTypeNestedInput = {
    create?: XOR<LeaderboardSubmissionCreateWithoutLeaderboardSubmissionTypeInput, LeaderboardSubmissionUncheckedCreateWithoutLeaderboardSubmissionTypeInput>
    connectOrCreate?: LeaderboardSubmissionCreateOrConnectWithoutLeaderboardSubmissionTypeInput
    upsert?: LeaderboardSubmissionUpsertWithoutLeaderboardSubmissionTypeInput
    disconnect?: LeaderboardSubmissionWhereInput | boolean
    delete?: LeaderboardSubmissionWhereInput | boolean
    connect?: LeaderboardSubmissionWhereUniqueInput
    update?: XOR<XOR<LeaderboardSubmissionUpdateToOneWithWhereWithoutLeaderboardSubmissionTypeInput, LeaderboardSubmissionUpdateWithoutLeaderboardSubmissionTypeInput>, LeaderboardSubmissionUncheckedUpdateWithoutLeaderboardSubmissionTypeInput>
  }

  export type PendingPostCreateNestedManyWithoutPendingPostStatusInput = {
    create?: XOR<PendingPostCreateWithoutPendingPostStatusInput, PendingPostUncheckedCreateWithoutPendingPostStatusInput> | PendingPostCreateWithoutPendingPostStatusInput[] | PendingPostUncheckedCreateWithoutPendingPostStatusInput[]
    connectOrCreate?: PendingPostCreateOrConnectWithoutPendingPostStatusInput | PendingPostCreateOrConnectWithoutPendingPostStatusInput[]
    connect?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
  }

  export type PendingPostUncheckedCreateNestedManyWithoutPendingPostStatusInput = {
    create?: XOR<PendingPostCreateWithoutPendingPostStatusInput, PendingPostUncheckedCreateWithoutPendingPostStatusInput> | PendingPostCreateWithoutPendingPostStatusInput[] | PendingPostUncheckedCreateWithoutPendingPostStatusInput[]
    connectOrCreate?: PendingPostCreateOrConnectWithoutPendingPostStatusInput | PendingPostCreateOrConnectWithoutPendingPostStatusInput[]
    connect?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
  }

  export type PendingPostUpdateManyWithoutPendingPostStatusNestedInput = {
    create?: XOR<PendingPostCreateWithoutPendingPostStatusInput, PendingPostUncheckedCreateWithoutPendingPostStatusInput> | PendingPostCreateWithoutPendingPostStatusInput[] | PendingPostUncheckedCreateWithoutPendingPostStatusInput[]
    connectOrCreate?: PendingPostCreateOrConnectWithoutPendingPostStatusInput | PendingPostCreateOrConnectWithoutPendingPostStatusInput[]
    upsert?: PendingPostUpsertWithWhereUniqueWithoutPendingPostStatusInput | PendingPostUpsertWithWhereUniqueWithoutPendingPostStatusInput[]
    set?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    disconnect?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    delete?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    connect?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    update?: PendingPostUpdateWithWhereUniqueWithoutPendingPostStatusInput | PendingPostUpdateWithWhereUniqueWithoutPendingPostStatusInput[]
    updateMany?: PendingPostUpdateManyWithWhereWithoutPendingPostStatusInput | PendingPostUpdateManyWithWhereWithoutPendingPostStatusInput[]
    deleteMany?: PendingPostScalarWhereInput | PendingPostScalarWhereInput[]
  }

  export type PendingPostUncheckedUpdateManyWithoutPendingPostStatusNestedInput = {
    create?: XOR<PendingPostCreateWithoutPendingPostStatusInput, PendingPostUncheckedCreateWithoutPendingPostStatusInput> | PendingPostCreateWithoutPendingPostStatusInput[] | PendingPostUncheckedCreateWithoutPendingPostStatusInput[]
    connectOrCreate?: PendingPostCreateOrConnectWithoutPendingPostStatusInput | PendingPostCreateOrConnectWithoutPendingPostStatusInput[]
    upsert?: PendingPostUpsertWithWhereUniqueWithoutPendingPostStatusInput | PendingPostUpsertWithWhereUniqueWithoutPendingPostStatusInput[]
    set?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    disconnect?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    delete?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    connect?: PendingPostWhereUniqueInput | PendingPostWhereUniqueInput[]
    update?: PendingPostUpdateWithWhereUniqueWithoutPendingPostStatusInput | PendingPostUpdateWithWhereUniqueWithoutPendingPostStatusInput[]
    updateMany?: PendingPostUpdateManyWithWhereWithoutPendingPostStatusInput | PendingPostUpdateManyWithWhereWithoutPendingPostStatusInput[]
    deleteMany?: PendingPostScalarWhereInput | PendingPostScalarWhereInput[]
  }

  export type LogCreateNestedManyWithoutLogLevelInput = {
    create?: XOR<LogCreateWithoutLogLevelInput, LogUncheckedCreateWithoutLogLevelInput> | LogCreateWithoutLogLevelInput[] | LogUncheckedCreateWithoutLogLevelInput[]
    connectOrCreate?: LogCreateOrConnectWithoutLogLevelInput | LogCreateOrConnectWithoutLogLevelInput[]
    createMany?: LogCreateManyLogLevelInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutLogLevelInput = {
    create?: XOR<LogCreateWithoutLogLevelInput, LogUncheckedCreateWithoutLogLevelInput> | LogCreateWithoutLogLevelInput[] | LogUncheckedCreateWithoutLogLevelInput[]
    connectOrCreate?: LogCreateOrConnectWithoutLogLevelInput | LogCreateOrConnectWithoutLogLevelInput[]
    createMany?: LogCreateManyLogLevelInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type LogUpdateManyWithoutLogLevelNestedInput = {
    create?: XOR<LogCreateWithoutLogLevelInput, LogUncheckedCreateWithoutLogLevelInput> | LogCreateWithoutLogLevelInput[] | LogUncheckedCreateWithoutLogLevelInput[]
    connectOrCreate?: LogCreateOrConnectWithoutLogLevelInput | LogCreateOrConnectWithoutLogLevelInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutLogLevelInput | LogUpsertWithWhereUniqueWithoutLogLevelInput[]
    createMany?: LogCreateManyLogLevelInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutLogLevelInput | LogUpdateWithWhereUniqueWithoutLogLevelInput[]
    updateMany?: LogUpdateManyWithWhereWithoutLogLevelInput | LogUpdateManyWithWhereWithoutLogLevelInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutLogLevelNestedInput = {
    create?: XOR<LogCreateWithoutLogLevelInput, LogUncheckedCreateWithoutLogLevelInput> | LogCreateWithoutLogLevelInput[] | LogUncheckedCreateWithoutLogLevelInput[]
    connectOrCreate?: LogCreateOrConnectWithoutLogLevelInput | LogCreateOrConnectWithoutLogLevelInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutLogLevelInput | LogUpsertWithWhereUniqueWithoutLogLevelInput[]
    createMany?: LogCreateManyLogLevelInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutLogLevelInput | LogUpdateWithWhereUniqueWithoutLogLevelInput[]
    updateMany?: LogUpdateManyWithWhereWithoutLogLevelInput | LogUpdateManyWithWhereWithoutLogLevelInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type LogCreateNestedManyWithoutLogTypeInput = {
    create?: XOR<LogCreateWithoutLogTypeInput, LogUncheckedCreateWithoutLogTypeInput> | LogCreateWithoutLogTypeInput[] | LogUncheckedCreateWithoutLogTypeInput[]
    connectOrCreate?: LogCreateOrConnectWithoutLogTypeInput | LogCreateOrConnectWithoutLogTypeInput[]
    createMany?: LogCreateManyLogTypeInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutLogTypeInput = {
    create?: XOR<LogCreateWithoutLogTypeInput, LogUncheckedCreateWithoutLogTypeInput> | LogCreateWithoutLogTypeInput[] | LogUncheckedCreateWithoutLogTypeInput[]
    connectOrCreate?: LogCreateOrConnectWithoutLogTypeInput | LogCreateOrConnectWithoutLogTypeInput[]
    createMany?: LogCreateManyLogTypeInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type LogUpdateManyWithoutLogTypeNestedInput = {
    create?: XOR<LogCreateWithoutLogTypeInput, LogUncheckedCreateWithoutLogTypeInput> | LogCreateWithoutLogTypeInput[] | LogUncheckedCreateWithoutLogTypeInput[]
    connectOrCreate?: LogCreateOrConnectWithoutLogTypeInput | LogCreateOrConnectWithoutLogTypeInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutLogTypeInput | LogUpsertWithWhereUniqueWithoutLogTypeInput[]
    createMany?: LogCreateManyLogTypeInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutLogTypeInput | LogUpdateWithWhereUniqueWithoutLogTypeInput[]
    updateMany?: LogUpdateManyWithWhereWithoutLogTypeInput | LogUpdateManyWithWhereWithoutLogTypeInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutLogTypeNestedInput = {
    create?: XOR<LogCreateWithoutLogTypeInput, LogUncheckedCreateWithoutLogTypeInput> | LogCreateWithoutLogTypeInput[] | LogUncheckedCreateWithoutLogTypeInput[]
    connectOrCreate?: LogCreateOrConnectWithoutLogTypeInput | LogCreateOrConnectWithoutLogTypeInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutLogTypeInput | LogUpsertWithWhereUniqueWithoutLogTypeInput[]
    createMany?: LogCreateManyLogTypeInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutLogTypeInput | LogUpdateWithWhereUniqueWithoutLogTypeInput[]
    updateMany?: LogUpdateManyWithWhereWithoutLogTypeInput | LogUpdateManyWithWhereWithoutLogTypeInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type CommunityCreateNestedOneWithoutCommunityUserInput = {
    create?: XOR<CommunityCreateWithoutCommunityUserInput, CommunityUncheckedCreateWithoutCommunityUserInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutCommunityUserInput
    connect?: CommunityWhereUniqueInput
  }

  export type UserRolesCreateNestedOneWithoutCommunityUserInput = {
    create?: XOR<UserRolesCreateWithoutCommunityUserInput, UserRolesUncheckedCreateWithoutCommunityUserInput>
    connectOrCreate?: UserRolesCreateOrConnectWithoutCommunityUserInput
    connect?: UserRolesWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunityUserInput = {
    create?: XOR<UserCreateWithoutCommunityUserInput, UserUncheckedCreateWithoutCommunityUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityUserInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityUpdateOneRequiredWithoutCommunityUserNestedInput = {
    create?: XOR<CommunityCreateWithoutCommunityUserInput, CommunityUncheckedCreateWithoutCommunityUserInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutCommunityUserInput
    upsert?: CommunityUpsertWithoutCommunityUserInput
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutCommunityUserInput, CommunityUpdateWithoutCommunityUserInput>, CommunityUncheckedUpdateWithoutCommunityUserInput>
  }

  export type UserRolesUpdateOneRequiredWithoutCommunityUserNestedInput = {
    create?: XOR<UserRolesCreateWithoutCommunityUserInput, UserRolesUncheckedCreateWithoutCommunityUserInput>
    connectOrCreate?: UserRolesCreateOrConnectWithoutCommunityUserInput
    upsert?: UserRolesUpsertWithoutCommunityUserInput
    connect?: UserRolesWhereUniqueInput
    update?: XOR<XOR<UserRolesUpdateToOneWithWhereWithoutCommunityUserInput, UserRolesUpdateWithoutCommunityUserInput>, UserRolesUncheckedUpdateWithoutCommunityUserInput>
  }

  export type UserUpdateOneRequiredWithoutCommunityUserNestedInput = {
    create?: XOR<UserCreateWithoutCommunityUserInput, UserUncheckedCreateWithoutCommunityUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityUserInput
    upsert?: UserUpsertWithoutCommunityUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommunityUserInput, UserUpdateWithoutCommunityUserInput>, UserUncheckedUpdateWithoutCommunityUserInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AdminTokenCreateWithoutAdminInput = {
    accessToken?: string | null
  }

  export type AdminTokenUncheckedCreateWithoutAdminInput = {
    id?: number
    accessToken?: string | null
  }

  export type AdminTokenCreateOrConnectWithoutAdminInput = {
    where: AdminTokenWhereUniqueInput
    create: XOR<AdminTokenCreateWithoutAdminInput, AdminTokenUncheckedCreateWithoutAdminInput>
  }

  export type AdminTokenUpsertWithoutAdminInput = {
    update: XOR<AdminTokenUpdateWithoutAdminInput, AdminTokenUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminTokenCreateWithoutAdminInput, AdminTokenUncheckedCreateWithoutAdminInput>
    where?: AdminTokenWhereInput
  }

  export type AdminTokenUpdateToOneWithWhereWithoutAdminInput = {
    where?: AdminTokenWhereInput
    data: XOR<AdminTokenUpdateWithoutAdminInput, AdminTokenUncheckedUpdateWithoutAdminInput>
  }

  export type AdminTokenUpdateWithoutAdminInput = {
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminTokenUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminCreateWithoutAdminTokenInput = {
    username?: string | null
    password?: string | null
  }

  export type AdminUncheckedCreateWithoutAdminTokenInput = {
    id?: number
    username?: string | null
    password?: string | null
  }

  export type AdminCreateOrConnectWithoutAdminTokenInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAdminTokenInput, AdminUncheckedCreateWithoutAdminTokenInput>
  }

  export type AdminUpsertWithoutAdminTokenInput = {
    update: XOR<AdminUpdateWithoutAdminTokenInput, AdminUncheckedUpdateWithoutAdminTokenInput>
    create: XOR<AdminCreateWithoutAdminTokenInput, AdminUncheckedCreateWithoutAdminTokenInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAdminTokenInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAdminTokenInput, AdminUncheckedUpdateWithoutAdminTokenInput>
  }

  export type AdminUpdateWithoutAdminTokenInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminUncheckedUpdateWithoutAdminTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunityCreateWithoutBannedUsersInput = {
    name?: string | null
    description?: string | null
    CommunityUser?: CommunityUserCreateNestedManyWithoutCommunityInput
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutBannedUsersInput = {
    id?: number
    name?: string | null
    description?: string | null
    CommunityUser?: CommunityUserUncheckedCreateNestedManyWithoutCommunityInput
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutBannedUsersInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutBannedUsersInput, CommunityUncheckedCreateWithoutBannedUsersInput>
  }

  export type CommunityUpsertWithoutBannedUsersInput = {
    update: XOR<CommunityUpdateWithoutBannedUsersInput, CommunityUncheckedUpdateWithoutBannedUsersInput>
    create: XOR<CommunityCreateWithoutBannedUsersInput, CommunityUncheckedCreateWithoutBannedUsersInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutBannedUsersInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutBannedUsersInput, CommunityUncheckedUpdateWithoutBannedUsersInput>
  }

  export type CommunityUpdateWithoutBannedUsersInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    CommunityUser?: CommunityUserUpdateManyWithoutCommunityNestedInput
    CommunityRequest?: CommunityRequestUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutBannedUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    CommunityUser?: CommunityUserUncheckedUpdateManyWithoutCommunityNestedInput
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type PostCreateWithoutCommentInput = {
    Content?: string | null
    fileUrl: string
    community: number
    user: string
    caption?: string | null
    Like?: LikeCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutCommentInput = {
    id?: number
    Content?: string | null
    fileUrl: string
    community: number
    user: string
    caption?: string | null
    Like?: LikeUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommentInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentInput, PostUncheckedCreateWithoutCommentInput>
  }

  export type PostUpsertWithoutCommentInput = {
    update: XOR<PostUpdateWithoutCommentInput, PostUncheckedUpdateWithoutCommentInput>
    create: XOR<PostCreateWithoutCommentInput, PostUncheckedCreateWithoutCommentInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentInput, PostUncheckedUpdateWithoutCommentInput>
  }

  export type PostUpdateWithoutCommentInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Like?: LikeUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Like?: LikeUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CommunityUserCreateWithoutCommunityInput = {
    verifiedAt?: Date | string | null
    UserRoles: UserRolesCreateNestedOneWithoutCommunityUserInput
    User: UserCreateNestedOneWithoutCommunityUserInput
  }

  export type CommunityUserUncheckedCreateWithoutCommunityInput = {
    id?: number
    user: string
    role: number
    verifiedAt?: Date | string | null
  }

  export type CommunityUserCreateOrConnectWithoutCommunityInput = {
    where: CommunityUserWhereUniqueInput
    create: XOR<CommunityUserCreateWithoutCommunityInput, CommunityUserUncheckedCreateWithoutCommunityInput>
  }

  export type CommunityUserCreateManyCommunityInputEnvelope = {
    data: CommunityUserCreateManyCommunityInput | CommunityUserCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type CommunityRequestCreateWithoutCommunityInput = {
    user?: string | null
    requestedAt?: Date | string | null
    message?: string | null
  }

  export type CommunityRequestUncheckedCreateWithoutCommunityInput = {
    id?: number
    user?: string | null
    requestedAt?: Date | string | null
    message?: string | null
  }

  export type CommunityRequestCreateOrConnectWithoutCommunityInput = {
    where: CommunityRequestWhereUniqueInput
    create: XOR<CommunityRequestCreateWithoutCommunityInput, CommunityRequestUncheckedCreateWithoutCommunityInput>
  }

  export type CommunityRequestCreateManyCommunityInputEnvelope = {
    data: CommunityRequestCreateManyCommunityInput | CommunityRequestCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type BannedUsersCreateWithoutCommunityInput = {
    user: string
    reasonId?: number | null
  }

  export type BannedUsersUncheckedCreateWithoutCommunityInput = {
    id?: number
    user: string
    reasonId?: number | null
  }

  export type BannedUsersCreateOrConnectWithoutCommunityInput = {
    where: BannedUsersWhereUniqueInput
    create: XOR<BannedUsersCreateWithoutCommunityInput, BannedUsersUncheckedCreateWithoutCommunityInput>
  }

  export type BannedUsersCreateManyCommunityInputEnvelope = {
    data: BannedUsersCreateManyCommunityInput | BannedUsersCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type CommunityUserUpsertWithWhereUniqueWithoutCommunityInput = {
    where: CommunityUserWhereUniqueInput
    update: XOR<CommunityUserUpdateWithoutCommunityInput, CommunityUserUncheckedUpdateWithoutCommunityInput>
    create: XOR<CommunityUserCreateWithoutCommunityInput, CommunityUserUncheckedCreateWithoutCommunityInput>
  }

  export type CommunityUserUpdateWithWhereUniqueWithoutCommunityInput = {
    where: CommunityUserWhereUniqueInput
    data: XOR<CommunityUserUpdateWithoutCommunityInput, CommunityUserUncheckedUpdateWithoutCommunityInput>
  }

  export type CommunityUserUpdateManyWithWhereWithoutCommunityInput = {
    where: CommunityUserScalarWhereInput
    data: XOR<CommunityUserUpdateManyMutationInput, CommunityUserUncheckedUpdateManyWithoutCommunityInput>
  }

  export type CommunityUserScalarWhereInput = {
    AND?: CommunityUserScalarWhereInput | CommunityUserScalarWhereInput[]
    OR?: CommunityUserScalarWhereInput[]
    NOT?: CommunityUserScalarWhereInput | CommunityUserScalarWhereInput[]
    id?: IntFilter<"CommunityUser"> | number
    community?: IntFilter<"CommunityUser"> | number
    user?: StringFilter<"CommunityUser"> | string
    role?: IntFilter<"CommunityUser"> | number
    verifiedAt?: DateTimeNullableFilter<"CommunityUser"> | Date | string | null
  }

  export type CommunityRequestUpsertWithWhereUniqueWithoutCommunityInput = {
    where: CommunityRequestWhereUniqueInput
    update: XOR<CommunityRequestUpdateWithoutCommunityInput, CommunityRequestUncheckedUpdateWithoutCommunityInput>
    create: XOR<CommunityRequestCreateWithoutCommunityInput, CommunityRequestUncheckedCreateWithoutCommunityInput>
  }

  export type CommunityRequestUpdateWithWhereUniqueWithoutCommunityInput = {
    where: CommunityRequestWhereUniqueInput
    data: XOR<CommunityRequestUpdateWithoutCommunityInput, CommunityRequestUncheckedUpdateWithoutCommunityInput>
  }

  export type CommunityRequestUpdateManyWithWhereWithoutCommunityInput = {
    where: CommunityRequestScalarWhereInput
    data: XOR<CommunityRequestUpdateManyMutationInput, CommunityRequestUncheckedUpdateManyWithoutCommunityInput>
  }

  export type CommunityRequestScalarWhereInput = {
    AND?: CommunityRequestScalarWhereInput | CommunityRequestScalarWhereInput[]
    OR?: CommunityRequestScalarWhereInput[]
    NOT?: CommunityRequestScalarWhereInput | CommunityRequestScalarWhereInput[]
    id?: IntFilter<"CommunityRequest"> | number
    user?: StringNullableFilter<"CommunityRequest"> | string | null
    community?: IntNullableFilter<"CommunityRequest"> | number | null
    requestedAt?: DateTimeNullableFilter<"CommunityRequest"> | Date | string | null
    message?: StringNullableFilter<"CommunityRequest"> | string | null
  }

  export type BannedUsersUpsertWithWhereUniqueWithoutCommunityInput = {
    where: BannedUsersWhereUniqueInput
    update: XOR<BannedUsersUpdateWithoutCommunityInput, BannedUsersUncheckedUpdateWithoutCommunityInput>
    create: XOR<BannedUsersCreateWithoutCommunityInput, BannedUsersUncheckedCreateWithoutCommunityInput>
  }

  export type BannedUsersUpdateWithWhereUniqueWithoutCommunityInput = {
    where: BannedUsersWhereUniqueInput
    data: XOR<BannedUsersUpdateWithoutCommunityInput, BannedUsersUncheckedUpdateWithoutCommunityInput>
  }

  export type BannedUsersUpdateManyWithWhereWithoutCommunityInput = {
    where: BannedUsersScalarWhereInput
    data: XOR<BannedUsersUpdateManyMutationInput, BannedUsersUncheckedUpdateManyWithoutCommunityInput>
  }

  export type BannedUsersScalarWhereInput = {
    AND?: BannedUsersScalarWhereInput | BannedUsersScalarWhereInput[]
    OR?: BannedUsersScalarWhereInput[]
    NOT?: BannedUsersScalarWhereInput | BannedUsersScalarWhereInput[]
    id?: IntFilter<"BannedUsers"> | number
    community?: IntFilter<"BannedUsers"> | number
    user?: StringFilter<"BannedUsers"> | string
    reasonId?: IntNullableFilter<"BannedUsers"> | number | null
  }

  export type CommunityCreateWithoutCommunityRequestInput = {
    name?: string | null
    description?: string | null
    CommunityUser?: CommunityUserCreateNestedManyWithoutCommunityInput
    BannedUsers?: BannedUsersCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutCommunityRequestInput = {
    id?: number
    name?: string | null
    description?: string | null
    CommunityUser?: CommunityUserUncheckedCreateNestedManyWithoutCommunityInput
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutCommunityRequestInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutCommunityRequestInput, CommunityUncheckedCreateWithoutCommunityRequestInput>
  }

  export type CommunityUpsertWithoutCommunityRequestInput = {
    update: XOR<CommunityUpdateWithoutCommunityRequestInput, CommunityUncheckedUpdateWithoutCommunityRequestInput>
    create: XOR<CommunityCreateWithoutCommunityRequestInput, CommunityUncheckedCreateWithoutCommunityRequestInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutCommunityRequestInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutCommunityRequestInput, CommunityUncheckedUpdateWithoutCommunityRequestInput>
  }

  export type CommunityUpdateWithoutCommunityRequestInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    CommunityUser?: CommunityUserUpdateManyWithoutCommunityNestedInput
    BannedUsers?: BannedUsersUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutCommunityRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    CommunityUser?: CommunityUserUncheckedUpdateManyWithoutCommunityNestedInput
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type PostCreateWithoutLikeInput = {
    Content?: string | null
    fileUrl: string
    community: number
    user: string
    caption?: string | null
    Comment?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutLikeInput = {
    id?: number
    Content?: string | null
    fileUrl: string
    community: number
    user: string
    caption?: string | null
    Comment?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutLikeInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutLikeInput, PostUncheckedCreateWithoutLikeInput>
  }

  export type PostUpsertWithoutLikeInput = {
    update: XOR<PostUpdateWithoutLikeInput, PostUncheckedUpdateWithoutLikeInput>
    create: XOR<PostCreateWithoutLikeInput, PostUncheckedCreateWithoutLikeInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutLikeInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutLikeInput, PostUncheckedUpdateWithoutLikeInput>
  }

  export type PostUpdateWithoutLikeInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutLikeInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type LogLevelCreateWithoutLogInput = {
    id: number
    level?: string | null
  }

  export type LogLevelUncheckedCreateWithoutLogInput = {
    id: number
    level?: string | null
  }

  export type LogLevelCreateOrConnectWithoutLogInput = {
    where: LogLevelWhereUniqueInput
    create: XOR<LogLevelCreateWithoutLogInput, LogLevelUncheckedCreateWithoutLogInput>
  }

  export type LogTypeCreateWithoutLogInput = {
    id: number
    type?: string | null
  }

  export type LogTypeUncheckedCreateWithoutLogInput = {
    id: number
    type?: string | null
  }

  export type LogTypeCreateOrConnectWithoutLogInput = {
    where: LogTypeWhereUniqueInput
    create: XOR<LogTypeCreateWithoutLogInput, LogTypeUncheckedCreateWithoutLogInput>
  }

  export type LogLevelUpsertWithoutLogInput = {
    update: XOR<LogLevelUpdateWithoutLogInput, LogLevelUncheckedUpdateWithoutLogInput>
    create: XOR<LogLevelCreateWithoutLogInput, LogLevelUncheckedCreateWithoutLogInput>
    where?: LogLevelWhereInput
  }

  export type LogLevelUpdateToOneWithWhereWithoutLogInput = {
    where?: LogLevelWhereInput
    data: XOR<LogLevelUpdateWithoutLogInput, LogLevelUncheckedUpdateWithoutLogInput>
  }

  export type LogLevelUpdateWithoutLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogLevelUncheckedUpdateWithoutLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogTypeUpsertWithoutLogInput = {
    update: XOR<LogTypeUpdateWithoutLogInput, LogTypeUncheckedUpdateWithoutLogInput>
    create: XOR<LogTypeCreateWithoutLogInput, LogTypeUncheckedCreateWithoutLogInput>
    where?: LogTypeWhereInput
  }

  export type LogTypeUpdateToOneWithWhereWithoutLogInput = {
    where?: LogTypeWhereInput
    data: XOR<LogTypeUpdateWithoutLogInput, LogTypeUncheckedUpdateWithoutLogInput>
  }

  export type LogTypeUpdateWithoutLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogTypeUncheckedUpdateWithoutLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PendingPostStatusCreateWithoutPendingPostInput = {
    id: number
    status?: string | null
  }

  export type PendingPostStatusUncheckedCreateWithoutPendingPostInput = {
    id: number
    status?: string | null
  }

  export type PendingPostStatusCreateOrConnectWithoutPendingPostInput = {
    where: PendingPostStatusWhereUniqueInput
    create: XOR<PendingPostStatusCreateWithoutPendingPostInput, PendingPostStatusUncheckedCreateWithoutPendingPostInput>
  }

  export type PendingPostStatusUpsertWithWhereUniqueWithoutPendingPostInput = {
    where: PendingPostStatusWhereUniqueInput
    update: XOR<PendingPostStatusUpdateWithoutPendingPostInput, PendingPostStatusUncheckedUpdateWithoutPendingPostInput>
    create: XOR<PendingPostStatusCreateWithoutPendingPostInput, PendingPostStatusUncheckedCreateWithoutPendingPostInput>
  }

  export type PendingPostStatusUpdateWithWhereUniqueWithoutPendingPostInput = {
    where: PendingPostStatusWhereUniqueInput
    data: XOR<PendingPostStatusUpdateWithoutPendingPostInput, PendingPostStatusUncheckedUpdateWithoutPendingPostInput>
  }

  export type PendingPostStatusUpdateManyWithWhereWithoutPendingPostInput = {
    where: PendingPostStatusScalarWhereInput
    data: XOR<PendingPostStatusUpdateManyMutationInput, PendingPostStatusUncheckedUpdateManyWithoutPendingPostInput>
  }

  export type PendingPostStatusScalarWhereInput = {
    AND?: PendingPostStatusScalarWhereInput | PendingPostStatusScalarWhereInput[]
    OR?: PendingPostStatusScalarWhereInput[]
    NOT?: PendingPostStatusScalarWhereInput | PendingPostStatusScalarWhereInput[]
    id?: IntFilter<"PendingPostStatus"> | number
    status?: StringNullableFilter<"PendingPostStatus"> | string | null
  }

  export type CommentCreateWithoutPostInput = {
    body?: string | null
    user: string
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: number
    body?: string | null
    user: string
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutPostInput = {
    user: string
  }

  export type LikeUncheckedCreateWithoutPostInput = {
    id?: number
    user: string
  }

  export type LikeCreateOrConnectWithoutPostInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput>
  }

  export type LikeCreateManyPostInputEnvelope = {
    data: LikeCreateManyPostInput | LikeCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    body?: StringNullableFilter<"Comment"> | string | null
    user?: StringFilter<"Comment"> | string
    post?: IntFilter<"Comment"> | number
  }

  export type LikeUpsertWithWhereUniqueWithoutPostInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutPostInput, LikeUncheckedUpdateWithoutPostInput>
    create: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutPostInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutPostInput, LikeUncheckedUpdateWithoutPostInput>
  }

  export type LikeUpdateManyWithWhereWithoutPostInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutPostInput>
  }

  export type LikeScalarWhereInput = {
    AND?: LikeScalarWhereInput | LikeScalarWhereInput[]
    OR?: LikeScalarWhereInput[]
    NOT?: LikeScalarWhereInput | LikeScalarWhereInput[]
    id?: IntFilter<"Like"> | number
    user?: StringFilter<"Like"> | string
    post?: IntFilter<"Like"> | number
  }

  export type UserCreateWithoutTokenInput = {
    id?: number
    username: string
    firstName: string
    lastName: string
    email: string
    password: string
    avatarUrl?: string | null
    bio?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    age?: number | null
    CommunityUser?: CommunityUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTokenInput = {
    id?: number
    username: string
    firstName: string
    lastName: string
    email: string
    password: string
    avatarUrl?: string | null
    bio?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    age?: number | null
    CommunityUser?: CommunityUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTokenInput, UserUncheckedCreateWithoutTokenInput>
  }

  export type UserUpsertWithoutTokenInput = {
    update: XOR<UserUpdateWithoutTokenInput, UserUncheckedUpdateWithoutTokenInput>
    create: XOR<UserCreateWithoutTokenInput, UserUncheckedCreateWithoutTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTokenInput, UserUncheckedUpdateWithoutTokenInput>
  }

  export type UserUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    CommunityUser?: CommunityUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    CommunityUser?: CommunityUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommunityUserCreateWithoutUserInput = {
    verifiedAt?: Date | string | null
    Community: CommunityCreateNestedOneWithoutCommunityUserInput
    UserRoles: UserRolesCreateNestedOneWithoutCommunityUserInput
  }

  export type CommunityUserUncheckedCreateWithoutUserInput = {
    id?: number
    community: number
    role: number
    verifiedAt?: Date | string | null
  }

  export type CommunityUserCreateOrConnectWithoutUserInput = {
    where: CommunityUserWhereUniqueInput
    create: XOR<CommunityUserCreateWithoutUserInput, CommunityUserUncheckedCreateWithoutUserInput>
  }

  export type CommunityUserCreateManyUserInputEnvelope = {
    data: CommunityUserCreateManyUserInput | CommunityUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TokenCreateWithoutUserInput = {
    refreshToken?: string | null
    accessToken?: string | null
    createdAt?: Date | string | null
  }

  export type TokenUncheckedCreateWithoutUserInput = {
    id?: number
    refreshToken?: string | null
    accessToken?: string | null
    createdAt?: Date | string | null
  }

  export type TokenCreateOrConnectWithoutUserInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenCreateManyUserInputEnvelope = {
    data: TokenCreateManyUserInput | TokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommunityUserUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityUserWhereUniqueInput
    update: XOR<CommunityUserUpdateWithoutUserInput, CommunityUserUncheckedUpdateWithoutUserInput>
    create: XOR<CommunityUserCreateWithoutUserInput, CommunityUserUncheckedCreateWithoutUserInput>
  }

  export type CommunityUserUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityUserWhereUniqueInput
    data: XOR<CommunityUserUpdateWithoutUserInput, CommunityUserUncheckedUpdateWithoutUserInput>
  }

  export type CommunityUserUpdateManyWithWhereWithoutUserInput = {
    where: CommunityUserScalarWhereInput
    data: XOR<CommunityUserUpdateManyMutationInput, CommunityUserUncheckedUpdateManyWithoutUserInput>
  }

  export type TokenUpsertWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    update: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenUpdateWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    data: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
  }

  export type TokenUpdateManyWithWhereWithoutUserInput = {
    where: TokenScalarWhereInput
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyWithoutUserInput>
  }

  export type TokenScalarWhereInput = {
    AND?: TokenScalarWhereInput | TokenScalarWhereInput[]
    OR?: TokenScalarWhereInput[]
    NOT?: TokenScalarWhereInput | TokenScalarWhereInput[]
    id?: IntFilter<"Token"> | number
    user?: StringFilter<"Token"> | string
    refreshToken?: StringNullableFilter<"Token"> | string | null
    accessToken?: StringNullableFilter<"Token"> | string | null
    createdAt?: DateTimeNullableFilter<"Token"> | Date | string | null
  }

  export type CommunityUserCreateWithoutUserRolesInput = {
    verifiedAt?: Date | string | null
    Community: CommunityCreateNestedOneWithoutCommunityUserInput
    User: UserCreateNestedOneWithoutCommunityUserInput
  }

  export type CommunityUserUncheckedCreateWithoutUserRolesInput = {
    id?: number
    community: number
    user: string
    verifiedAt?: Date | string | null
  }

  export type CommunityUserCreateOrConnectWithoutUserRolesInput = {
    where: CommunityUserWhereUniqueInput
    create: XOR<CommunityUserCreateWithoutUserRolesInput, CommunityUserUncheckedCreateWithoutUserRolesInput>
  }

  export type CommunityUserCreateManyUserRolesInputEnvelope = {
    data: CommunityUserCreateManyUserRolesInput | CommunityUserCreateManyUserRolesInput[]
    skipDuplicates?: boolean
  }

  export type CommunityUserUpsertWithWhereUniqueWithoutUserRolesInput = {
    where: CommunityUserWhereUniqueInput
    update: XOR<CommunityUserUpdateWithoutUserRolesInput, CommunityUserUncheckedUpdateWithoutUserRolesInput>
    create: XOR<CommunityUserCreateWithoutUserRolesInput, CommunityUserUncheckedCreateWithoutUserRolesInput>
  }

  export type CommunityUserUpdateWithWhereUniqueWithoutUserRolesInput = {
    where: CommunityUserWhereUniqueInput
    data: XOR<CommunityUserUpdateWithoutUserRolesInput, CommunityUserUncheckedUpdateWithoutUserRolesInput>
  }

  export type CommunityUserUpdateManyWithWhereWithoutUserRolesInput = {
    where: CommunityUserScalarWhereInput
    data: XOR<CommunityUserUpdateManyMutationInput, CommunityUserUncheckedUpdateManyWithoutUserRolesInput>
  }

  export type EmailForCreateWithoutEmailInput = {
    id: number
    for?: string | null
  }

  export type EmailForUncheckedCreateWithoutEmailInput = {
    id: number
    for?: string | null
  }

  export type EmailForCreateOrConnectWithoutEmailInput = {
    where: EmailForWhereUniqueInput
    create: XOR<EmailForCreateWithoutEmailInput, EmailForUncheckedCreateWithoutEmailInput>
  }

  export type EmailForUpsertWithoutEmailInput = {
    update: XOR<EmailForUpdateWithoutEmailInput, EmailForUncheckedUpdateWithoutEmailInput>
    create: XOR<EmailForCreateWithoutEmailInput, EmailForUncheckedCreateWithoutEmailInput>
    where?: EmailForWhereInput
  }

  export type EmailForUpdateToOneWithWhereWithoutEmailInput = {
    where?: EmailForWhereInput
    data: XOR<EmailForUpdateWithoutEmailInput, EmailForUncheckedUpdateWithoutEmailInput>
  }

  export type EmailForUpdateWithoutEmailInput = {
    id?: IntFieldUpdateOperationsInput | number
    for?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailForUncheckedUpdateWithoutEmailInput = {
    id?: IntFieldUpdateOperationsInput | number
    for?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailCreateWithoutEmailForInput = {
    email?: string | null
    verificationCode?: string | null
    messageId?: string | null
    createdAt?: Date | string | null
  }

  export type EmailUncheckedCreateWithoutEmailForInput = {
    id?: number
    email?: string | null
    verificationCode?: string | null
    messageId?: string | null
    createdAt?: Date | string | null
  }

  export type EmailCreateOrConnectWithoutEmailForInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutEmailForInput, EmailUncheckedCreateWithoutEmailForInput>
  }

  export type EmailCreateManyEmailForInputEnvelope = {
    data: EmailCreateManyEmailForInput | EmailCreateManyEmailForInput[]
    skipDuplicates?: boolean
  }

  export type EmailUpsertWithWhereUniqueWithoutEmailForInput = {
    where: EmailWhereUniqueInput
    update: XOR<EmailUpdateWithoutEmailForInput, EmailUncheckedUpdateWithoutEmailForInput>
    create: XOR<EmailCreateWithoutEmailForInput, EmailUncheckedCreateWithoutEmailForInput>
  }

  export type EmailUpdateWithWhereUniqueWithoutEmailForInput = {
    where: EmailWhereUniqueInput
    data: XOR<EmailUpdateWithoutEmailForInput, EmailUncheckedUpdateWithoutEmailForInput>
  }

  export type EmailUpdateManyWithWhereWithoutEmailForInput = {
    where: EmailScalarWhereInput
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyWithoutEmailForInput>
  }

  export type EmailScalarWhereInput = {
    AND?: EmailScalarWhereInput | EmailScalarWhereInput[]
    OR?: EmailScalarWhereInput[]
    NOT?: EmailScalarWhereInput | EmailScalarWhereInput[]
    id?: IntFilter<"Email"> | number
    email?: StringNullableFilter<"Email"> | string | null
    verificationCode?: StringNullableFilter<"Email"> | string | null
    messageId?: StringNullableFilter<"Email"> | string | null
    for?: IntNullableFilter<"Email"> | number | null
    createdAt?: DateTimeNullableFilter<"Email"> | Date | string | null
  }

  export type LeaderboardSubmissionCreateWithoutLeaderboardInput = {
    user?: string | null
    community?: number | null
    entryUrl?: string | null
    verifiedBy?: number | null
    weight?: string | null
    type?: number | null
    verifiedAt?: Date | string | null
    rank?: number | null
    LeaderboardSubmissionType?: LeaderboardSubmissionTypeCreateNestedManyWithoutLeaderboardSubmissionInput
  }

  export type LeaderboardSubmissionUncheckedCreateWithoutLeaderboardInput = {
    id?: number
    user?: string | null
    community?: number | null
    entryUrl?: string | null
    verifiedBy?: number | null
    weight?: string | null
    type?: number | null
    verifiedAt?: Date | string | null
    rank?: number | null
    LeaderboardSubmissionType?: LeaderboardSubmissionTypeUncheckedCreateNestedManyWithoutLeaderboardSubmissionInput
  }

  export type LeaderboardSubmissionCreateOrConnectWithoutLeaderboardInput = {
    where: LeaderboardSubmissionWhereUniqueInput
    create: XOR<LeaderboardSubmissionCreateWithoutLeaderboardInput, LeaderboardSubmissionUncheckedCreateWithoutLeaderboardInput>
  }

  export type LeaderboardSubmissionCreateManyLeaderboardInputEnvelope = {
    data: LeaderboardSubmissionCreateManyLeaderboardInput | LeaderboardSubmissionCreateManyLeaderboardInput[]
    skipDuplicates?: boolean
  }

  export type LeaderboardSubmissionUpsertWithWhereUniqueWithoutLeaderboardInput = {
    where: LeaderboardSubmissionWhereUniqueInput
    update: XOR<LeaderboardSubmissionUpdateWithoutLeaderboardInput, LeaderboardSubmissionUncheckedUpdateWithoutLeaderboardInput>
    create: XOR<LeaderboardSubmissionCreateWithoutLeaderboardInput, LeaderboardSubmissionUncheckedCreateWithoutLeaderboardInput>
  }

  export type LeaderboardSubmissionUpdateWithWhereUniqueWithoutLeaderboardInput = {
    where: LeaderboardSubmissionWhereUniqueInput
    data: XOR<LeaderboardSubmissionUpdateWithoutLeaderboardInput, LeaderboardSubmissionUncheckedUpdateWithoutLeaderboardInput>
  }

  export type LeaderboardSubmissionUpdateManyWithWhereWithoutLeaderboardInput = {
    where: LeaderboardSubmissionScalarWhereInput
    data: XOR<LeaderboardSubmissionUpdateManyMutationInput, LeaderboardSubmissionUncheckedUpdateManyWithoutLeaderboardInput>
  }

  export type LeaderboardSubmissionScalarWhereInput = {
    AND?: LeaderboardSubmissionScalarWhereInput | LeaderboardSubmissionScalarWhereInput[]
    OR?: LeaderboardSubmissionScalarWhereInput[]
    NOT?: LeaderboardSubmissionScalarWhereInput | LeaderboardSubmissionScalarWhereInput[]
    id?: IntFilter<"LeaderboardSubmission"> | number
    user?: StringNullableFilter<"LeaderboardSubmission"> | string | null
    community?: IntNullableFilter<"LeaderboardSubmission"> | number | null
    entryUrl?: StringNullableFilter<"LeaderboardSubmission"> | string | null
    verifiedBy?: IntNullableFilter<"LeaderboardSubmission"> | number | null
    weight?: StringNullableFilter<"LeaderboardSubmission"> | string | null
    type?: IntNullableFilter<"LeaderboardSubmission"> | number | null
    verifiedAt?: DateTimeNullableFilter<"LeaderboardSubmission"> | Date | string | null
    rank?: IntNullableFilter<"LeaderboardSubmission"> | number | null
    leaderboardId?: IntNullableFilter<"LeaderboardSubmission"> | number | null
  }

  export type LeaderboardSubmissionTypeCreateWithoutLeaderboardSubmissionInput = {
    id: number
    type?: string | null
  }

  export type LeaderboardSubmissionTypeUncheckedCreateWithoutLeaderboardSubmissionInput = {
    id: number
    type?: string | null
  }

  export type LeaderboardSubmissionTypeCreateOrConnectWithoutLeaderboardSubmissionInput = {
    where: LeaderboardSubmissionTypeWhereUniqueInput
    create: XOR<LeaderboardSubmissionTypeCreateWithoutLeaderboardSubmissionInput, LeaderboardSubmissionTypeUncheckedCreateWithoutLeaderboardSubmissionInput>
  }

  export type LeaderboardSubmissionTypeCreateManyLeaderboardSubmissionInputEnvelope = {
    data: LeaderboardSubmissionTypeCreateManyLeaderboardSubmissionInput | LeaderboardSubmissionTypeCreateManyLeaderboardSubmissionInput[]
    skipDuplicates?: boolean
  }

  export type LeaderboardCreateWithoutLeaderboardSubmissionInput = {
    community: number
  }

  export type LeaderboardUncheckedCreateWithoutLeaderboardSubmissionInput = {
    id?: number
    community: number
  }

  export type LeaderboardCreateOrConnectWithoutLeaderboardSubmissionInput = {
    where: LeaderboardWhereUniqueInput
    create: XOR<LeaderboardCreateWithoutLeaderboardSubmissionInput, LeaderboardUncheckedCreateWithoutLeaderboardSubmissionInput>
  }

  export type LeaderboardSubmissionTypeUpsertWithWhereUniqueWithoutLeaderboardSubmissionInput = {
    where: LeaderboardSubmissionTypeWhereUniqueInput
    update: XOR<LeaderboardSubmissionTypeUpdateWithoutLeaderboardSubmissionInput, LeaderboardSubmissionTypeUncheckedUpdateWithoutLeaderboardSubmissionInput>
    create: XOR<LeaderboardSubmissionTypeCreateWithoutLeaderboardSubmissionInput, LeaderboardSubmissionTypeUncheckedCreateWithoutLeaderboardSubmissionInput>
  }

  export type LeaderboardSubmissionTypeUpdateWithWhereUniqueWithoutLeaderboardSubmissionInput = {
    where: LeaderboardSubmissionTypeWhereUniqueInput
    data: XOR<LeaderboardSubmissionTypeUpdateWithoutLeaderboardSubmissionInput, LeaderboardSubmissionTypeUncheckedUpdateWithoutLeaderboardSubmissionInput>
  }

  export type LeaderboardSubmissionTypeUpdateManyWithWhereWithoutLeaderboardSubmissionInput = {
    where: LeaderboardSubmissionTypeScalarWhereInput
    data: XOR<LeaderboardSubmissionTypeUpdateManyMutationInput, LeaderboardSubmissionTypeUncheckedUpdateManyWithoutLeaderboardSubmissionInput>
  }

  export type LeaderboardSubmissionTypeScalarWhereInput = {
    AND?: LeaderboardSubmissionTypeScalarWhereInput | LeaderboardSubmissionTypeScalarWhereInput[]
    OR?: LeaderboardSubmissionTypeScalarWhereInput[]
    NOT?: LeaderboardSubmissionTypeScalarWhereInput | LeaderboardSubmissionTypeScalarWhereInput[]
    id?: IntFilter<"LeaderboardSubmissionType"> | number
    type?: StringNullableFilter<"LeaderboardSubmissionType"> | string | null
    leaderboardSubmissionId?: IntNullableFilter<"LeaderboardSubmissionType"> | number | null
  }

  export type LeaderboardUpsertWithoutLeaderboardSubmissionInput = {
    update: XOR<LeaderboardUpdateWithoutLeaderboardSubmissionInput, LeaderboardUncheckedUpdateWithoutLeaderboardSubmissionInput>
    create: XOR<LeaderboardCreateWithoutLeaderboardSubmissionInput, LeaderboardUncheckedCreateWithoutLeaderboardSubmissionInput>
    where?: LeaderboardWhereInput
  }

  export type LeaderboardUpdateToOneWithWhereWithoutLeaderboardSubmissionInput = {
    where?: LeaderboardWhereInput
    data: XOR<LeaderboardUpdateWithoutLeaderboardSubmissionInput, LeaderboardUncheckedUpdateWithoutLeaderboardSubmissionInput>
  }

  export type LeaderboardUpdateWithoutLeaderboardSubmissionInput = {
    community?: IntFieldUpdateOperationsInput | number
  }

  export type LeaderboardUncheckedUpdateWithoutLeaderboardSubmissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
  }

  export type LeaderboardSubmissionCreateWithoutLeaderboardSubmissionTypeInput = {
    user?: string | null
    community?: number | null
    entryUrl?: string | null
    verifiedBy?: number | null
    weight?: string | null
    type?: number | null
    verifiedAt?: Date | string | null
    rank?: number | null
    Leaderboard?: LeaderboardCreateNestedOneWithoutLeaderboardSubmissionInput
  }

  export type LeaderboardSubmissionUncheckedCreateWithoutLeaderboardSubmissionTypeInput = {
    id?: number
    user?: string | null
    community?: number | null
    entryUrl?: string | null
    verifiedBy?: number | null
    weight?: string | null
    type?: number | null
    verifiedAt?: Date | string | null
    rank?: number | null
    leaderboardId?: number | null
  }

  export type LeaderboardSubmissionCreateOrConnectWithoutLeaderboardSubmissionTypeInput = {
    where: LeaderboardSubmissionWhereUniqueInput
    create: XOR<LeaderboardSubmissionCreateWithoutLeaderboardSubmissionTypeInput, LeaderboardSubmissionUncheckedCreateWithoutLeaderboardSubmissionTypeInput>
  }

  export type LeaderboardSubmissionUpsertWithoutLeaderboardSubmissionTypeInput = {
    update: XOR<LeaderboardSubmissionUpdateWithoutLeaderboardSubmissionTypeInput, LeaderboardSubmissionUncheckedUpdateWithoutLeaderboardSubmissionTypeInput>
    create: XOR<LeaderboardSubmissionCreateWithoutLeaderboardSubmissionTypeInput, LeaderboardSubmissionUncheckedCreateWithoutLeaderboardSubmissionTypeInput>
    where?: LeaderboardSubmissionWhereInput
  }

  export type LeaderboardSubmissionUpdateToOneWithWhereWithoutLeaderboardSubmissionTypeInput = {
    where?: LeaderboardSubmissionWhereInput
    data: XOR<LeaderboardSubmissionUpdateWithoutLeaderboardSubmissionTypeInput, LeaderboardSubmissionUncheckedUpdateWithoutLeaderboardSubmissionTypeInput>
  }

  export type LeaderboardSubmissionUpdateWithoutLeaderboardSubmissionTypeInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    Leaderboard?: LeaderboardUpdateOneWithoutLeaderboardSubmissionNestedInput
  }

  export type LeaderboardSubmissionUncheckedUpdateWithoutLeaderboardSubmissionTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    leaderboardId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PendingPostCreateWithoutPendingPostStatusInput = {
    Content?: string | null
    fileUrl: string
    community: number
    user: string
    caption?: string | null
    status?: number | null
    confirmationToken?: string | null
  }

  export type PendingPostUncheckedCreateWithoutPendingPostStatusInput = {
    id?: number
    Content?: string | null
    fileUrl: string
    community: number
    user: string
    caption?: string | null
    status?: number | null
    confirmationToken?: string | null
  }

  export type PendingPostCreateOrConnectWithoutPendingPostStatusInput = {
    where: PendingPostWhereUniqueInput
    create: XOR<PendingPostCreateWithoutPendingPostStatusInput, PendingPostUncheckedCreateWithoutPendingPostStatusInput>
  }

  export type PendingPostUpsertWithWhereUniqueWithoutPendingPostStatusInput = {
    where: PendingPostWhereUniqueInput
    update: XOR<PendingPostUpdateWithoutPendingPostStatusInput, PendingPostUncheckedUpdateWithoutPendingPostStatusInput>
    create: XOR<PendingPostCreateWithoutPendingPostStatusInput, PendingPostUncheckedCreateWithoutPendingPostStatusInput>
  }

  export type PendingPostUpdateWithWhereUniqueWithoutPendingPostStatusInput = {
    where: PendingPostWhereUniqueInput
    data: XOR<PendingPostUpdateWithoutPendingPostStatusInput, PendingPostUncheckedUpdateWithoutPendingPostStatusInput>
  }

  export type PendingPostUpdateManyWithWhereWithoutPendingPostStatusInput = {
    where: PendingPostScalarWhereInput
    data: XOR<PendingPostUpdateManyMutationInput, PendingPostUncheckedUpdateManyWithoutPendingPostStatusInput>
  }

  export type PendingPostScalarWhereInput = {
    AND?: PendingPostScalarWhereInput | PendingPostScalarWhereInput[]
    OR?: PendingPostScalarWhereInput[]
    NOT?: PendingPostScalarWhereInput | PendingPostScalarWhereInput[]
    id?: IntFilter<"PendingPost"> | number
    Content?: StringNullableFilter<"PendingPost"> | string | null
    fileUrl?: StringFilter<"PendingPost"> | string
    community?: IntFilter<"PendingPost"> | number
    user?: StringFilter<"PendingPost"> | string
    caption?: StringNullableFilter<"PendingPost"> | string | null
    status?: IntNullableFilter<"PendingPost"> | number | null
    confirmationToken?: StringNullableFilter<"PendingPost"> | string | null
  }

  export type LogCreateWithoutLogLevelInput = {
    user?: string | null
    context?: number | null
    message?: string | null
    timestamp?: Date | string | null
    LogType?: LogTypeCreateNestedOneWithoutLogInput
  }

  export type LogUncheckedCreateWithoutLogLevelInput = {
    id?: number
    user?: string | null
    context?: number | null
    message?: string | null
    type?: number | null
    timestamp?: Date | string | null
  }

  export type LogCreateOrConnectWithoutLogLevelInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutLogLevelInput, LogUncheckedCreateWithoutLogLevelInput>
  }

  export type LogCreateManyLogLevelInputEnvelope = {
    data: LogCreateManyLogLevelInput | LogCreateManyLogLevelInput[]
    skipDuplicates?: boolean
  }

  export type LogUpsertWithWhereUniqueWithoutLogLevelInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutLogLevelInput, LogUncheckedUpdateWithoutLogLevelInput>
    create: XOR<LogCreateWithoutLogLevelInput, LogUncheckedCreateWithoutLogLevelInput>
  }

  export type LogUpdateWithWhereUniqueWithoutLogLevelInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutLogLevelInput, LogUncheckedUpdateWithoutLogLevelInput>
  }

  export type LogUpdateManyWithWhereWithoutLogLevelInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutLogLevelInput>
  }

  export type LogScalarWhereInput = {
    AND?: LogScalarWhereInput | LogScalarWhereInput[]
    OR?: LogScalarWhereInput[]
    NOT?: LogScalarWhereInput | LogScalarWhereInput[]
    id?: IntFilter<"Log"> | number
    user?: StringNullableFilter<"Log"> | string | null
    context?: IntNullableFilter<"Log"> | number | null
    message?: StringNullableFilter<"Log"> | string | null
    type?: IntNullableFilter<"Log"> | number | null
    level?: IntNullableFilter<"Log"> | number | null
    timestamp?: DateTimeNullableFilter<"Log"> | Date | string | null
  }

  export type LogCreateWithoutLogTypeInput = {
    user?: string | null
    context?: number | null
    message?: string | null
    timestamp?: Date | string | null
    LogLevel?: LogLevelCreateNestedOneWithoutLogInput
  }

  export type LogUncheckedCreateWithoutLogTypeInput = {
    id?: number
    user?: string | null
    context?: number | null
    message?: string | null
    level?: number | null
    timestamp?: Date | string | null
  }

  export type LogCreateOrConnectWithoutLogTypeInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutLogTypeInput, LogUncheckedCreateWithoutLogTypeInput>
  }

  export type LogCreateManyLogTypeInputEnvelope = {
    data: LogCreateManyLogTypeInput | LogCreateManyLogTypeInput[]
    skipDuplicates?: boolean
  }

  export type LogUpsertWithWhereUniqueWithoutLogTypeInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutLogTypeInput, LogUncheckedUpdateWithoutLogTypeInput>
    create: XOR<LogCreateWithoutLogTypeInput, LogUncheckedCreateWithoutLogTypeInput>
  }

  export type LogUpdateWithWhereUniqueWithoutLogTypeInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutLogTypeInput, LogUncheckedUpdateWithoutLogTypeInput>
  }

  export type LogUpdateManyWithWhereWithoutLogTypeInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutLogTypeInput>
  }

  export type CommunityCreateWithoutCommunityUserInput = {
    name?: string | null
    description?: string | null
    CommunityRequest?: CommunityRequestCreateNestedManyWithoutCommunityInput
    BannedUsers?: BannedUsersCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutCommunityUserInput = {
    id?: number
    name?: string | null
    description?: string | null
    CommunityRequest?: CommunityRequestUncheckedCreateNestedManyWithoutCommunityInput
    BannedUsers?: BannedUsersUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutCommunityUserInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutCommunityUserInput, CommunityUncheckedCreateWithoutCommunityUserInput>
  }

  export type UserRolesCreateWithoutCommunityUserInput = {
    id: number
    role?: string | null
  }

  export type UserRolesUncheckedCreateWithoutCommunityUserInput = {
    id: number
    role?: string | null
  }

  export type UserRolesCreateOrConnectWithoutCommunityUserInput = {
    where: UserRolesWhereUniqueInput
    create: XOR<UserRolesCreateWithoutCommunityUserInput, UserRolesUncheckedCreateWithoutCommunityUserInput>
  }

  export type UserCreateWithoutCommunityUserInput = {
    id?: number
    username: string
    firstName: string
    lastName: string
    email: string
    password: string
    avatarUrl?: string | null
    bio?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    age?: number | null
    Token?: TokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityUserInput = {
    id?: number
    username: string
    firstName: string
    lastName: string
    email: string
    password: string
    avatarUrl?: string | null
    bio?: string | null
    createdAt?: Date | string | null
    isEmailVerified?: boolean | null
    height?: number | null
    weight?: number | null
    age?: number | null
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommunityUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunityUserInput, UserUncheckedCreateWithoutCommunityUserInput>
  }

  export type CommunityUpsertWithoutCommunityUserInput = {
    update: XOR<CommunityUpdateWithoutCommunityUserInput, CommunityUncheckedUpdateWithoutCommunityUserInput>
    create: XOR<CommunityCreateWithoutCommunityUserInput, CommunityUncheckedCreateWithoutCommunityUserInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutCommunityUserInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutCommunityUserInput, CommunityUncheckedUpdateWithoutCommunityUserInput>
  }

  export type CommunityUpdateWithoutCommunityUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    CommunityRequest?: CommunityRequestUpdateManyWithoutCommunityNestedInput
    BannedUsers?: BannedUsersUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutCommunityUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    CommunityRequest?: CommunityRequestUncheckedUpdateManyWithoutCommunityNestedInput
    BannedUsers?: BannedUsersUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type UserRolesUpsertWithoutCommunityUserInput = {
    update: XOR<UserRolesUpdateWithoutCommunityUserInput, UserRolesUncheckedUpdateWithoutCommunityUserInput>
    create: XOR<UserRolesCreateWithoutCommunityUserInput, UserRolesUncheckedCreateWithoutCommunityUserInput>
    where?: UserRolesWhereInput
  }

  export type UserRolesUpdateToOneWithWhereWithoutCommunityUserInput = {
    where?: UserRolesWhereInput
    data: XOR<UserRolesUpdateWithoutCommunityUserInput, UserRolesUncheckedUpdateWithoutCommunityUserInput>
  }

  export type UserRolesUpdateWithoutCommunityUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRolesUncheckedUpdateWithoutCommunityUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutCommunityUserInput = {
    update: XOR<UserUpdateWithoutCommunityUserInput, UserUncheckedUpdateWithoutCommunityUserInput>
    create: XOR<UserCreateWithoutCommunityUserInput, UserUncheckedCreateWithoutCommunityUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommunityUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommunityUserInput, UserUncheckedUpdateWithoutCommunityUserInput>
  }

  export type UserUpdateWithoutCommunityUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    Token?: TokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommunityUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommunityUserCreateManyCommunityInput = {
    id?: number
    user: string
    role: number
    verifiedAt?: Date | string | null
  }

  export type CommunityRequestCreateManyCommunityInput = {
    id?: number
    user?: string | null
    requestedAt?: Date | string | null
    message?: string | null
  }

  export type BannedUsersCreateManyCommunityInput = {
    id?: number
    user: string
    reasonId?: number | null
  }

  export type CommunityUserUpdateWithoutCommunityInput = {
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserRoles?: UserRolesUpdateOneRequiredWithoutCommunityUserNestedInput
    User?: UserUpdateOneRequiredWithoutCommunityUserNestedInput
  }

  export type CommunityUserUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    role?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommunityUserUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    role?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommunityRequestUpdateWithoutCommunityInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunityRequestUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunityRequestUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BannedUsersUpdateWithoutCommunityInput = {
    user?: StringFieldUpdateOperationsInput | string
    reasonId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BannedUsersUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    reasonId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BannedUsersUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    reasonId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PendingPostStatusUpdateWithoutPendingPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PendingPostStatusUncheckedUpdateWithoutPendingPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PendingPostStatusUncheckedUpdateManyWithoutPendingPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateManyPostInput = {
    id?: number
    body?: string | null
    user: string
  }

  export type LikeCreateManyPostInput = {
    id?: number
    user: string
  }

  export type CommentUpdateWithoutPostInput = {
    body?: NullableStringFieldUpdateOperationsInput | string | null
    user?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: NullableStringFieldUpdateOperationsInput | string | null
    user?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: NullableStringFieldUpdateOperationsInput | string | null
    user?: StringFieldUpdateOperationsInput | string
  }

  export type LikeUpdateWithoutPostInput = {
    user?: StringFieldUpdateOperationsInput | string
  }

  export type LikeUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
  }

  export type LikeUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
  }

  export type CommunityUserCreateManyUserInput = {
    id?: number
    community: number
    role: number
    verifiedAt?: Date | string | null
  }

  export type TokenCreateManyUserInput = {
    id?: number
    refreshToken?: string | null
    accessToken?: string | null
    createdAt?: Date | string | null
  }

  export type CommunityUserUpdateWithoutUserInput = {
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Community?: CommunityUpdateOneRequiredWithoutCommunityUserNestedInput
    UserRoles?: UserRolesUpdateOneRequiredWithoutCommunityUserNestedInput
  }

  export type CommunityUserUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
    role?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommunityUserUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
    role?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TokenUpdateWithoutUserInput = {
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommunityUserCreateManyUserRolesInput = {
    id?: number
    community: number
    user: string
    verifiedAt?: Date | string | null
  }

  export type CommunityUserUpdateWithoutUserRolesInput = {
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Community?: CommunityUpdateOneRequiredWithoutCommunityUserNestedInput
    User?: UserUpdateOneRequiredWithoutCommunityUserNestedInput
  }

  export type CommunityUserUncheckedUpdateWithoutUserRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommunityUserUncheckedUpdateManyWithoutUserRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailCreateManyEmailForInput = {
    id?: number
    email?: string | null
    verificationCode?: string | null
    messageId?: string | null
    createdAt?: Date | string | null
  }

  export type EmailUpdateWithoutEmailForInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailUncheckedUpdateWithoutEmailForInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailUncheckedUpdateManyWithoutEmailForInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaderboardSubmissionCreateManyLeaderboardInput = {
    id?: number
    user?: string | null
    community?: number | null
    entryUrl?: string | null
    verifiedBy?: number | null
    weight?: string | null
    type?: number | null
    verifiedAt?: Date | string | null
    rank?: number | null
  }

  export type LeaderboardSubmissionUpdateWithoutLeaderboardInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    LeaderboardSubmissionType?: LeaderboardSubmissionTypeUpdateManyWithoutLeaderboardSubmissionNestedInput
  }

  export type LeaderboardSubmissionUncheckedUpdateWithoutLeaderboardInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    LeaderboardSubmissionType?: LeaderboardSubmissionTypeUncheckedUpdateManyWithoutLeaderboardSubmissionNestedInput
  }

  export type LeaderboardSubmissionUncheckedUpdateManyWithoutLeaderboardInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    community?: NullableIntFieldUpdateOperationsInput | number | null
    entryUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LeaderboardSubmissionTypeCreateManyLeaderboardSubmissionInput = {
    id: number
    type?: string | null
  }

  export type LeaderboardSubmissionTypeUpdateWithoutLeaderboardSubmissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeaderboardSubmissionTypeUncheckedUpdateWithoutLeaderboardSubmissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeaderboardSubmissionTypeUncheckedUpdateManyWithoutLeaderboardSubmissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PendingPostUpdateWithoutPendingPostStatusInput = {
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    confirmationToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PendingPostUncheckedUpdateWithoutPendingPostStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    confirmationToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PendingPostUncheckedUpdateManyWithoutPendingPostStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    community?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    confirmationToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogCreateManyLogLevelInput = {
    id?: number
    user?: string | null
    context?: number | null
    message?: string | null
    type?: number | null
    timestamp?: Date | string | null
  }

  export type LogUpdateWithoutLogLevelInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LogType?: LogTypeUpdateOneWithoutLogNestedInput
  }

  export type LogUncheckedUpdateWithoutLogLevelInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogUncheckedUpdateManyWithoutLogLevelInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogCreateManyLogTypeInput = {
    id?: number
    user?: string | null
    context?: number | null
    message?: string | null
    level?: number | null
    timestamp?: Date | string | null
  }

  export type LogUpdateWithoutLogTypeInput = {
    user?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LogLevel?: LogLevelUpdateOneWithoutLogNestedInput
  }

  export type LogUncheckedUpdateWithoutLogTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogUncheckedUpdateManyWithoutLogTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CommunityCountOutputTypeDefaultArgs instead
     */
    export type CommunityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PendingPostCountOutputTypeDefaultArgs instead
     */
    export type PendingPostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PendingPostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostCountOutputTypeDefaultArgs instead
     */
    export type PostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRolesCountOutputTypeDefaultArgs instead
     */
    export type UserRolesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRolesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailForCountOutputTypeDefaultArgs instead
     */
    export type EmailForCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailForCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaderboardCountOutputTypeDefaultArgs instead
     */
    export type LeaderboardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaderboardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaderboardSubmissionCountOutputTypeDefaultArgs instead
     */
    export type LeaderboardSubmissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaderboardSubmissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PendingPostStatusCountOutputTypeDefaultArgs instead
     */
    export type PendingPostStatusCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PendingPostStatusCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogLevelCountOutputTypeDefaultArgs instead
     */
    export type LogLevelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogLevelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogTypeCountOutputTypeDefaultArgs instead
     */
    export type LogTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminDefaultArgs instead
     */
    export type AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminTokenDefaultArgs instead
     */
    export type AdminTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BannedUsersDefaultArgs instead
     */
    export type BannedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BannedUsersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityDefaultArgs instead
     */
    export type CommunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityRequestDefaultArgs instead
     */
    export type CommunityRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContextDefaultArgs instead
     */
    export type ContextArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContextDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LikeDefaultArgs instead
     */
    export type LikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LikeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogDefaultArgs instead
     */
    export type LogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PendingPostDefaultArgs instead
     */
    export type PendingPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PendingPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostDefaultArgs instead
     */
    export type PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PreferencesDefaultArgs instead
     */
    export type PreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PreferencesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RelationshipDefaultArgs instead
     */
    export type RelationshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RelationshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TokenDefaultArgs instead
     */
    export type TokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRolesDefaultArgs instead
     */
    export type UserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailDefaultArgs instead
     */
    export type EmailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailForDefaultArgs instead
     */
    export type EmailForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailForDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaderboardDefaultArgs instead
     */
    export type LeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaderboardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaderboardSubmissionDefaultArgs instead
     */
    export type LeaderboardSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaderboardSubmissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaderboardSubmissionTypeDefaultArgs instead
     */
    export type LeaderboardSubmissionTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaderboardSubmissionTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PendingPostStatusDefaultArgs instead
     */
    export type PendingPostStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PendingPostStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogLevelDefaultArgs instead
     */
    export type LogLevelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogLevelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogTypeDefaultArgs instead
     */
    export type LogTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SuspiciousLoginDefaultArgs instead
     */
    export type SuspiciousLoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SuspiciousLoginDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityUserDefaultArgs instead
     */
    export type CommunityUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityUserDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}